/*!
 * Front for marketdo4a.com 1.4.0-beta.1 
 * (c) 2020 Roman Meshcheryakov
 */
(window.webpackJsonp=window.webpackJsonp||[]).push([[14,12],{11:function(module,exports){eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcz8zNmM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n")},14:function(module,exports){eval("module.exports = jQuery;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")},15:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Multifilter; });\n/* unused harmony export RadioFilter */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return PriceFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CheckboxFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return SelectFilter; });\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);\n/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21);\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6);\n/* harmony import */ var _catalog_FilterCheckbox_vue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22);\n/* harmony import */ var _catalog_FilterSelect_vue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23);\n/* harmony import */ var _catalog_FilterPrice_vue__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(24);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3);\n\n\n\n\n\n\n\n\n\n// import SimpleBar from 'simplebar';\n// import noUiSlider from 'nouislider';\n // import MultifilterRadio from './catalog/MultifilterRadio.vue';\n\n\n\n\n\n/*\n Прости меня господь за эту хуиту ((\n */\n\nvar Multifilter =\n/*#__PURE__*/\nfunction () {\n  function Multifilter(el, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, Multifilter);\n\n    if (!el) return;\n    this.el = el;\n    this.valueEl = this.el.querySelector('.multifilter__value');\n    this.contentEl = this.el.querySelector('.dropdown-menu');\n    this.menuButton = this.el.querySelector('button.multifilter__content');\n    this.inputList = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6___default()(this.el.querySelectorAll('input'));\n    this.callback = callback;\n    this.options = {\n      type: options.type || 'simple',\n      // 'checkbox', 'radio', 'price'\n      replaceTitle: options.replaceTitle || false\n    };\n\n    if (this.options.type === 'simple') {\n      // this.inputList.forEach(item => item.addEventListener('change', this.callback));\n      this.el.addEventListener('change', function (event) {\n        return _this.callback(event);\n      });\n    }\n  }\n  /**\n   * Инициализирует кастомную прокрутку\n   *\n   * @returns {SimpleBar|boolean}\n   */\n\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(Multifilter, [{\n    key: \"initScrollbar\",\n    value: function initScrollbar() {\n      if (!this.contentEl) return false; // const simpleBar = new SimpleBar(this.contentEl, { autoHide: false });\n      // this.contentEl = simpleBar.getContentElement();\n      // return simpleBar;\n    }\n    /**\n     * Обновляет заголовок\n     *\n     * @param {Array|String} [title=''] - Строка или массив вставляемых значений\n     * @returns {String} title\n     */\n\n  }, {\n    key: \"updateTitle\",\n    value: function updateTitle() {\n      var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var newTitle = Array.isArray(title) ? title.join(', ') : title;\n\n      if (newTitle === '') {\n        newTitle = 'Не выбрано';\n      }\n\n      this.valueEl.innerHTML = newTitle;\n      return title;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.inputList.forEach(function (input) {\n        if (!(input.disabled || !input.type)) {\n          switch (input.type.toLowerCase()) {\n            case 'text':\n            case 'password':\n            case 'textarea':\n            case 'hidden':\n              input.value = '';\n              break;\n\n            case 'radio':\n              if (!input.hasAttribute('checked')) {\n                input.checked = false;\n              }\n\n              break;\n\n            case 'checkbox':\n              input.checked = false;\n              break;\n\n            case 'select-one':\n            case 'select-multi':\n              input.selectedIndex = -1;\n              break;\n\n            default:\n              break;\n          }\n        }\n      });\n      this.callback(this);\n    }\n  }]);\n\n  return Multifilter;\n}();\n/**\n * RadioFilter\n */\n\nvar RadioFilter =\n/*#__PURE__*/\nfunction (_Multifilter) {\n  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(RadioFilter, _Multifilter);\n\n  function RadioFilter(el, callback) {\n    var _this2;\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, RadioFilter);\n\n    _this2 = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter).call(this, el, callback, {\n      type: 'radio'\n    }));\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2), \"onChange\", function (event) {\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"updateTitle\", _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2)).call(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2), event.target.nextElementSibling.textContent);\n\n      _this2.callback(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2));\n    });\n\n    _this2.el.addEventListener('change', _this2.onChange);\n\n    _this2.defaultInput = _this2.el.querySelector('input[checked]');\n\n    _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"updateTitle\", _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2)).call(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2), _this2.defaultInput.nextElementSibling.textContent);\n\n    if (_this2.inputList.length > 9) {\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"initScrollbar\", _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2)).call(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2));\n    }\n\n    return _this2;\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(RadioFilter, [{\n    key: \"reset\",\n    value: function reset() {\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"reset\", this).call(this); // this.defaultInput.checked = true;\n\n\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"updateTitle\", this).call(this, this.defaultInput.nextElementSibling.textContent); // this.callback(this);\n\n    }\n  }]);\n\n  return RadioFilter;\n}(Multifilter);\n/**\n * PriceFilter\n */\n\nvar PriceFilter =\n/*#__PURE__*/\nfunction () {\n  function PriceFilter(el) {\n    var _this3 = this;\n\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'filters';\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, PriceFilter);\n\n    this.el = el;\n    this.container = container;\n    this.filterSettings = PriceFilter.parseSettings(this.el);\n    _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].commit('filters/pushFilterToContainer', {\n      container: this.container,\n      filter: this.filterSettings\n    });\n    new vue__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]({\n      store: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"],\n      render: function render(h) {\n        return h(_catalog_FilterPrice_vue__WEBPACK_IMPORTED_MODULE_12__[/* default */ \"a\"], {\n          props: {\n            filter: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].state.filters[_this3.container][_this3.filterSettings.name]\n          }\n        });\n      }\n    }).$mount(this.el);\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(PriceFilter, null, [{\n    key: \"parseSettings\",\n    value: function parseSettings(multifilterEl) {\n      var container = multifilterEl.querySelector('.multifilter-price');\n      var option = {\n        label: multifilterEl.querySelector('.multifilter__value').textContent,\n        type: 'range',\n        name: 'price',\n        data: {\n          minRange: null,\n          maxRange: null,\n          priceFrom: 0,\n          priceTo: 0,\n          priceMin: 0,\n          priceMax: 10000\n        }\n      };\n\n      if (container.querySelector('input[name=\"price[from]\"]')) {\n        option.data.priceFrom = parseInt(container.querySelector('input[name=\"price[from]\"]').value, 10) || 0;\n      }\n\n      if (container.querySelector('input[name=\"price[to]\"]')) {\n        option.data.priceTo = parseInt(container.querySelector('input[name=\"price[to]\"]').value, 10) || 0;\n      }\n\n      if (container.querySelector('.multifilter-price__num .multifilter-price__start')) {\n        option.data.priceMin = parseInt(container.querySelector('.multifilter-price__num .multifilter-price__start').textContent.replace(/[^0-9]/g, ''), 10) || 0;\n      }\n\n      if (container.querySelector('.multifilter-price__num .multifilter-price__end')) {\n        option.data.priceMax = parseInt(container.querySelector('.multifilter-price__num .multifilter-price__end').textContent.replace(/[^0-9]/g, ''), 10) || 10000;\n      }\n\n      if (option.data.priceFrom < option.data.priceMin) {\n        option.data.priceFrom = option.data.priceMin;\n      }\n\n      if (option.data.priceTo > option.data.priceMax || option.data.priceTo === 0) {\n        option.data.priceTo = option.data.priceMax;\n      }\n\n      return option;\n    }\n  }]);\n\n  return PriceFilter;\n}();\n/**\n * CheckboxFilter\n */\n\nvar CheckboxFilter =\n/*#__PURE__*/\nfunction () {\n  function CheckboxFilter(el) {\n    var _this4 = this;\n\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'filters';\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, CheckboxFilter);\n\n    this.el = el;\n    this.container = container;\n    this.filterSettings = CheckboxFilter.parseSettings(this.el);\n    _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].commit('filters/pushFilterToContainer', {\n      container: this.container,\n      filter: this.filterSettings\n    });\n    new vue__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]({\n      store: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"],\n      render: function render(h) {\n        return h(_catalog_FilterCheckbox_vue__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"], {\n          props: {\n            filter: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].state.filters[_this4.container][_this4.filterSettings.name]\n          }\n        });\n      }\n    }).$mount(this.el);\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(CheckboxFilter, null, [{\n    key: \"parseSettings\",\n    value: function parseSettings(multifilterEl) {\n      var option = {\n        type: 'checkbox',\n        replaceTitle: false,\n        label: multifilterEl.querySelector('.multifilter__value').textContent,\n        labelDisabled: 'Выберите тип товара',\n        labelEmpty: 'Не выбрано',\n        disabled: multifilterEl.disabled,\n        name: multifilterEl.dataset.filterName || '',\n        parent: multifilterEl.dataset.filterParent || '',\n        selectedItems: [],\n        // Не используется, но пусть будет\n        data: []\n      };\n\n      if (multifilterEl.querySelector('.multifilter__label')) {\n        option.replaceTitle = true;\n        option.label = multifilterEl.querySelector('.multifilter__label').textContent;\n      }\n\n      [].forEach.call(multifilterEl.querySelectorAll('input[type=\"checkbox\"]'), function (input, i) {\n        if (!option.name) {\n          option.name = input.name.replace('[]', '');\n        }\n\n        if (input.checked) {\n          option.selectedItems.push(input.value);\n        }\n\n        option.data.push({\n          label: input.parentElement.querySelector('.multifilter-checkbox__label').textContent,\n          id: i,\n          name: input.name || '',\n          value: input.value,\n          checked: input.checked,\n          // true, если активен\n          available: !input.disabled,\n          // true, если в наличии\n          parent: input.dataset.parentId,\n          // Наследование значения (если есть)\n          hidden: input.parentElement.style.display === 'none' && !input.checked // Визуально скрыт, показать, если вдруг будет активен\n\n        });\n      });\n\n      if (!option.name) {\n        option.name = option.label;\n      } // store.commit('filters/setFilter', option);\n\n\n      return option;\n    }\n  }]);\n\n  return CheckboxFilter;\n}(); // export function getFilterCheckbox(el, container = 'filters') {\n//   const settings = CheckboxFilter.parseSettings(el);\n//   store.commit('filters/pushFilterToContainer', { container, filter: settings });\n//\n//   return new Vue({\n//     store,\n//     render: h => h(FilterCheckbox, {\n//       props: { filter: store.state.filters[container][settings.name] },\n//     }),\n//   }).$mount(el);\n// }\n\n/**\n * SelectFilter\n */\n\nvar SelectFilter =\n/*#__PURE__*/\nfunction () {\n  function SelectFilter(el) {\n    var _this5 = this;\n\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sort';\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, SelectFilter);\n\n    this.el = el;\n    this.container = container;\n    this.filterSettings = SelectFilter.parseSettings(this.el);\n    _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].commit('filters/pushFilterToContainer', {\n      container: this.container,\n      filter: this.filterSettings\n    });\n    new vue__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]({\n      store: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"],\n      render: function render(h) {\n        return h(_catalog_FilterSelect_vue__WEBPACK_IMPORTED_MODULE_11__[/* default */ \"a\"], {\n          props: {\n            filter: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].state.filters[_this5.container][_this5.filterSettings.name]\n          }\n        });\n      }\n    }).$mount(this.el);\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(SelectFilter, null, [{\n    key: \"parseSettings\",\n    value: function parseSettings(multifilterEl) {\n      var option = {\n        type: 'radio',\n        label: 'Не выбрано',\n        selected: null,\n        name: multifilterEl.dataset.filterName || '',\n        data: []\n      };\n      [].forEach.call(multifilterEl.querySelectorAll('input[type=\"radio\"]'), function (input) {\n        if (!option.name) {\n          option.name = input.name;\n        }\n\n        if (input.checked) {\n          option.selected = input.value;\n          option.label = input.parentElement.querySelector('.multifilter-radio__label').textContent;\n        }\n\n        option.data.push({\n          label: input.parentElement.querySelector('.multifilter-radio__label').textContent,\n          name: input.name || '',\n          value: input.value,\n          checked: input.checked\n        });\n      });\n\n      if (!option.name) {\n        option.name = option.label;\n      }\n\n      return option;\n    }\n  }]);\n\n  return SelectFilter;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9NdWx0aWZpbHRlci5qcz85ODgxIl0sIm5hbWVzIjpbIk11bHRpZmlsdGVyIiwiZWwiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJ2YWx1ZUVsIiwicXVlcnlTZWxlY3RvciIsImNvbnRlbnRFbCIsIm1lbnVCdXR0b24iLCJpbnB1dExpc3QiLCJxdWVyeVNlbGVjdG9yQWxsIiwidHlwZSIsInJlcGxhY2VUaXRsZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInRpdGxlIiwibmV3VGl0bGUiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwiaW5uZXJIVE1MIiwiZm9yRWFjaCIsImlucHV0IiwiZGlzYWJsZWQiLCJ0b0xvd2VyQ2FzZSIsInZhbHVlIiwiaGFzQXR0cmlidXRlIiwiY2hlY2tlZCIsInNlbGVjdGVkSW5kZXgiLCJSYWRpb0ZpbHRlciIsInRhcmdldCIsIm5leHRFbGVtZW50U2libGluZyIsInRleHRDb250ZW50Iiwib25DaGFuZ2UiLCJkZWZhdWx0SW5wdXQiLCJsZW5ndGgiLCJQcmljZUZpbHRlciIsImNvbnRhaW5lciIsImZpbHRlclNldHRpbmdzIiwicGFyc2VTZXR0aW5ncyIsInN0b3JlIiwiY29tbWl0IiwiZmlsdGVyIiwiVnVlIiwicmVuZGVyIiwiaCIsIkZpbHRlclByaWNlIiwicHJvcHMiLCJzdGF0ZSIsImZpbHRlcnMiLCJuYW1lIiwiJG1vdW50IiwibXVsdGlmaWx0ZXJFbCIsIm9wdGlvbiIsImxhYmVsIiwiZGF0YSIsIm1pblJhbmdlIiwibWF4UmFuZ2UiLCJwcmljZUZyb20iLCJwcmljZVRvIiwicHJpY2VNaW4iLCJwcmljZU1heCIsInBhcnNlSW50IiwicmVwbGFjZSIsIkNoZWNrYm94RmlsdGVyIiwiRmlsdGVyQ2hlY2tib3giLCJsYWJlbERpc2FibGVkIiwibGFiZWxFbXB0eSIsImRhdGFzZXQiLCJmaWx0ZXJOYW1lIiwicGFyZW50IiwiZmlsdGVyUGFyZW50Iiwic2VsZWN0ZWRJdGVtcyIsImNhbGwiLCJpIiwicHVzaCIsInBhcmVudEVsZW1lbnQiLCJpZCIsImF2YWlsYWJsZSIsInBhcmVudElkIiwiaGlkZGVuIiwic3R5bGUiLCJkaXNwbGF5IiwiU2VsZWN0RmlsdGVyIiwiRmlsdGVyU2VsZWN0Iiwic2VsZWN0ZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0NBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTs7OztBQUlPLElBQU1BLFdBQWI7QUFBQTtBQUFBO0FBQ0UsdUJBQVlDLEVBQVosRUFBZ0JDLFFBQWhCLEVBQXdDO0FBQUE7O0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUN0QyxRQUFJLENBQUNGLEVBQUwsRUFBUztBQUVULFNBQUtBLEVBQUwsR0FBVUEsRUFBVjtBQUNBLFNBQUtHLE9BQUwsR0FBZSxLQUFLSCxFQUFMLENBQVFJLGFBQVIsQ0FBc0IscUJBQXRCLENBQWY7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLEtBQUtMLEVBQUwsQ0FBUUksYUFBUixDQUFzQixnQkFBdEIsQ0FBakI7QUFDQSxTQUFLRSxVQUFMLEdBQWtCLEtBQUtOLEVBQUwsQ0FBUUksYUFBUixDQUFzQiw2QkFBdEIsQ0FBbEI7QUFFQSxTQUFLRyxTQUFMLG1GQUFxQixLQUFLUCxFQUFMLENBQVFRLGdCQUFSLENBQXlCLE9BQXpCLENBQXJCO0FBRUEsU0FBS1AsUUFBTCxHQUFnQkEsUUFBaEI7QUFFQSxTQUFLQyxPQUFMLEdBQWU7QUFDYk8sVUFBSSxFQUFFUCxPQUFPLENBQUNPLElBQVIsSUFBZ0IsUUFEVDtBQUNtQjtBQUNoQ0Msa0JBQVksRUFBRVIsT0FBTyxDQUFDUSxZQUFSLElBQXdCO0FBRnpCLEtBQWY7O0FBS0EsUUFBSSxLQUFLUixPQUFMLENBQWFPLElBQWIsS0FBc0IsUUFBMUIsRUFBb0M7QUFDbEM7QUFDQSxXQUFLVCxFQUFMLENBQVFXLGdCQUFSLENBQXlCLFFBQXpCLEVBQW1DLFVBQUFDLEtBQUs7QUFBQSxlQUFJLEtBQUksQ0FBQ1gsUUFBTCxDQUFjVyxLQUFkLENBQUo7QUFBQSxPQUF4QztBQUNEO0FBQ0Y7QUFFRDs7Ozs7OztBQXhCRjtBQUFBO0FBQUEsb0NBNkJrQjtBQUNkLFVBQUksQ0FBQyxLQUFLUCxTQUFWLEVBQXFCLE9BQU8sS0FBUCxDQURQLENBRWQ7QUFDQTtBQUNBO0FBQ0Q7QUFHRDs7Ozs7OztBQXJDRjtBQUFBO0FBQUEsa0NBMkMwQjtBQUFBLFVBQVpRLEtBQVksdUVBQUosRUFBSTtBQUN0QixVQUFJQyxRQUFRLEdBQUdDLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxLQUFkLElBQXVCQSxLQUFLLENBQUNJLElBQU4sQ0FBVyxJQUFYLENBQXZCLEdBQTBDSixLQUF6RDs7QUFDQSxVQUFJQyxRQUFRLEtBQUssRUFBakIsRUFBcUI7QUFDbkJBLGdCQUFRLEdBQUcsWUFBWDtBQUNEOztBQUNELFdBQUtYLE9BQUwsQ0FBYWUsU0FBYixHQUF5QkosUUFBekI7QUFFQSxhQUFPRCxLQUFQO0FBQ0Q7QUFuREg7QUFBQTtBQUFBLDRCQXFEVTtBQUNOLFdBQUtOLFNBQUwsQ0FBZVksT0FBZixDQUF1QixVQUFDQyxLQUFELEVBQVc7QUFDaEMsWUFBSSxFQUFFQSxLQUFLLENBQUNDLFFBQU4sSUFBa0IsQ0FBQ0QsS0FBSyxDQUFDWCxJQUEzQixDQUFKLEVBQXNDO0FBQ3BDLGtCQUFRVyxLQUFLLENBQUNYLElBQU4sQ0FBV2EsV0FBWCxFQUFSO0FBQ0UsaUJBQUssTUFBTDtBQUNBLGlCQUFLLFVBQUw7QUFDQSxpQkFBSyxVQUFMO0FBQ0EsaUJBQUssUUFBTDtBQUNFRixtQkFBSyxDQUFDRyxLQUFOLEdBQWMsRUFBZDtBQUNBOztBQUVGLGlCQUFLLE9BQUw7QUFDRSxrQkFBSSxDQUFDSCxLQUFLLENBQUNJLFlBQU4sQ0FBbUIsU0FBbkIsQ0FBTCxFQUFvQztBQUNsQ0oscUJBQUssQ0FBQ0ssT0FBTixHQUFnQixLQUFoQjtBQUNEOztBQUNEOztBQUVGLGlCQUFLLFVBQUw7QUFDRUwsbUJBQUssQ0FBQ0ssT0FBTixHQUFnQixLQUFoQjtBQUNBOztBQUVGLGlCQUFLLFlBQUw7QUFDQSxpQkFBSyxjQUFMO0FBQ0VMLG1CQUFLLENBQUNNLGFBQU4sR0FBc0IsQ0FBQyxDQUF2QjtBQUNBOztBQUVGO0FBQ0U7QUF4Qko7QUEwQkQ7QUFDRixPQTdCRDtBQThCQSxXQUFLekIsUUFBTCxDQUFjLElBQWQ7QUFDRDtBQXJGSDs7QUFBQTtBQUFBO0FBd0ZBOzs7O0FBR08sSUFBTTBCLFdBQWI7QUFBQTtBQUFBO0FBQUE7O0FBQ0UsdUJBQVkzQixFQUFaLEVBQWdCQyxRQUFoQixFQUEwQjtBQUFBOztBQUFBOztBQUN4QixnTkFBTUQsRUFBTixFQUFVQyxRQUFWLEVBQW9CO0FBQUVRLFVBQUksRUFBRTtBQUFSLEtBQXBCOztBQUR3QiwwTEFhZixVQUFDRyxLQUFELEVBQVc7QUFDcEIsMlhBQWtCQSxLQUFLLENBQUNnQixNQUFOLENBQWFDLGtCQUFiLENBQWdDQyxXQUFsRDs7QUFDQSxhQUFLN0IsUUFBTDtBQUNELEtBaEJ5Qjs7QUFHeEIsV0FBS0QsRUFBTCxDQUFRVyxnQkFBUixDQUF5QixRQUF6QixFQUFtQyxPQUFLb0IsUUFBeEM7O0FBRUEsV0FBS0MsWUFBTCxHQUFvQixPQUFLaEMsRUFBTCxDQUFRSSxhQUFSLENBQXNCLGdCQUF0QixDQUFwQjs7QUFDQSx5WEFBa0IsT0FBSzRCLFlBQUwsQ0FBa0JILGtCQUFsQixDQUFxQ0MsV0FBdkQ7O0FBRUEsUUFBSSxPQUFLdkIsU0FBTCxDQUFlMEIsTUFBZixHQUF3QixDQUE1QixFQUErQjtBQUM3QjtBQUNEOztBQVZ1QjtBQVd6Qjs7QUFaSDtBQUFBO0FBQUEsNEJBbUJVO0FBQ04sdU1BRE0sQ0FFTjs7O0FBQ0EsNk1BQWtCLEtBQUtELFlBQUwsQ0FBa0JILGtCQUFsQixDQUFxQ0MsV0FBdkQsRUFITSxDQUlOOztBQUNEO0FBeEJIOztBQUFBO0FBQUEsRUFBaUMvQixXQUFqQztBQTRCQTs7OztBQUdPLElBQU1tQyxXQUFiO0FBQUE7QUFBQTtBQUNFLHVCQUFZbEMsRUFBWixFQUF1QztBQUFBOztBQUFBLFFBQXZCbUMsU0FBdUIsdUVBQVgsU0FBVzs7QUFBQTs7QUFDckMsU0FBS25DLEVBQUwsR0FBVUEsRUFBVjtBQUNBLFNBQUttQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0JGLFdBQVcsQ0FBQ0csYUFBWixDQUEwQixLQUFLckMsRUFBL0IsQ0FBdEI7QUFFQXNDLDJEQUFLLENBQUNDLE1BQU4sQ0FBYSwrQkFBYixFQUE4QztBQUFFSixlQUFTLEVBQUUsS0FBS0EsU0FBbEI7QUFBNkJLLFlBQU0sRUFBRSxLQUFLSjtBQUExQyxLQUE5QztBQUVBLFFBQUlLLG1EQUFKLENBQVE7QUFDTkgsV0FBSyxFQUFMQSx1REFETTtBQUVOSSxZQUFNLEVBQUUsZ0JBQUFDLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNDLHlFQUFELEVBQWM7QUFDMUJDLGVBQUssRUFBRTtBQUFFTCxrQkFBTSxFQUFFRix1REFBSyxDQUFDUSxLQUFOLENBQVlDLE9BQVosQ0FBb0IsTUFBSSxDQUFDWixTQUF6QixFQUFvQyxNQUFJLENBQUNDLGNBQUwsQ0FBb0JZLElBQXhEO0FBQVY7QUFEbUIsU0FBZCxDQUFMO0FBQUE7QUFGSCxLQUFSLEVBS0dDLE1BTEgsQ0FLVSxLQUFLakQsRUFMZjtBQU1EOztBQWRIO0FBQUE7QUFBQSxrQ0FnQnVCa0QsYUFoQnZCLEVBZ0JzQztBQUNsQyxVQUFNZixTQUFTLEdBQUdlLGFBQWEsQ0FBQzlDLGFBQWQsQ0FBNEIsb0JBQTVCLENBQWxCO0FBRUEsVUFBTStDLE1BQU0sR0FBRztBQUNiQyxhQUFLLEVBQUVGLGFBQWEsQ0FBQzlDLGFBQWQsQ0FBNEIscUJBQTVCLEVBQW1EMEIsV0FEN0M7QUFFYnJCLFlBQUksRUFBRSxPQUZPO0FBR2J1QyxZQUFJLEVBQUUsT0FITztBQUliSyxZQUFJLEVBQUU7QUFDSkMsa0JBQVEsRUFBRSxJQUROO0FBRUpDLGtCQUFRLEVBQUUsSUFGTjtBQUlKQyxtQkFBUyxFQUFFLENBSlA7QUFLSkMsaUJBQU8sRUFBRSxDQUxMO0FBTUpDLGtCQUFRLEVBQUUsQ0FOTjtBQU9KQyxrQkFBUSxFQUFFO0FBUE47QUFKTyxPQUFmOztBQWVBLFVBQUl4QixTQUFTLENBQUMvQixhQUFWLENBQXdCLDJCQUF4QixDQUFKLEVBQTBEO0FBQ3hEK0MsY0FBTSxDQUFDRSxJQUFQLENBQVlHLFNBQVosR0FBd0JJLFFBQVEsQ0FBQ3pCLFNBQVMsQ0FBQy9CLGFBQVYsQ0FBd0IsMkJBQXhCLEVBQXFEbUIsS0FBdEQsRUFBNkQsRUFBN0QsQ0FBUixJQUE0RSxDQUFwRztBQUNEOztBQUVELFVBQUlZLFNBQVMsQ0FBQy9CLGFBQVYsQ0FBd0IseUJBQXhCLENBQUosRUFBd0Q7QUFDdEQrQyxjQUFNLENBQUNFLElBQVAsQ0FBWUksT0FBWixHQUFzQkcsUUFBUSxDQUFDekIsU0FBUyxDQUFDL0IsYUFBVixDQUF3Qix5QkFBeEIsRUFBbURtQixLQUFwRCxFQUEyRCxFQUEzRCxDQUFSLElBQTBFLENBQWhHO0FBQ0Q7O0FBRUQsVUFBSVksU0FBUyxDQUFDL0IsYUFBVixDQUF3QixtREFBeEIsQ0FBSixFQUFrRjtBQUNoRitDLGNBQU0sQ0FBQ0UsSUFBUCxDQUFZSyxRQUFaLEdBQXVCRSxRQUFRLENBQUN6QixTQUFTLENBQUMvQixhQUFWLENBQXdCLG1EQUF4QixFQUM3QjBCLFdBRDZCLENBRTdCK0IsT0FGNkIsQ0FFckIsU0FGcUIsRUFFVixFQUZVLENBQUQsRUFFSixFQUZJLENBQVIsSUFFVyxDQUZsQztBQUdEOztBQUVELFVBQUkxQixTQUFTLENBQUMvQixhQUFWLENBQXdCLGlEQUF4QixDQUFKLEVBQWdGO0FBQzlFK0MsY0FBTSxDQUFDRSxJQUFQLENBQVlNLFFBQVosR0FBdUJDLFFBQVEsQ0FBQ3pCLFNBQVMsQ0FBQy9CLGFBQVYsQ0FBd0IsaURBQXhCLEVBQzdCMEIsV0FENkIsQ0FFN0IrQixPQUY2QixDQUVyQixTQUZxQixFQUVWLEVBRlUsQ0FBRCxFQUVKLEVBRkksQ0FBUixJQUVXLEtBRmxDO0FBR0Q7O0FBRUQsVUFBSVYsTUFBTSxDQUFDRSxJQUFQLENBQVlHLFNBQVosR0FBd0JMLE1BQU0sQ0FBQ0UsSUFBUCxDQUFZSyxRQUF4QyxFQUFrRDtBQUNoRFAsY0FBTSxDQUFDRSxJQUFQLENBQVlHLFNBQVosR0FBd0JMLE1BQU0sQ0FBQ0UsSUFBUCxDQUFZSyxRQUFwQztBQUNEOztBQUVELFVBQUlQLE1BQU0sQ0FBQ0UsSUFBUCxDQUFZSSxPQUFaLEdBQXNCTixNQUFNLENBQUNFLElBQVAsQ0FBWU0sUUFBbEMsSUFBOENSLE1BQU0sQ0FBQ0UsSUFBUCxDQUFZSSxPQUFaLEtBQXdCLENBQTFFLEVBQTZFO0FBQzNFTixjQUFNLENBQUNFLElBQVAsQ0FBWUksT0FBWixHQUFzQk4sTUFBTSxDQUFDRSxJQUFQLENBQVlNLFFBQWxDO0FBQ0Q7O0FBRUQsYUFBT1IsTUFBUDtBQUNEO0FBL0RIOztBQUFBO0FBQUE7QUFrRUE7Ozs7QUFHTyxJQUFNVyxjQUFiO0FBQUE7QUFBQTtBQUNFLDBCQUFZOUQsRUFBWixFQUF1QztBQUFBOztBQUFBLFFBQXZCbUMsU0FBdUIsdUVBQVgsU0FBVzs7QUFBQTs7QUFDckMsU0FBS25DLEVBQUwsR0FBVUEsRUFBVjtBQUNBLFNBQUttQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0IwQixjQUFjLENBQUN6QixhQUFmLENBQTZCLEtBQUtyQyxFQUFsQyxDQUF0QjtBQUNBc0MsMkRBQUssQ0FBQ0MsTUFBTixDQUFhLCtCQUFiLEVBQThDO0FBQUVKLGVBQVMsRUFBRSxLQUFLQSxTQUFsQjtBQUE2QkssWUFBTSxFQUFFLEtBQUtKO0FBQTFDLEtBQTlDO0FBRUEsUUFBSUssbURBQUosQ0FBUTtBQUNOSCxXQUFLLEVBQUxBLHVEQURNO0FBRU5JLFlBQU0sRUFBRSxnQkFBQUMsQ0FBQztBQUFBLGVBQUlBLENBQUMsQ0FBQ29CLDRFQUFELEVBQWlCO0FBQzdCbEIsZUFBSyxFQUFFO0FBQUVMLGtCQUFNLEVBQUVGLHVEQUFLLENBQUNRLEtBQU4sQ0FBWUMsT0FBWixDQUFvQixNQUFJLENBQUNaLFNBQXpCLEVBQW9DLE1BQUksQ0FBQ0MsY0FBTCxDQUFvQlksSUFBeEQ7QUFBVjtBQURzQixTQUFqQixDQUFMO0FBQUE7QUFGSCxLQUFSLEVBS0dDLE1BTEgsQ0FLVSxLQUFLakQsRUFMZjtBQU1EOztBQWJIO0FBQUE7QUFBQSxrQ0FldUJrRCxhQWZ2QixFQWVzQztBQUNsQyxVQUFNQyxNQUFNLEdBQUc7QUFDYjFDLFlBQUksRUFBRSxVQURPO0FBRWJDLG9CQUFZLEVBQUUsS0FGRDtBQUdiMEMsYUFBSyxFQUFFRixhQUFhLENBQUM5QyxhQUFkLENBQTRCLHFCQUE1QixFQUFtRDBCLFdBSDdDO0FBSWJrQyxxQkFBYSxFQUFFLHFCQUpGO0FBS2JDLGtCQUFVLEVBQUUsWUFMQztBQU1iNUMsZ0JBQVEsRUFBRTZCLGFBQWEsQ0FBQzdCLFFBTlg7QUFPYjJCLFlBQUksRUFBRUUsYUFBYSxDQUFDZ0IsT0FBZCxDQUFzQkMsVUFBdEIsSUFBb0MsRUFQN0I7QUFRYkMsY0FBTSxFQUFFbEIsYUFBYSxDQUFDZ0IsT0FBZCxDQUFzQkcsWUFBdEIsSUFBc0MsRUFSakM7QUFTYkMscUJBQWEsRUFBRSxFQVRGO0FBU007QUFDbkJqQixZQUFJLEVBQUU7QUFWTyxPQUFmOztBQWFBLFVBQUlILGFBQWEsQ0FBQzlDLGFBQWQsQ0FBNEIscUJBQTVCLENBQUosRUFBd0Q7QUFDdEQrQyxjQUFNLENBQUN6QyxZQUFQLEdBQXNCLElBQXRCO0FBQ0F5QyxjQUFNLENBQUNDLEtBQVAsR0FBZUYsYUFBYSxDQUFDOUMsYUFBZCxDQUE0QixxQkFBNUIsRUFBbUQwQixXQUFsRTtBQUNEOztBQUVELFNBQUdYLE9BQUgsQ0FBV29ELElBQVgsQ0FBZ0JyQixhQUFhLENBQUMxQyxnQkFBZCxDQUErQix3QkFBL0IsQ0FBaEIsRUFBMEUsVUFBQ1ksS0FBRCxFQUFRb0QsQ0FBUixFQUFjO0FBQ3RGLFlBQUksQ0FBQ3JCLE1BQU0sQ0FBQ0gsSUFBWixFQUFrQjtBQUNoQkcsZ0JBQU0sQ0FBQ0gsSUFBUCxHQUFjNUIsS0FBSyxDQUFDNEIsSUFBTixDQUFXYSxPQUFYLENBQW1CLElBQW5CLEVBQXlCLEVBQXpCLENBQWQ7QUFDRDs7QUFFRCxZQUFJekMsS0FBSyxDQUFDSyxPQUFWLEVBQW1CO0FBQ2pCMEIsZ0JBQU0sQ0FBQ21CLGFBQVAsQ0FBcUJHLElBQXJCLENBQTBCckQsS0FBSyxDQUFDRyxLQUFoQztBQUNEOztBQUVENEIsY0FBTSxDQUFDRSxJQUFQLENBQVlvQixJQUFaLENBQWlCO0FBQ2ZyQixlQUFLLEVBQUVoQyxLQUFLLENBQUNzRCxhQUFOLENBQW9CdEUsYUFBcEIsQ0FBa0MsOEJBQWxDLEVBQWtFMEIsV0FEMUQ7QUFFZjZDLFlBQUUsRUFBRUgsQ0FGVztBQUdmeEIsY0FBSSxFQUFFNUIsS0FBSyxDQUFDNEIsSUFBTixJQUFjLEVBSEw7QUFJZnpCLGVBQUssRUFBRUgsS0FBSyxDQUFDRyxLQUpFO0FBS2ZFLGlCQUFPLEVBQUVMLEtBQUssQ0FBQ0ssT0FMQTtBQUtTO0FBQ3hCbUQsbUJBQVMsRUFBRSxDQUFDeEQsS0FBSyxDQUFDQyxRQU5IO0FBTWE7QUFDNUIrQyxnQkFBTSxFQUFFaEQsS0FBSyxDQUFDOEMsT0FBTixDQUFjVyxRQVBQO0FBT2lCO0FBQ2hDQyxnQkFBTSxFQUFFMUQsS0FBSyxDQUFDc0QsYUFBTixDQUFvQkssS0FBcEIsQ0FBMEJDLE9BQTFCLEtBQXNDLE1BQXRDLElBQWdELENBQUM1RCxLQUFLLENBQUNLLE9BUmhELENBUXlEOztBQVJ6RCxTQUFqQjtBQVVELE9BbkJEOztBQXFCQSxVQUFJLENBQUMwQixNQUFNLENBQUNILElBQVosRUFBa0I7QUFDaEJHLGNBQU0sQ0FBQ0gsSUFBUCxHQUFjRyxNQUFNLENBQUNDLEtBQXJCO0FBQ0QsT0ExQ2lDLENBNENsQzs7O0FBRUEsYUFBT0QsTUFBUDtBQUNEO0FBOURIOztBQUFBO0FBQUEsSSxDQWlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOzs7O0FBR08sSUFBTThCLFlBQWI7QUFBQTtBQUFBO0FBQ0Usd0JBQVlqRixFQUFaLEVBQW9DO0FBQUE7O0FBQUEsUUFBcEJtQyxTQUFvQix1RUFBUixNQUFROztBQUFBOztBQUNsQyxTQUFLbkMsRUFBTCxHQUFVQSxFQUFWO0FBQ0EsU0FBS21DLFNBQUwsR0FBaUJBLFNBQWpCO0FBRUEsU0FBS0MsY0FBTCxHQUFzQjZDLFlBQVksQ0FBQzVDLGFBQWIsQ0FBMkIsS0FBS3JDLEVBQWhDLENBQXRCO0FBRUFzQywyREFBSyxDQUFDQyxNQUFOLENBQWEsK0JBQWIsRUFBOEM7QUFBRUosZUFBUyxFQUFFLEtBQUtBLFNBQWxCO0FBQTZCSyxZQUFNLEVBQUUsS0FBS0o7QUFBMUMsS0FBOUM7QUFHQSxRQUFJSyxtREFBSixDQUFRO0FBQ05ILFdBQUssRUFBTEEsdURBRE07QUFFTkksWUFBTSxFQUFFLGdCQUFBQyxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDdUMsMEVBQUQsRUFBZTtBQUMzQnJDLGVBQUssRUFBRTtBQUFFTCxrQkFBTSxFQUFFRix1REFBSyxDQUFDUSxLQUFOLENBQVlDLE9BQVosQ0FBb0IsTUFBSSxDQUFDWixTQUF6QixFQUFvQyxNQUFJLENBQUNDLGNBQUwsQ0FBb0JZLElBQXhEO0FBQVY7QUFEb0IsU0FBZixDQUFMO0FBQUE7QUFGSCxLQUFSLEVBS0dDLE1BTEgsQ0FLVSxLQUFLakQsRUFMZjtBQU1EOztBQWhCSDtBQUFBO0FBQUEsa0NBa0J1QmtELGFBbEJ2QixFQWtCc0M7QUFDbEMsVUFBTUMsTUFBTSxHQUFHO0FBQ2IxQyxZQUFJLEVBQUUsT0FETztBQUViMkMsYUFBSyxFQUFFLFlBRk07QUFHYitCLGdCQUFRLEVBQUUsSUFIRztBQUlibkMsWUFBSSxFQUFFRSxhQUFhLENBQUNnQixPQUFkLENBQXNCQyxVQUF0QixJQUFvQyxFQUo3QjtBQUtiZCxZQUFJLEVBQUU7QUFMTyxPQUFmO0FBUUEsU0FBR2xDLE9BQUgsQ0FBV29ELElBQVgsQ0FBZ0JyQixhQUFhLENBQUMxQyxnQkFBZCxDQUErQixxQkFBL0IsQ0FBaEIsRUFBdUUsVUFBQ1ksS0FBRCxFQUFXO0FBQ2hGLFlBQUksQ0FBQytCLE1BQU0sQ0FBQ0gsSUFBWixFQUFrQjtBQUNoQkcsZ0JBQU0sQ0FBQ0gsSUFBUCxHQUFjNUIsS0FBSyxDQUFDNEIsSUFBcEI7QUFDRDs7QUFFRCxZQUFJNUIsS0FBSyxDQUFDSyxPQUFWLEVBQW1CO0FBQ2pCMEIsZ0JBQU0sQ0FBQ2dDLFFBQVAsR0FBa0IvRCxLQUFLLENBQUNHLEtBQXhCO0FBQ0E0QixnQkFBTSxDQUFDQyxLQUFQLEdBQWVoQyxLQUFLLENBQUNzRCxhQUFOLENBQW9CdEUsYUFBcEIsQ0FBa0MsMkJBQWxDLEVBQStEMEIsV0FBOUU7QUFDRDs7QUFFRHFCLGNBQU0sQ0FBQ0UsSUFBUCxDQUFZb0IsSUFBWixDQUFpQjtBQUNmckIsZUFBSyxFQUFFaEMsS0FBSyxDQUFDc0QsYUFBTixDQUFvQnRFLGFBQXBCLENBQWtDLDJCQUFsQyxFQUErRDBCLFdBRHZEO0FBRWZrQixjQUFJLEVBQUU1QixLQUFLLENBQUM0QixJQUFOLElBQWMsRUFGTDtBQUdmekIsZUFBSyxFQUFFSCxLQUFLLENBQUNHLEtBSEU7QUFJZkUsaUJBQU8sRUFBRUwsS0FBSyxDQUFDSztBQUpBLFNBQWpCO0FBTUQsT0FoQkQ7O0FBa0JBLFVBQUksQ0FBQzBCLE1BQU0sQ0FBQ0gsSUFBWixFQUFrQjtBQUNoQkcsY0FBTSxDQUFDSCxJQUFQLEdBQWNHLE1BQU0sQ0FBQ0MsS0FBckI7QUFDRDs7QUFFRCxhQUFPRCxNQUFQO0FBQ0Q7QUFsREg7O0FBQUE7QUFBQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCBTaW1wbGVCYXIgZnJvbSAnc2ltcGxlYmFyJztcbi8vIGltcG9ydCBub1VpU2xpZGVyIGZyb20gJ25vdWlzbGlkZXInO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5cbi8vIGltcG9ydCBNdWx0aWZpbHRlclJhZGlvIGZyb20gJy4vY2F0YWxvZy9NdWx0aWZpbHRlclJhZGlvLnZ1ZSc7XG5pbXBvcnQgRmlsdGVyQ2hlY2tib3ggZnJvbSAnLi9jYXRhbG9nL0ZpbHRlckNoZWNrYm94LnZ1ZSc7XG5pbXBvcnQgRmlsdGVyU2VsZWN0IGZyb20gJy4vY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlJztcbmltcG9ydCBGaWx0ZXJQcmljZSBmcm9tICcuL2NhdGFsb2cvRmlsdGVyUHJpY2UudnVlJztcblxuaW1wb3J0IHN0b3JlIGZyb20gJy4uL3N0b3JlJztcblxuXG4vKlxuINCf0YDQvtGB0YLQuCDQvNC10L3RjyDQs9C+0YHQv9C+0LTRjCDQt9CwINGN0YLRgyDRhdGD0LjRgtGDICgoXG4gKi9cblxuZXhwb3J0IGNsYXNzIE11bHRpZmlsdGVyIHtcbiAgY29uc3RydWN0b3IoZWwsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWVsKSByZXR1cm47XG5cbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy52YWx1ZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXJfX3ZhbHVlJyk7XG4gICAgdGhpcy5jb250ZW50RWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5kcm9wZG93bi1tZW51Jyk7XG4gICAgdGhpcy5tZW51QnV0dG9uID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdidXR0b24ubXVsdGlmaWx0ZXJfX2NvbnRlbnQnKTtcblxuICAgIHRoaXMuaW5wdXRMaXN0ID0gWy4uLnRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKV07XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiBvcHRpb25zLnR5cGUgfHwgJ3NpbXBsZScsIC8vICdjaGVja2JveCcsICdyYWRpbycsICdwcmljZSdcbiAgICAgIHJlcGxhY2VUaXRsZTogb3B0aW9ucy5yZXBsYWNlVGl0bGUgfHwgZmFsc2UsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gJ3NpbXBsZScpIHtcbiAgICAgIC8vIHRoaXMuaW5wdXRMaXN0LmZvckVhY2goaXRlbSA9PiBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuY2FsbGJhY2spKTtcbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4gdGhpcy5jYWxsYmFjayhldmVudCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDQmNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdGCINC60LDRgdGC0L7QvNC90YPRjiDQv9GA0L7QutGA0YPRgtC60YNcbiAgICpcbiAgICogQHJldHVybnMge1NpbXBsZUJhcnxib29sZWFufVxuICAgKi9cbiAgaW5pdFNjcm9sbGJhcigpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudEVsKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gY29uc3Qgc2ltcGxlQmFyID0gbmV3IFNpbXBsZUJhcih0aGlzLmNvbnRlbnRFbCwgeyBhdXRvSGlkZTogZmFsc2UgfSk7XG4gICAgLy8gdGhpcy5jb250ZW50RWwgPSBzaW1wbGVCYXIuZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAvLyByZXR1cm4gc2ltcGxlQmFyO1xuICB9XG5cblxuICAvKipcbiAgICog0J7QsdC90L7QstC70Y/QtdGCINC30LDQs9C+0LvQvtCy0L7QulxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gW3RpdGxlPScnXSAtINCh0YLRgNC+0LrQsCDQuNC70Lgg0LzQsNGB0YHQuNCyINCy0YHRgtCw0LLQu9GP0LXQvNGL0YUg0LfQvdCw0YfQtdC90LjQuVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aXRsZVxuICAgKi9cbiAgdXBkYXRlVGl0bGUodGl0bGUgPSAnJykge1xuICAgIGxldCBuZXdUaXRsZSA9IEFycmF5LmlzQXJyYXkodGl0bGUpID8gdGl0bGUuam9pbignLCAnKSA6IHRpdGxlO1xuICAgIGlmIChuZXdUaXRsZSA9PT0gJycpIHtcbiAgICAgIG5ld1RpdGxlID0gJ9Cd0LUg0LLRi9Cx0YDQsNC90L4nO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlRWwuaW5uZXJIVE1MID0gbmV3VGl0bGU7XG5cbiAgICByZXR1cm4gdGl0bGU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLmlucHV0TGlzdC5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKCEoaW5wdXQuZGlzYWJsZWQgfHwgIWlucHV0LnR5cGUpKSB7XG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgaWYgKCFpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgICAgICAgICBpbnB1dC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XG4gICAgICAgICAgY2FzZSAnc2VsZWN0LW11bHRpJzpcbiAgICAgICAgICAgIGlucHV0LnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIFJhZGlvRmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBSYWRpb0ZpbHRlciBleHRlbmRzIE11bHRpZmlsdGVyIHtcbiAgY29uc3RydWN0b3IoZWwsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoZWwsIGNhbGxiYWNrLCB7IHR5cGU6ICdyYWRpbycgfSk7XG5cbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xuXG4gICAgdGhpcy5kZWZhdWx0SW5wdXQgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W2NoZWNrZWRdJyk7XG4gICAgc3VwZXIudXBkYXRlVGl0bGUodGhpcy5kZWZhdWx0SW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50KTtcblxuICAgIGlmICh0aGlzLmlucHV0TGlzdC5sZW5ndGggPiA5KSB7XG4gICAgICBzdXBlci5pbml0U2Nyb2xsYmFyKCk7XG4gICAgfVxuICB9XG5cbiAgb25DaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBzdXBlci51cGRhdGVUaXRsZShldmVudC50YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50KTtcbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMpO1xuICB9O1xuXG4gIHJlc2V0KCkge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgLy8gdGhpcy5kZWZhdWx0SW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgc3VwZXIudXBkYXRlVGl0bGUodGhpcy5kZWZhdWx0SW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50KTtcbiAgICAvLyB0aGlzLmNhbGxiYWNrKHRoaXMpO1xuICB9XG59XG5cblxuLyoqXG4gKiBQcmljZUZpbHRlclxuICovXG5leHBvcnQgY2xhc3MgUHJpY2VGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihlbCwgY29udGFpbmVyID0gJ2ZpbHRlcnMnKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuZmlsdGVyU2V0dGluZ3MgPSBQcmljZUZpbHRlci5wYXJzZVNldHRpbmdzKHRoaXMuZWwpO1xuXG4gICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciwgZmlsdGVyOiB0aGlzLmZpbHRlclNldHRpbmdzIH0pO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBzdG9yZSxcbiAgICAgIHJlbmRlcjogaCA9PiBoKEZpbHRlclByaWNlLCB7XG4gICAgICAgIHByb3BzOiB7IGZpbHRlcjogc3RvcmUuc3RhdGUuZmlsdGVyc1t0aGlzLmNvbnRhaW5lcl1bdGhpcy5maWx0ZXJTZXR0aW5ncy5uYW1lXSB9LFxuICAgICAgfSksXG4gICAgfSkuJG1vdW50KHRoaXMuZWwpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2V0dGluZ3MobXVsdGlmaWx0ZXJFbCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG11bHRpZmlsdGVyRWwucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXByaWNlJyk7XG5cbiAgICBjb25zdCBvcHRpb24gPSB7XG4gICAgICBsYWJlbDogbXVsdGlmaWx0ZXJFbC5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXJfX3ZhbHVlJykudGV4dENvbnRlbnQsXG4gICAgICB0eXBlOiAncmFuZ2UnLFxuICAgICAgbmFtZTogJ3ByaWNlJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWluUmFuZ2U6IG51bGwsXG4gICAgICAgIG1heFJhbmdlOiBudWxsLFxuXG4gICAgICAgIHByaWNlRnJvbTogMCxcbiAgICAgICAgcHJpY2VUbzogMCxcbiAgICAgICAgcHJpY2VNaW46IDAsXG4gICAgICAgIHByaWNlTWF4OiAxMDAwMCxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmIChjb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cInByaWNlW2Zyb21dXCJdJykpIHtcbiAgICAgIG9wdGlvbi5kYXRhLnByaWNlRnJvbSA9IHBhcnNlSW50KGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwicHJpY2VbZnJvbV1cIl0nKS52YWx1ZSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwicHJpY2VbdG9dXCJdJykpIHtcbiAgICAgIG9wdGlvbi5kYXRhLnByaWNlVG8gPSBwYXJzZUludChjb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cInByaWNlW3RvXVwiXScpLnZhbHVlLCAxMCkgfHwgMDtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlci1wcmljZV9fbnVtIC5tdWx0aWZpbHRlci1wcmljZV9fc3RhcnQnKSkge1xuICAgICAgb3B0aW9uLmRhdGEucHJpY2VNaW4gPSBwYXJzZUludChjb250YWluZXIucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXByaWNlX19udW0gLm11bHRpZmlsdGVyLXByaWNlX19zdGFydCcpXG4gICAgICAgIC50ZXh0Q29udGVudFxuICAgICAgICAucmVwbGFjZSgvW14wLTldL2csICcnKSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcHJpY2VfX251bSAubXVsdGlmaWx0ZXItcHJpY2VfX2VuZCcpKSB7XG4gICAgICBvcHRpb24uZGF0YS5wcmljZU1heCA9IHBhcnNlSW50KGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcHJpY2VfX251bSAubXVsdGlmaWx0ZXItcHJpY2VfX2VuZCcpXG4gICAgICAgIC50ZXh0Q29udGVudFxuICAgICAgICAucmVwbGFjZSgvW14wLTldL2csICcnKSwgMTApIHx8IDEwMDAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb24uZGF0YS5wcmljZUZyb20gPCBvcHRpb24uZGF0YS5wcmljZU1pbikge1xuICAgICAgb3B0aW9uLmRhdGEucHJpY2VGcm9tID0gb3B0aW9uLmRhdGEucHJpY2VNaW47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5kYXRhLnByaWNlVG8gPiBvcHRpb24uZGF0YS5wcmljZU1heCB8fCBvcHRpb24uZGF0YS5wcmljZVRvID09PSAwKSB7XG4gICAgICBvcHRpb24uZGF0YS5wcmljZVRvID0gb3B0aW9uLmRhdGEucHJpY2VNYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrYm94RmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVja2JveEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKGVsLCBjb250YWluZXIgPSAnZmlsdGVycycpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5maWx0ZXJTZXR0aW5ncyA9IENoZWNrYm94RmlsdGVyLnBhcnNlU2V0dGluZ3ModGhpcy5lbCk7XG4gICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciwgZmlsdGVyOiB0aGlzLmZpbHRlclNldHRpbmdzIH0pO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBzdG9yZSxcbiAgICAgIHJlbmRlcjogaCA9PiBoKEZpbHRlckNoZWNrYm94LCB7XG4gICAgICAgIHByb3BzOiB7IGZpbHRlcjogc3RvcmUuc3RhdGUuZmlsdGVyc1t0aGlzLmNvbnRhaW5lcl1bdGhpcy5maWx0ZXJTZXR0aW5ncy5uYW1lXSB9LFxuICAgICAgfSksXG4gICAgfSkuJG1vdW50KHRoaXMuZWwpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2V0dGluZ3MobXVsdGlmaWx0ZXJFbCkge1xuICAgIGNvbnN0IG9wdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICByZXBsYWNlVGl0bGU6IGZhbHNlLFxuICAgICAgbGFiZWw6IG11bHRpZmlsdGVyRWwucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyX192YWx1ZScpLnRleHRDb250ZW50LFxuICAgICAgbGFiZWxEaXNhYmxlZDogJ9CS0YvQsdC10YDQuNGC0LUg0YLQuNC/INGC0L7QstCw0YDQsCcsXG4gICAgICBsYWJlbEVtcHR5OiAn0J3QtSDQstGL0LHRgNCw0L3QvicsXG4gICAgICBkaXNhYmxlZDogbXVsdGlmaWx0ZXJFbC5kaXNhYmxlZCxcbiAgICAgIG5hbWU6IG11bHRpZmlsdGVyRWwuZGF0YXNldC5maWx0ZXJOYW1lIHx8ICcnLFxuICAgICAgcGFyZW50OiBtdWx0aWZpbHRlckVsLmRhdGFzZXQuZmlsdGVyUGFyZW50IHx8ICcnLFxuICAgICAgc2VsZWN0ZWRJdGVtczogW10sIC8vINCd0LUg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPLCDQvdC+INC/0YPRgdGC0Ywg0LHRg9C00LXRglxuICAgICAgZGF0YTogW10sXG4gICAgfTtcblxuICAgIGlmIChtdWx0aWZpbHRlckVsLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlcl9fbGFiZWwnKSkge1xuICAgICAgb3B0aW9uLnJlcGxhY2VUaXRsZSA9IHRydWU7XG4gICAgICBvcHRpb24ubGFiZWwgPSBtdWx0aWZpbHRlckVsLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlcl9fbGFiZWwnKS50ZXh0Q29udGVudDtcbiAgICB9XG5cbiAgICBbXS5mb3JFYWNoLmNhbGwobXVsdGlmaWx0ZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKSwgKGlucHV0LCBpKSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbi5uYW1lKSB7XG4gICAgICAgIG9wdGlvbi5uYW1lID0gaW5wdXQubmFtZS5yZXBsYWNlKCdbXScsICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkSXRlbXMucHVzaChpbnB1dC52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbi5kYXRhLnB1c2goe1xuICAgICAgICBsYWJlbDogaW5wdXQucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItY2hlY2tib3hfX2xhYmVsJykudGV4dENvbnRlbnQsXG4gICAgICAgIGlkOiBpLFxuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lIHx8ICcnLFxuICAgICAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IGlucHV0LmNoZWNrZWQsIC8vIHRydWUsINC10YHQu9C4INCw0LrRgtC40LLQtdC9XG4gICAgICAgIGF2YWlsYWJsZTogIWlucHV0LmRpc2FibGVkLCAvLyB0cnVlLCDQtdGB0LvQuCDQsiDQvdCw0LvQuNGH0LjQuFxuICAgICAgICBwYXJlbnQ6IGlucHV0LmRhdGFzZXQucGFyZW50SWQsIC8vINCd0LDRgdC70LXQtNC+0LLQsNC90LjQtSDQt9C90LDRh9C10L3QuNGPICjQtdGB0LvQuCDQtdGB0YLRjClcbiAgICAgICAgaGlkZGVuOiBpbnB1dC5wYXJlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyAmJiAhaW5wdXQuY2hlY2tlZCwgLy8g0JLQuNC30YPQsNC70YzQvdC+INGB0LrRgNGL0YIsINC/0L7QutCw0LfQsNGC0YwsINC10YHQu9C4INCy0LTRgNGD0LMg0LHRg9C00LXRgiDQsNC60YLQuNCy0LXQvVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIW9wdGlvbi5uYW1lKSB7XG4gICAgICBvcHRpb24ubmFtZSA9IG9wdGlvbi5sYWJlbDtcbiAgICB9XG5cbiAgICAvLyBzdG9yZS5jb21taXQoJ2ZpbHRlcnMvc2V0RmlsdGVyJywgb3B0aW9uKTtcblxuICAgIHJldHVybiBvcHRpb247XG4gIH1cbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGdldEZpbHRlckNoZWNrYm94KGVsLCBjb250YWluZXIgPSAnZmlsdGVycycpIHtcbi8vICAgY29uc3Qgc2V0dGluZ3MgPSBDaGVja2JveEZpbHRlci5wYXJzZVNldHRpbmdzKGVsKTtcbi8vICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyLCBmaWx0ZXI6IHNldHRpbmdzIH0pO1xuLy9cbi8vICAgcmV0dXJuIG5ldyBWdWUoe1xuLy8gICAgIHN0b3JlLFxuLy8gICAgIHJlbmRlcjogaCA9PiBoKEZpbHRlckNoZWNrYm94LCB7XG4vLyAgICAgICBwcm9wczogeyBmaWx0ZXI6IHN0b3JlLnN0YXRlLmZpbHRlcnNbY29udGFpbmVyXVtzZXR0aW5ncy5uYW1lXSB9LFxuLy8gICAgIH0pLFxuLy8gICB9KS4kbW91bnQoZWwpO1xuLy8gfVxuXG5cbi8qKlxuICogU2VsZWN0RmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWxlY3RGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihlbCwgY29udGFpbmVyID0gJ3NvcnQnKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgdGhpcy5maWx0ZXJTZXR0aW5ncyA9IFNlbGVjdEZpbHRlci5wYXJzZVNldHRpbmdzKHRoaXMuZWwpO1xuXG4gICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciwgZmlsdGVyOiB0aGlzLmZpbHRlclNldHRpbmdzIH0pO1xuXG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIHN0b3JlLFxuICAgICAgcmVuZGVyOiBoID0+IGgoRmlsdGVyU2VsZWN0LCB7XG4gICAgICAgIHByb3BzOiB7IGZpbHRlcjogc3RvcmUuc3RhdGUuZmlsdGVyc1t0aGlzLmNvbnRhaW5lcl1bdGhpcy5maWx0ZXJTZXR0aW5ncy5uYW1lXSB9LFxuICAgICAgfSksXG4gICAgfSkuJG1vdW50KHRoaXMuZWwpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2V0dGluZ3MobXVsdGlmaWx0ZXJFbCkge1xuICAgIGNvbnN0IG9wdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICBsYWJlbDogJ9Cd0LUg0LLRi9Cx0YDQsNC90L4nLFxuICAgICAgc2VsZWN0ZWQ6IG51bGwsXG4gICAgICBuYW1lOiBtdWx0aWZpbHRlckVsLmRhdGFzZXQuZmlsdGVyTmFtZSB8fCAnJyxcbiAgICAgIGRhdGE6IFtdLFxuICAgIH07XG5cbiAgICBbXS5mb3JFYWNoLmNhbGwobXVsdGlmaWx0ZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKSwgKGlucHV0KSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbi5uYW1lKSB7XG4gICAgICAgIG9wdGlvbi5uYW1lID0gaW5wdXQubmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaW5wdXQudmFsdWU7XG4gICAgICAgIG9wdGlvbi5sYWJlbCA9IGlucHV0LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXJhZGlvX19sYWJlbCcpLnRleHRDb250ZW50O1xuICAgICAgfVxuXG4gICAgICBvcHRpb24uZGF0YS5wdXNoKHtcbiAgICAgICAgbGFiZWw6IGlucHV0LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXJhZGlvX19sYWJlbCcpLnRleHRDb250ZW50LFxuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lIHx8ICcnLFxuICAgICAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IGlucHV0LmNoZWNrZWQsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmICghb3B0aW9uLm5hbWUpIHtcbiAgICAgIG9wdGlvbi5uYW1lID0gb3B0aW9uLmxhYmVsO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb247XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n")},160:function(module,exports,__webpack_require__){eval('!function(t,n){ true?module.exports=n():undefined}(this,function(){"use strict";function t(t,n){var e=void 0;return function(){e&&clearTimeout(e),e=setTimeout(t,n)}}function n(t,n){for(var e=t.length,r=e,o=[];e--;)o.push(n(t[r-e-1]));return o}function e(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(window.Promise)return A(t,n,e);t.recalculate(!0,!0)}function r(t){for(var n=t.options,e=t.responsiveOptions,r=t.keys,o=t.docWidth,i=void 0,s=0;s<r.length;s++){var a=parseInt(r[s],10);o>=a&&(i=n.breakAt[a],O(i,e))}return e}function o(t){for(var n=t.options,e=t.responsiveOptions,r=t.keys,o=t.docWidth,i=void 0,s=r.length-1;s>=0;s--){var a=parseInt(r[s],10);o<=a&&(i=n.breakAt[a],O(i,e))}return e}function i(t){var n=t.useContainerForBreakpoints?t.container.clientWidth:window.innerWidth,e={columns:t.columns};b(t.margin)?e.margin={x:t.margin.x,y:t.margin.y}:e.margin={x:t.margin,y:t.margin};var i=Object.keys(t.breakAt);return t.mobileFirst?r({options:t,responsiveOptions:e,keys:i,docWidth:n}):o({options:t,responsiveOptions:e,keys:i,docWidth:n})}function s(t){return i(t).columns}function a(t){return i(t).margin}function c(t){var n=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],e=s(t),r=a(t).x,o=100/e;if(!n)return o;if(1===e)return"100%";var i="px";if("string"==typeof r){var c=parseFloat(r);i=r.replace(c,""),r=c}return r=(e-1)*r/e,"%"===i?o-r+"%":"calc("+o+"% - "+r+i+")"}function u(t,n){var e=s(t.options),r=0,o=void 0,i=void 0;if(1===++n)return 0;i=a(t.options).x;var u="px";if("string"==typeof i){var l=parseFloat(i,10);u=i.replace(l,""),i=l}return o=(i-(e-1)*i/e)*(n-1),r+=c(t.options,!1)*(n-1),"%"===u?r+o+"%":"calc("+r+"% + "+o+u+")"}function l(t){var n=0,e=t.container;v(t.rows,function(t){n=t>n?t:n}),e.style.height=n+"px"}function p(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=s(t.options),i=a(t.options).y;M(t,o,e),v(n,function(n){var e=0,o=parseInt(n.offsetHeight,10);isNaN(o)||(t.rows.forEach(function(n,r){n<t.rows[e]&&(e=r)}),n.style.position="absolute",n.style.top=t.rows[e]+"px",n.style.left=""+t.cols[e],t.rows[e]+=isNaN(o)?0:o+i,r&&(n.dataset.macyComplete=1))}),r&&(t.tmpRows=null),l(t)}function f(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=s(t.options),i=a(t.options).y;M(t,o,e),v(n,function(n){t.lastcol===o&&(t.lastcol=0);var e=C(n,"height");e=parseInt(n.offsetHeight,10),isNaN(e)||(n.style.position="absolute",n.style.top=t.rows[t.lastcol]+"px",n.style.left=""+t.cols[t.lastcol],t.rows[t.lastcol]+=isNaN(e)?0:e+i,t.lastcol+=1,r&&(n.dataset.macyComplete=1))}),r&&(t.tmpRows=null),l(t)}var h=function t(n,e){if(!(this instanceof t))return new t(n,e);if(n&&n.nodeName)return n;if(n=n.replace(/^\\s*/,"").replace(/\\s*$/,""),e)return this.byCss(n,e);for(var r in this.selectors)if(e=r.split("/"),new RegExp(e[1],e[2]).test(n))return this.selectors[r](n);return this.byCss(n)};h.prototype.byCss=function(t,n){return(n||document).querySelectorAll(t)},h.prototype.selectors={},h.prototype.selectors[/^\\.[\\w\\-]+$/]=function(t){return document.getElementsByClassName(t.substring(1))},h.prototype.selectors[/^\\w+$/]=function(t){return document.getElementsByTagName(t)},h.prototype.selectors[/^\\#[\\w\\-]+$/]=function(t){return document.getElementById(t.substring(1))};var v=function(t,n){for(var e=t.length,r=e;e--;)n(t[r-e-1])},m=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.running=!1,this.events=[],this.add(t)};m.prototype.run=function(){if(!this.running&&this.events.length>0){var t=this.events.shift();this.running=!0,t(),this.running=!1,this.run()}},m.prototype.add=function(){var t=this,n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return!!n&&(Array.isArray(n)?v(n,function(n){return t.add(n)}):(this.events.push(n),void this.run()))},m.prototype.clear=function(){this.events=[]};var d=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.instance=t,this.data=n,this},y=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.events={},this.instance=t};y.prototype.on=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return!(!t||!n)&&(Array.isArray(this.events[t])||(this.events[t]=[]),this.events[t].push(n))},y.prototype.emit=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!t||!Array.isArray(this.events[t]))return!1;var e=new d(this.instance,n);v(this.events[t],function(t){return t(e)})};var g=function(t){return!("naturalHeight"in t&&t.naturalHeight+t.naturalWidth===0)||t.width+t.height!==0},E=function(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new Promise(function(t,e){if(n.complete)return g(n)?t(n):e(n);n.addEventListener("load",function(){return g(n)?t(n):e(n)}),n.addEventListener("error",function(){return e(n)})}).then(function(n){e&&t.emit(t.constants.EVENT_IMAGE_LOAD,{img:n})}).catch(function(n){return t.emit(t.constants.EVENT_IMAGE_ERROR,{img:n})})},w=function(t,e){var r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return n(e,function(n){return E(t,n,r)})},A=function(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Promise.all(w(t,n,e)).then(function(){t.emit(t.constants.EVENT_IMAGE_COMPLETE)})},I=function(n){return t(function(){n.emit(n.constants.EVENT_RESIZE),n.queue.add(function(){return n.recalculate(!0,!0)})},100)},N=function(t){if(t.container=h(t.options.container),t.container instanceof h||!t.container)return!!t.options.debug&&console.error("Error: Container not found");t.container.length&&(t.container=t.container[0]),t.options.container=t.container,t.container.style.position="relative"},T=function(t){t.queue=new m,t.events=new y(t),t.rows=[],t.resizer=I(t)},L=function(t){var n=h("img",t.container);window.addEventListener("resize",t.resizer),t.on(t.constants.EVENT_IMAGE_LOAD,function(){return t.recalculate(!1,!1)}),t.on(t.constants.EVENT_IMAGE_COMPLETE,function(){return t.recalculate(!0,!0)}),t.options.useOwnImageLoader||e(t,n,!t.options.waitForImages),t.emit(t.constants.EVENT_INITIALIZED)},_=function(t){N(t),T(t),L(t)},b=function(t){return t===Object(t)&&"[object Array]"!==Object.prototype.toString.call(t)},O=function(t,n){b(t)||(n.columns=t),b(t)&&t.columns&&(n.columns=t.columns),b(t)&&t.margin&&!b(t.margin)&&(n.margin={x:t.margin,y:t.margin}),b(t)&&t.margin&&b(t.margin)&&t.margin.x&&(n.margin.x=t.margin.x),b(t)&&t.margin&&b(t.margin)&&t.margin.y&&(n.margin.y=t.margin.y)},C=function(t,n){return window.getComputedStyle(t,null).getPropertyValue(n)},M=function(t,n){var e=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.lastcol||(t.lastcol=0),t.rows.length<1&&(e=!0),e){t.rows=[],t.cols=[],t.lastcol=0;for(var r=n-1;r>=0;r--)t.rows[r]=0,t.cols[r]=u(t,r)}else if(t.tmpRows){t.rows=[];for(var r=n-1;r>=0;r--)t.rows[r]=t.tmpRows[r]}else{t.tmpRows=[];for(var r=n-1;r>=0;r--)t.tmpRows[r]=t.rows[r]}},V=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=n?t.container.children:h(\':scope > *:not([data-macy-complete="1"])\',t.container);r=Array.from(r).filter(function(t){return null!==t.offsetParent});var o=c(t.options);return v(r,function(t){n&&(t.dataset.macyComplete=0),t.style.width=o}),t.options.trueOrder?(f(t,r,n,e),t.emit(t.constants.EVENT_RECALCULATED)):(p(t,r,n,e),t.emit(t.constants.EVENT_RECALCULATED))},R=function(){return!!window.Promise},x=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}return t};Array.from||(Array.from=function(t){for(var n=0,e=[];n<t.length;)e.push(t[n++]);return e});var k={columns:4,margin:2,trueOrder:!1,waitForImages:!1,useImageLoader:!0,breakAt:{},useOwnImageLoader:!1,onInit:!1,cancelLegacy:!1,useContainerForBreakpoints:!1};!function(){try{document.createElement("a").querySelector(":scope *")}catch(t){!function(){function t(t){return function(e){if(e&&n.test(e)){var r=this.getAttribute("id");r||(this.id="q"+Math.floor(9e6*Math.random())+1e6),arguments[0]=e.replace(n,"#"+this.id);var o=t.apply(this,arguments);return null===r?this.removeAttribute("id"):r||(this.id=r),o}return t.apply(this,arguments)}}var n=/:scope\\b/gi,e=t(Element.prototype.querySelector);Element.prototype.querySelector=function(t){return e.apply(this,arguments)};var r=t(Element.prototype.querySelectorAll);Element.prototype.querySelectorAll=function(t){return r.apply(this,arguments)}}()}}();var q=function t(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:k;if(!(this instanceof t))return new t(n);this.options={},x(this.options,k,n),this.options.cancelLegacy&&!R()||_(this)};return q.init=function(t){return console.warn("Depreciated: Macy.init will be removed in v3.0.0 opt to use Macy directly like so Macy({ /*options here*/ }) "),new q(t)},q.prototype.recalculateOnImageLoad=function(){var t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return e(this,h("img",this.container),!t)},q.prototype.runOnImageLoad=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=h("img",this.container);return this.on(this.constants.EVENT_IMAGE_COMPLETE,t),n&&this.on(this.constants.EVENT_IMAGE_LOAD,t),e(this,r,n)},q.prototype.recalculate=function(){var t=this,n=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return e&&this.queue.clear(),this.queue.add(function(){return V(t,n,e)})},q.prototype.remove=function(){window.removeEventListener("resize",this.resizer),v(this.container.children,function(t){t.removeAttribute("data-macy-complete"),t.removeAttribute("style")}),this.container.removeAttribute("style")},q.prototype.reInit=function(){this.recalculate(!0,!0),this.emit(this.constants.EVENT_INITIALIZED),window.addEventListener("resize",this.resizer),this.container.style.position="relative"},q.prototype.on=function(t,n){this.events.on(t,n)},q.prototype.emit=function(t,n){this.events.emit(t,n)},q.constants={EVENT_INITIALIZED:"macy.initialized",EVENT_RECALCULATED:"macy.recalculated",EVENT_IMAGE_LOAD:"macy.image.load",EVENT_IMAGE_ERROR:"macy.image.error",EVENT_IMAGE_COMPLETE:"macy.images.complete",EVENT_RESIZE:"macy.resize"},q.prototype.constants=q.constants,q});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFjeS9kaXN0L21hY3kuanM/ZTE2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQW9ELG9CQUFvQixTQUEwRCxDQUFDLGlCQUFpQixhQUFhLGdCQUFnQixhQUFhLGtCQUFrQixzQ0FBc0MsZ0JBQWdCLDRCQUE0QixJQUFJLHFCQUFxQixTQUFTLGdCQUFnQiw4REFBOEQsa0NBQWtDLHFCQUFxQixjQUFjLDZFQUE2RSxXQUFXLEtBQUssd0JBQXdCLDhCQUE4QixTQUFTLGNBQWMsc0ZBQXNGLEtBQUssS0FBSyx3QkFBd0IsOEJBQThCLFNBQVMsY0FBYyxnRkFBZ0YsbUJBQW1CLHNCQUFzQiwwQkFBMEIsV0FBVyx1QkFBdUIsNkJBQTZCLHdCQUF3QixnREFBZ0QsS0FBSyxnREFBZ0QsRUFBRSxjQUFjLG9CQUFvQixjQUFjLG1CQUFtQixjQUFjLHlGQUF5RixlQUFlLHNCQUFzQixXQUFXLHVCQUF1QixvQkFBb0Isc0JBQXNCLDREQUE0RCxnQkFBZ0IseUNBQXlDLG9CQUFvQixpQkFBaUIsV0FBVyx1QkFBdUIsdUJBQXVCLHNCQUFzQiwrRkFBK0YsY0FBYyxzQkFBc0IscUJBQXFCLFVBQVUsd0JBQXdCLGdCQUFnQiwySkFBMkoseUJBQXlCLHNDQUFzQyx3Q0FBd0MsbUJBQW1CLDRJQUE0SSwyQkFBMkIsZ0JBQWdCLDJKQUEySix5QkFBeUIsNkJBQTZCLG9CQUFvQix3TkFBd04sMkJBQTJCLHNCQUFzQiwwQ0FBMEMsMEJBQTBCLHNFQUFzRSx3R0FBd0csc0JBQXNCLGdDQUFnQyx3Q0FBd0MseUJBQXlCLGtEQUFrRCx1REFBdUQsNENBQTRDLHdDQUF3QyxrREFBa0QsZ0RBQWdELG9CQUFvQix1QkFBdUIsSUFBSSxhQUFhLGNBQWMsOERBQThELDRDQUE0QywyQkFBMkIsd0NBQXdDLDBCQUEwQixnREFBZ0QsNEJBQTRCLHFFQUFxRSw2Q0FBNkMsZ0JBQWdCLHlDQUF5Qyw4QkFBOEIsZ0JBQWdCLGtCQUFrQixnRUFBZ0Usd0NBQXdDLGNBQWMsOERBQThELGNBQWMsa0JBQWtCLDBCQUEwQix3SEFBd0gsNkZBQTZGLDZCQUE2QiwwSEFBMEgsK0NBQStDLDZCQUE2Qiw2QkFBNkIsWUFBWSxHQUFHLGtCQUFrQix1RkFBdUYsaUJBQWlCLDhEQUE4RCxpQ0FBaUMsb0NBQW9DLHFDQUFxQyxzQkFBc0Isd0NBQXdDLFlBQVksRUFBRSxtQkFBbUIsd0NBQXdDLE1BQU0sRUFBRSxvQkFBb0IsNkNBQTZDLE1BQU0sRUFBRSxFQUFFLGlCQUFpQiw4REFBOEQsdUJBQXVCLGdCQUFnQixFQUFFLGlCQUFpQiw4REFBOEQsNkNBQTZDLHlDQUF5QyxFQUFFLGVBQWUsb0JBQW9CLHdEQUF3RCw0QkFBNEIsRUFBRSxNQUFNLGVBQWUsa0pBQWtKLHVIQUF1SCxlQUFlLHlEQUF5RCxlQUFlLDJCQUEyQix5RkFBeUYsNEJBQTRCLG1EQUFtRCw0QkFBNEIscUdBQXFHLGVBQWUsZUFBZSxlQUFlLDJFQUEyRSxpQkFBaUIsb0dBQW9HLHNCQUFzQixvSUFBb0ksaUJBQWlCLDJEQUEyRCxpQkFBaUIsOERBQThELHVEQUF1RCxnQ0FBZ0MsY0FBYyxLQUFLLGlDQUFpQyxtQkFBbUIsVUFBVSxjQUFjLEtBQUssMkJBQTJCLEtBQUssYUFBYSxjQUFjLEtBQUssNEJBQTRCLGVBQWUsOE1BQThNLG1DQUFtQyw2QkFBNkIsRUFBRSxtQkFBbUIsdUJBQXVCLDhDQUE4Qyw4SEFBOEgsY0FBYyx1QkFBdUIsOEJBQThCLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxVQUFVLG9DQUFvQyxpQkFBaUIsV0FBVyxnQkFBZ0IsU0FBUyxFQUFFLE9BQU8sNkVBQTZFLCtFQUErRSxZQUFZLElBQUksc0RBQXNELFNBQVMsWUFBWSxjQUFjLG1CQUFtQixpQkFBaUIsOEJBQThCLHlGQUF5Riw4QkFBOEIsNERBQTRELGdDQUFnQyx3REFBd0QsNENBQTRDLGdDQUFnQyw0Q0FBNEMsK0NBQStDLGdDQUFnQyxJQUFJLEdBQUcsbUJBQW1CLCtEQUErRCx3Q0FBd0MsZUFBZSwrREFBK0QsMEJBQTBCLDZHQUE2RyxtQkFBbUIsY0FBYywrQ0FBK0MsOERBQThELDBDQUEwQyx3Q0FBd0Msd0ZBQXdGLGdIQUFnSCxvQ0FBb0Msa0lBQWtJLHVEQUF1RCxnQkFBZ0IsRUFBRSwrQkFBK0Isd0ZBQXdGLG1FQUFtRSwwQ0FBMEMsK0JBQStCLDRKQUE0Siw4QkFBOEIsb0JBQW9CLGdDQUFnQyxzQkFBc0IsY0FBYywyTkFBMk4scUNBQXFDIiwiZmlsZSI6IjE2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiFmdW5jdGlvbih0LG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4oKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKG4pOnQuTWFjeT1uKCl9KHRoaXMsZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiB0KHQsbil7dmFyIGU9dm9pZCAwO3JldHVybiBmdW5jdGlvbigpe2UmJmNsZWFyVGltZW91dChlKSxlPXNldFRpbWVvdXQodCxuKX19ZnVuY3Rpb24gbih0LG4pe2Zvcih2YXIgZT10Lmxlbmd0aCxyPWUsbz1bXTtlLS07KW8ucHVzaChuKHRbci1lLTFdKSk7cmV0dXJuIG99ZnVuY3Rpb24gZSh0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07aWYod2luZG93LlByb21pc2UpcmV0dXJuIEEodCxuLGUpO3QucmVjYWxjdWxhdGUoITAsITApfWZ1bmN0aW9uIHIodCl7Zm9yKHZhciBuPXQub3B0aW9ucyxlPXQucmVzcG9uc2l2ZU9wdGlvbnMscj10LmtleXMsbz10LmRvY1dpZHRoLGk9dm9pZCAwLHM9MDtzPHIubGVuZ3RoO3MrKyl7dmFyIGE9cGFyc2VJbnQocltzXSwxMCk7bz49YSYmKGk9bi5icmVha0F0W2FdLE8oaSxlKSl9cmV0dXJuIGV9ZnVuY3Rpb24gbyh0KXtmb3IodmFyIG49dC5vcHRpb25zLGU9dC5yZXNwb25zaXZlT3B0aW9ucyxyPXQua2V5cyxvPXQuZG9jV2lkdGgsaT12b2lkIDAscz1yLmxlbmd0aC0xO3M+PTA7cy0tKXt2YXIgYT1wYXJzZUludChyW3NdLDEwKTtvPD1hJiYoaT1uLmJyZWFrQXRbYV0sTyhpLGUpKX1yZXR1cm4gZX1mdW5jdGlvbiBpKHQpe3ZhciBuPXQudXNlQ29udGFpbmVyRm9yQnJlYWtwb2ludHM/dC5jb250YWluZXIuY2xpZW50V2lkdGg6d2luZG93LmlubmVyV2lkdGgsZT17Y29sdW1uczp0LmNvbHVtbnN9O2IodC5tYXJnaW4pP2UubWFyZ2luPXt4OnQubWFyZ2luLngseTp0Lm1hcmdpbi55fTplLm1hcmdpbj17eDp0Lm1hcmdpbix5OnQubWFyZ2lufTt2YXIgaT1PYmplY3Qua2V5cyh0LmJyZWFrQXQpO3JldHVybiB0Lm1vYmlsZUZpcnN0P3Ioe29wdGlvbnM6dCxyZXNwb25zaXZlT3B0aW9uczplLGtleXM6aSxkb2NXaWR0aDpufSk6byh7b3B0aW9uczp0LHJlc3BvbnNpdmVPcHRpb25zOmUsa2V5czppLGRvY1dpZHRoOm59KX1mdW5jdGlvbiBzKHQpe3JldHVybiBpKHQpLmNvbHVtbnN9ZnVuY3Rpb24gYSh0KXtyZXR1cm4gaSh0KS5tYXJnaW59ZnVuY3Rpb24gYyh0KXt2YXIgbj0hKGFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdKXx8YXJndW1lbnRzWzFdLGU9cyh0KSxyPWEodCkueCxvPTEwMC9lO2lmKCFuKXJldHVybiBvO2lmKDE9PT1lKXJldHVyblwiMTAwJVwiO3ZhciBpPVwicHhcIjtpZihcInN0cmluZ1wiPT10eXBlb2Ygcil7dmFyIGM9cGFyc2VGbG9hdChyKTtpPXIucmVwbGFjZShjLFwiXCIpLHI9Y31yZXR1cm4gcj0oZS0xKSpyL2UsXCIlXCI9PT1pP28tcitcIiVcIjpcImNhbGMoXCIrbytcIiUgLSBcIityK2krXCIpXCJ9ZnVuY3Rpb24gdSh0LG4pe3ZhciBlPXModC5vcHRpb25zKSxyPTAsbz12b2lkIDAsaT12b2lkIDA7aWYoMT09PSsrbilyZXR1cm4gMDtpPWEodC5vcHRpb25zKS54O3ZhciB1PVwicHhcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgaSl7dmFyIGw9cGFyc2VGbG9hdChpLDEwKTt1PWkucmVwbGFjZShsLFwiXCIpLGk9bH1yZXR1cm4gbz0oaS0oZS0xKSppL2UpKihuLTEpLHIrPWModC5vcHRpb25zLCExKSoobi0xKSxcIiVcIj09PXU/citvK1wiJVwiOlwiY2FsYyhcIityK1wiJSArIFwiK28rdStcIilcIn1mdW5jdGlvbiBsKHQpe3ZhciBuPTAsZT10LmNvbnRhaW5lcjt2KHQucm93cyxmdW5jdGlvbih0KXtuPXQ+bj90Om59KSxlLnN0eWxlLmhlaWdodD1uK1wicHhcIn1mdW5jdGlvbiBwKHQsbil7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXSxyPSEoYXJndW1lbnRzLmxlbmd0aD4zJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10pfHxhcmd1bWVudHNbM10sbz1zKHQub3B0aW9ucyksaT1hKHQub3B0aW9ucykueTtNKHQsbyxlKSx2KG4sZnVuY3Rpb24obil7dmFyIGU9MCxvPXBhcnNlSW50KG4ub2Zmc2V0SGVpZ2h0LDEwKTtpc05hTihvKXx8KHQucm93cy5mb3JFYWNoKGZ1bmN0aW9uKG4scil7bjx0LnJvd3NbZV0mJihlPXIpfSksbi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsbi5zdHlsZS50b3A9dC5yb3dzW2VdK1wicHhcIixuLnN0eWxlLmxlZnQ9XCJcIit0LmNvbHNbZV0sdC5yb3dzW2VdKz1pc05hTihvKT8wOm8raSxyJiYobi5kYXRhc2V0Lm1hY3lDb21wbGV0ZT0xKSl9KSxyJiYodC50bXBSb3dzPW51bGwpLGwodCl9ZnVuY3Rpb24gZih0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl0scj0hKGFyZ3VtZW50cy5sZW5ndGg+MyYmdm9pZCAwIT09YXJndW1lbnRzWzNdKXx8YXJndW1lbnRzWzNdLG89cyh0Lm9wdGlvbnMpLGk9YSh0Lm9wdGlvbnMpLnk7TSh0LG8sZSksdihuLGZ1bmN0aW9uKG4pe3QubGFzdGNvbD09PW8mJih0Lmxhc3Rjb2w9MCk7dmFyIGU9QyhuLFwiaGVpZ2h0XCIpO2U9cGFyc2VJbnQobi5vZmZzZXRIZWlnaHQsMTApLGlzTmFOKGUpfHwobi5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCIsbi5zdHlsZS50b3A9dC5yb3dzW3QubGFzdGNvbF0rXCJweFwiLG4uc3R5bGUubGVmdD1cIlwiK3QuY29sc1t0Lmxhc3Rjb2xdLHQucm93c1t0Lmxhc3Rjb2xdKz1pc05hTihlKT8wOmUraSx0Lmxhc3Rjb2wrPTEsciYmKG4uZGF0YXNldC5tYWN5Q29tcGxldGU9MSkpfSksciYmKHQudG1wUm93cz1udWxsKSxsKHQpfXZhciBoPWZ1bmN0aW9uIHQobixlKXtpZighKHRoaXMgaW5zdGFuY2VvZiB0KSlyZXR1cm4gbmV3IHQobixlKTtpZihuJiZuLm5vZGVOYW1lKXJldHVybiBuO2lmKG49bi5yZXBsYWNlKC9eXFxzKi8sXCJcIikucmVwbGFjZSgvXFxzKiQvLFwiXCIpLGUpcmV0dXJuIHRoaXMuYnlDc3MobixlKTtmb3IodmFyIHIgaW4gdGhpcy5zZWxlY3RvcnMpaWYoZT1yLnNwbGl0KFwiL1wiKSxuZXcgUmVnRXhwKGVbMV0sZVsyXSkudGVzdChuKSlyZXR1cm4gdGhpcy5zZWxlY3RvcnNbcl0obik7cmV0dXJuIHRoaXMuYnlDc3Mobil9O2gucHJvdG90eXBlLmJ5Q3NzPWZ1bmN0aW9uKHQsbil7cmV0dXJuKG58fGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKHQpfSxoLnByb3RvdHlwZS5zZWxlY3RvcnM9e30saC5wcm90b3R5cGUuc2VsZWN0b3JzWy9eXFwuW1xcd1xcLV0rJC9dPWZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKHQuc3Vic3RyaW5nKDEpKX0saC5wcm90b3R5cGUuc2VsZWN0b3JzWy9eXFx3KyQvXT1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodCl9LGgucHJvdG90eXBlLnNlbGVjdG9yc1svXlxcI1tcXHdcXC1dKyQvXT1mdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodC5zdWJzdHJpbmcoMSkpfTt2YXIgdj1mdW5jdGlvbih0LG4pe2Zvcih2YXIgZT10Lmxlbmd0aCxyPWU7ZS0tOyluKHRbci1lLTFdKX0sbT1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07dGhpcy5ydW5uaW5nPSExLHRoaXMuZXZlbnRzPVtdLHRoaXMuYWRkKHQpfTttLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXtpZighdGhpcy5ydW5uaW5nJiZ0aGlzLmV2ZW50cy5sZW5ndGg+MCl7dmFyIHQ9dGhpcy5ldmVudHMuc2hpZnQoKTt0aGlzLnJ1bm5pbmc9ITAsdCgpLHRoaXMucnVubmluZz0hMSx0aGlzLnJ1bigpfX0sbS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcyxuPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF07cmV0dXJuISFuJiYoQXJyYXkuaXNBcnJheShuKT92KG4sZnVuY3Rpb24obil7cmV0dXJuIHQuYWRkKG4pfSk6KHRoaXMuZXZlbnRzLnB1c2gobiksdm9pZCB0aGlzLnJ1bigpKSl9LG0ucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5ldmVudHM9W119O3ZhciBkPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTtyZXR1cm4gdGhpcy5pbnN0YW5jZT10LHRoaXMuZGF0YT1uLHRoaXN9LHk9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO3RoaXMuZXZlbnRzPXt9LHRoaXMuaW5zdGFuY2U9dH07eS5wcm90b3R5cGUub249ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdLG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXTtyZXR1cm4hKCF0fHwhbikmJihBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzW3RdKXx8KHRoaXMuZXZlbnRzW3RdPVtdKSx0aGlzLmV2ZW50c1t0XS5wdXNoKG4pKX0seS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0sbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06e307aWYoIXR8fCFBcnJheS5pc0FycmF5KHRoaXMuZXZlbnRzW3RdKSlyZXR1cm4hMTt2YXIgZT1uZXcgZCh0aGlzLmluc3RhbmNlLG4pO3YodGhpcy5ldmVudHNbdF0sZnVuY3Rpb24odCl7cmV0dXJuIHQoZSl9KX07dmFyIGc9ZnVuY3Rpb24odCl7cmV0dXJuIShcIm5hdHVyYWxIZWlnaHRcImluIHQmJnQubmF0dXJhbEhlaWdodCt0Lm5hdHVyYWxXaWR0aD09PTApfHx0LndpZHRoK3QuaGVpZ2h0IT09MH0sRT1mdW5jdGlvbih0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHQsZSl7aWYobi5jb21wbGV0ZSlyZXR1cm4gZyhuKT90KG4pOmUobik7bi5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGcobik/dChuKTplKG4pfSksbi5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbigpe3JldHVybiBlKG4pfSl9KS50aGVuKGZ1bmN0aW9uKG4pe2UmJnQuZW1pdCh0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9MT0FELHtpbWc6bn0pfSkuY2F0Y2goZnVuY3Rpb24obil7cmV0dXJuIHQuZW1pdCh0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9FUlJPUix7aW1nOm59KX0pfSx3PWZ1bmN0aW9uKHQsZSl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtyZXR1cm4gbihlLGZ1bmN0aW9uKG4pe3JldHVybiBFKHQsbixyKX0pfSxBPWZ1bmN0aW9uKHQsbil7dmFyIGU9YXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0mJmFyZ3VtZW50c1syXTtyZXR1cm4gUHJvbWlzZS5hbGwodyh0LG4sZSkpLnRoZW4oZnVuY3Rpb24oKXt0LmVtaXQodC5jb25zdGFudHMuRVZFTlRfSU1BR0VfQ09NUExFVEUpfSl9LEk9ZnVuY3Rpb24obil7cmV0dXJuIHQoZnVuY3Rpb24oKXtuLmVtaXQobi5jb25zdGFudHMuRVZFTlRfUkVTSVpFKSxuLnF1ZXVlLmFkZChmdW5jdGlvbigpe3JldHVybiBuLnJlY2FsY3VsYXRlKCEwLCEwKX0pfSwxMDApfSxOPWZ1bmN0aW9uKHQpe2lmKHQuY29udGFpbmVyPWgodC5vcHRpb25zLmNvbnRhaW5lciksdC5jb250YWluZXIgaW5zdGFuY2VvZiBofHwhdC5jb250YWluZXIpcmV0dXJuISF0Lm9wdGlvbnMuZGVidWcmJmNvbnNvbGUuZXJyb3IoXCJFcnJvcjogQ29udGFpbmVyIG5vdCBmb3VuZFwiKTt0LmNvbnRhaW5lci5sZW5ndGgmJih0LmNvbnRhaW5lcj10LmNvbnRhaW5lclswXSksdC5vcHRpb25zLmNvbnRhaW5lcj10LmNvbnRhaW5lcix0LmNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCJ9LFQ9ZnVuY3Rpb24odCl7dC5xdWV1ZT1uZXcgbSx0LmV2ZW50cz1uZXcgeSh0KSx0LnJvd3M9W10sdC5yZXNpemVyPUkodCl9LEw9ZnVuY3Rpb24odCl7dmFyIG49aChcImltZ1wiLHQuY29udGFpbmVyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHQucmVzaXplciksdC5vbih0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9MT0FELGZ1bmN0aW9uKCl7cmV0dXJuIHQucmVjYWxjdWxhdGUoITEsITEpfSksdC5vbih0LmNvbnN0YW50cy5FVkVOVF9JTUFHRV9DT01QTEVURSxmdW5jdGlvbigpe3JldHVybiB0LnJlY2FsY3VsYXRlKCEwLCEwKX0pLHQub3B0aW9ucy51c2VPd25JbWFnZUxvYWRlcnx8ZSh0LG4sIXQub3B0aW9ucy53YWl0Rm9ySW1hZ2VzKSx0LmVtaXQodC5jb25zdGFudHMuRVZFTlRfSU5JVElBTElaRUQpfSxfPWZ1bmN0aW9uKHQpe04odCksVCh0KSxMKHQpfSxiPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09T2JqZWN0KHQpJiZcIltvYmplY3QgQXJyYXldXCIhPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9LE89ZnVuY3Rpb24odCxuKXtiKHQpfHwobi5jb2x1bW5zPXQpLGIodCkmJnQuY29sdW1ucyYmKG4uY29sdW1ucz10LmNvbHVtbnMpLGIodCkmJnQubWFyZ2luJiYhYih0Lm1hcmdpbikmJihuLm1hcmdpbj17eDp0Lm1hcmdpbix5OnQubWFyZ2lufSksYih0KSYmdC5tYXJnaW4mJmIodC5tYXJnaW4pJiZ0Lm1hcmdpbi54JiYobi5tYXJnaW4ueD10Lm1hcmdpbi54KSxiKHQpJiZ0Lm1hcmdpbiYmYih0Lm1hcmdpbikmJnQubWFyZ2luLnkmJihuLm1hcmdpbi55PXQubWFyZ2luLnkpfSxDPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuKX0sTT1mdW5jdGlvbih0LG4pe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MiYmdm9pZCAwIT09YXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMl07aWYodC5sYXN0Y29sfHwodC5sYXN0Y29sPTApLHQucm93cy5sZW5ndGg8MSYmKGU9ITApLGUpe3Qucm93cz1bXSx0LmNvbHM9W10sdC5sYXN0Y29sPTA7Zm9yKHZhciByPW4tMTtyPj0wO3ItLSl0LnJvd3Nbcl09MCx0LmNvbHNbcl09dSh0LHIpfWVsc2UgaWYodC50bXBSb3dzKXt0LnJvd3M9W107Zm9yKHZhciByPW4tMTtyPj0wO3ItLSl0LnJvd3Nbcl09dC50bXBSb3dzW3JdfWVsc2V7dC50bXBSb3dzPVtdO2Zvcih2YXIgcj1uLTE7cj49MDtyLS0pdC50bXBSb3dzW3JdPXQucm93c1tyXX19LFY9ZnVuY3Rpb24odCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0mJmFyZ3VtZW50c1sxXSxlPSEoYXJndW1lbnRzLmxlbmd0aD4yJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0pfHxhcmd1bWVudHNbMl0scj1uP3QuY29udGFpbmVyLmNoaWxkcmVuOmgoJzpzY29wZSA+ICo6bm90KFtkYXRhLW1hY3ktY29tcGxldGU9XCIxXCJdKScsdC5jb250YWluZXIpO3I9QXJyYXkuZnJvbShyKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10Lm9mZnNldFBhcmVudH0pO3ZhciBvPWModC5vcHRpb25zKTtyZXR1cm4gdihyLGZ1bmN0aW9uKHQpe24mJih0LmRhdGFzZXQubWFjeUNvbXBsZXRlPTApLHQuc3R5bGUud2lkdGg9b30pLHQub3B0aW9ucy50cnVlT3JkZXI/KGYodCxyLG4sZSksdC5lbWl0KHQuY29uc3RhbnRzLkVWRU5UX1JFQ0FMQ1VMQVRFRCkpOihwKHQscixuLGUpLHQuZW1pdCh0LmNvbnN0YW50cy5FVkVOVF9SRUNBTENVTEFURUQpKX0sUj1mdW5jdGlvbigpe3JldHVybiEhd2luZG93LlByb21pc2V9LHg9T2JqZWN0LmFzc2lnbnx8ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTE7bjxhcmd1bWVudHMubGVuZ3RoO24rKyl7dmFyIGU9YXJndW1lbnRzW25dO2Zvcih2YXIgciBpbiBlKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiYodFtyXT1lW3JdKX1yZXR1cm4gdH07QXJyYXkuZnJvbXx8KEFycmF5LmZyb209ZnVuY3Rpb24odCl7Zm9yKHZhciBuPTAsZT1bXTtuPHQubGVuZ3RoOyllLnB1c2godFtuKytdKTtyZXR1cm4gZX0pO3ZhciBrPXtjb2x1bW5zOjQsbWFyZ2luOjIsdHJ1ZU9yZGVyOiExLHdhaXRGb3JJbWFnZXM6ITEsdXNlSW1hZ2VMb2FkZXI6ITAsYnJlYWtBdDp7fSx1c2VPd25JbWFnZUxvYWRlcjohMSxvbkluaXQ6ITEsY2FuY2VsTGVnYWN5OiExLHVzZUNvbnRhaW5lckZvckJyZWFrcG9pbnRzOiExfTshZnVuY3Rpb24oKXt0cnl7ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIikucXVlcnlTZWxlY3RvcihcIjpzY29wZSAqXCIpfWNhdGNoKHQpeyFmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKGUmJm4udGVzdChlKSl7dmFyIHI9dGhpcy5nZXRBdHRyaWJ1dGUoXCJpZFwiKTtyfHwodGhpcy5pZD1cInFcIitNYXRoLmZsb29yKDllNipNYXRoLnJhbmRvbSgpKSsxZTYpLGFyZ3VtZW50c1swXT1lLnJlcGxhY2UobixcIiNcIit0aGlzLmlkKTt2YXIgbz10LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gbnVsbD09PXI/dGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTpyfHwodGhpcy5pZD1yKSxvfXJldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIG49LzpzY29wZVxcYi9naSxlPXQoRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvcik7RWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvcj1mdW5jdGlvbih0KXtyZXR1cm4gZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O3ZhciByPXQoRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCk7RWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbD1mdW5jdGlvbih0KXtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSgpfX0oKTt2YXIgcT1mdW5jdGlvbiB0KCl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/YXJndW1lbnRzWzBdOms7aWYoISh0aGlzIGluc3RhbmNlb2YgdCkpcmV0dXJuIG5ldyB0KG4pO3RoaXMub3B0aW9ucz17fSx4KHRoaXMub3B0aW9ucyxrLG4pLHRoaXMub3B0aW9ucy5jYW5jZWxMZWdhY3kmJiFSKCl8fF8odGhpcyl9O3JldHVybiBxLmluaXQ9ZnVuY3Rpb24odCl7cmV0dXJuIGNvbnNvbGUud2FybihcIkRlcHJlY2lhdGVkOiBNYWN5LmluaXQgd2lsbCBiZSByZW1vdmVkIGluIHYzLjAuMCBvcHQgdG8gdXNlIE1hY3kgZGlyZWN0bHkgbGlrZSBzbyBNYWN5KHsgLypvcHRpb25zIGhlcmUqLyB9KSBcIiksbmV3IHEodCl9LHEucHJvdG90eXBlLnJlY2FsY3VsYXRlT25JbWFnZUxvYWQ9ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdO3JldHVybiBlKHRoaXMsaChcImltZ1wiLHRoaXMuY29udGFpbmVyKSwhdCl9LHEucHJvdG90eXBlLnJ1bk9uSW1hZ2VMb2FkPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdJiZhcmd1bWVudHNbMV0scj1oKFwiaW1nXCIsdGhpcy5jb250YWluZXIpO3JldHVybiB0aGlzLm9uKHRoaXMuY29uc3RhbnRzLkVWRU5UX0lNQUdFX0NPTVBMRVRFLHQpLG4mJnRoaXMub24odGhpcy5jb25zdGFudHMuRVZFTlRfSU1BR0VfTE9BRCx0KSxlKHRoaXMscixuKX0scS5wcm90b3R5cGUucmVjYWxjdWxhdGU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLG49YXJndW1lbnRzLmxlbmd0aD4wJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXSxlPSEoYXJndW1lbnRzLmxlbmd0aD4xJiZ2b2lkIDAhPT1hcmd1bWVudHNbMV0pfHxhcmd1bWVudHNbMV07cmV0dXJuIGUmJnRoaXMucXVldWUuY2xlYXIoKSx0aGlzLnF1ZXVlLmFkZChmdW5jdGlvbigpe3JldHVybiBWKHQsbixlKX0pfSxxLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMucmVzaXplciksdih0aGlzLmNvbnRhaW5lci5jaGlsZHJlbixmdW5jdGlvbih0KXt0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbWFjeS1jb21wbGV0ZVwiKSx0LnJlbW92ZUF0dHJpYnV0ZShcInN0eWxlXCIpfSksdGhpcy5jb250YWluZXIucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIil9LHEucHJvdG90eXBlLnJlSW5pdD1mdW5jdGlvbigpe3RoaXMucmVjYWxjdWxhdGUoITAsITApLHRoaXMuZW1pdCh0aGlzLmNvbnN0YW50cy5FVkVOVF9JTklUSUFMSVpFRCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnJlc2l6ZXIpLHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIn0scS5wcm90b3R5cGUub249ZnVuY3Rpb24odCxuKXt0aGlzLmV2ZW50cy5vbih0LG4pfSxxLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHQsbil7dGhpcy5ldmVudHMuZW1pdCh0LG4pfSxxLmNvbnN0YW50cz17RVZFTlRfSU5JVElBTElaRUQ6XCJtYWN5LmluaXRpYWxpemVkXCIsRVZFTlRfUkVDQUxDVUxBVEVEOlwibWFjeS5yZWNhbGN1bGF0ZWRcIixFVkVOVF9JTUFHRV9MT0FEOlwibWFjeS5pbWFnZS5sb2FkXCIsRVZFTlRfSU1BR0VfRVJST1I6XCJtYWN5LmltYWdlLmVycm9yXCIsRVZFTlRfSU1BR0VfQ09NUExFVEU6XCJtYWN5LmltYWdlcy5jb21wbGV0ZVwiLEVWRU5UX1JFU0laRTpcIm1hY3kucmVzaXplXCJ9LHEucHJvdG90eXBlLmNvbnN0YW50cz1xLmNvbnN0YW50cyxxfSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///160\n')},17:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/Dropdown.vue?vue&type=template&id=f86c24e2&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'fieldset\',_vm._b({directives:[{name:"click-outside",rawName:"v-click-outside",value:(_vm.close),expression:"close"}],class:{ show: _vm.visible }},\'fieldset\',_vm.$attrs,false),[_c(\'button\',{staticClass:"multifilter__content multifilter__content_dropdown",attrs:{"type":"button"},on:{"click":function($event){$event.preventDefault();return _vm.toggle($event)}}},[_vm._t("btn")],2),_vm._v(" "),_vm._t("default"),_vm._v(" "),_c(\'div\',{ref:"menu",staticClass:"dropdown-menu",class:{ show: _vm.visible }},[_vm._t("body")],2)],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/Dropdown.vue?vue&type=template&id=f86c24e2&\n\n// EXTERNAL MODULE: ./node_modules/simplebar/dist/simplebar.esm.js\nvar simplebar_esm = __webpack_require__(36);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/Dropdown.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n // import simplebar from \'simplebar-vue\';\n// import \'simplebar/dist/simplebar.min.css\';\n\n/* harmony default export */ var Dropdownvue_type_script_lang_js_ = ({\n  name: \'MultifilterDropdown\',\n  // components: {\n  //   simplebar\n  // },\n  props: {\n    scrolled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function data() {\n    return {\n      visible: false\n    };\n  },\n  mounted: function mounted() {\n    // $(this.$el).on(\'hidden.bs.dropdown\', () => {\n    //   this.visible = false;\n    // });\n    // $(this.$el).on(\'shown.bs.dropdown\', () => {\n    //   this.visible = true;\n    // });\n    if (this.scrolled) {\n      new simplebar_esm["a" /* default */](this.$refs.menu, {\n        autoHide: false\n      });\n    }\n  },\n  methods: {\n    open: function open() {\n      this.visible = true;\n    },\n    close: function close() {\n      this.visible = false;\n    },\n    toggle: function toggle() {\n      this.visible = !this.visible;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/Dropdown.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Dropdownvue_type_script_lang_js_ = (Dropdownvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/Dropdown.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_Dropdownvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Dropdown = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9Ecm9wZG93bi52dWU/MzRiMSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvRHJvcGRvd24udnVlP2U4N2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvRHJvcGRvd24udnVlPzhhOGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvRHJvcGRvd24udnVlP2FmZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLDZCQUE2QixhQUFhLG9GQUFvRixTQUFTLHFCQUFxQiw0Q0FBNEMsd0VBQXdFLGdCQUFnQixLQUFLLHlCQUF5Qix3QkFBd0IsNEJBQTRCLHdFQUF3RSw4Q0FBOEMscUJBQXFCO0FBQ3RsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NDK0JBO0FBQ0E7O0FBRUE7QUFDQSw2QkFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFEQTtBQUVBO0FBRkE7QUFEQSxHQUxBO0FBV0EsTUFYQSxrQkFXQTtBQUNBO0FBQ0E7QUFEQTtBQUdBLEdBZkE7QUFnQkEsU0FoQkEscUJBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBLEdBM0JBO0FBNEJBO0FBQ0EsUUFEQSxrQkFDQTtBQUNBO0FBQ0EsS0FIQTtBQUlBLFNBSkEsbUJBSUE7QUFDQTtBQUNBLEtBTkE7QUFPQSxVQVBBLG9CQU9BO0FBQ0E7QUFDQTtBQVRBO0FBNUJBLEc7O0FDbkN3TCxDQUFnQixnSEFBRyxFQUFDLEM7Ozs7O0FDQXJIO0FBQzNCO0FBQ0w7OztBQUd2RDtBQUM2RjtBQUM3RixnQkFBZ0IsOENBQVU7QUFDMUIsRUFBRSwyQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSx5RiIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdmaWVsZHNldCcsX3ZtLl9iKHtkaXJlY3RpdmVzOlt7bmFtZTpcImNsaWNrLW91dHNpZGVcIixyYXdOYW1lOlwidi1jbGljay1vdXRzaWRlXCIsdmFsdWU6KF92bS5jbG9zZSksZXhwcmVzc2lvbjpcImNsb3NlXCJ9XSxjbGFzczp7IHNob3c6IF92bS52aXNpYmxlIH19LCdmaWVsZHNldCcsX3ZtLiRhdHRycyxmYWxzZSksW19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19jb250ZW50IG11bHRpZmlsdGVyX19jb250ZW50X2Ryb3Bkb3duXCIsYXR0cnM6e1widHlwZVwiOlwiYnV0dG9uXCJ9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLnRvZ2dsZSgkZXZlbnQpfX19LFtfdm0uX3QoXCJidG5cIildLDIpLF92bS5fdihcIiBcIiksX3ZtLl90KFwiZGVmYXVsdFwiKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtyZWY6XCJtZW51XCIsc3RhdGljQ2xhc3M6XCJkcm9wZG93bi1tZW51XCIsY2xhc3M6eyBzaG93OiBfdm0udmlzaWJsZSB9fSxbX3ZtLl90KFwiYm9keVwiKV0sMildLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxmaWVsZHNldFxuICAgIHYtY2xpY2stb3V0c2lkZT1cImNsb3NlXCJcbiAgICA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiXG4gICAgdi1iaW5kPVwiJGF0dHJzXCJcbiAgPlxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2NvbnRlbnQgbXVsdGlmaWx0ZXJfX2NvbnRlbnRfZHJvcGRvd25cIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBAY2xpY2sucHJldmVudD1cInRvZ2dsZVwiXG4gICAgPlxuICAgICAgPHNsb3QgbmFtZT1cImJ0blwiIC8+XG4gICAgPC9idXR0b24+XG5cbiAgICA8c2xvdCAvPlxuXG4gICAgPGRpdlxuICAgICAgcmVmPVwibWVudVwiXG4gICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIlxuICAgICAgOmNsYXNzPVwieyBzaG93OiB2aXNpYmxlIH1cIlxuICAgID5cbiAgICAgIDxzbG90IG5hbWU9XCJib2R5XCIgLz5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gICAgPHNpbXBsZWJhciBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIiA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiIGRhdGEtc2ltcGxlYmFyLWF1dG8taGlkZT1cImZhbHNlXCI+LS0+XG4gICAgPCEtLSAgICAgIDxzbG90IG5hbWU9XCJib2R5XCI+PC9zbG90Pi0tPlxuICAgIDwhLS0gICAgPC9zaW1wbGViYXI+LS0+XG4gIDwvZmllbGRzZXQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFNpbXBsZUJhciBmcm9tICdzaW1wbGViYXInO1xuLy8gaW1wb3J0IHNpbXBsZWJhciBmcm9tICdzaW1wbGViYXItdnVlJztcbi8vIGltcG9ydCAnc2ltcGxlYmFyL2Rpc3Qvc2ltcGxlYmFyLm1pbi5jc3MnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdNdWx0aWZpbHRlckRyb3Bkb3duJyxcbiAgLy8gY29tcG9uZW50czoge1xuICAvLyAgIHNpbXBsZWJhclxuICAvLyB9LFxuICBwcm9wczoge1xuICAgIHNjcm9sbGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgfTtcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICAvLyAkKHRoaXMuJGVsKS5vbignaGlkZGVuLmJzLmRyb3Bkb3duJywgKCkgPT4ge1xuICAgIC8vICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgLy8gfSk7XG4gICAgLy8gJCh0aGlzLiRlbCkub24oJ3Nob3duLmJzLmRyb3Bkb3duJywgKCkgPT4ge1xuICAgIC8vICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAvLyB9KTtcblxuICAgIGlmICh0aGlzLnNjcm9sbGVkKSB7XG4gICAgICBuZXcgU2ltcGxlQmFyKHRoaXMuJHJlZnMubWVudSwgeyBhdXRvSGlkZTogZmFsc2UgfSk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb3BlbigpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgdG9nZ2xlKCkge1xuICAgICAgdGhpcy52aXNpYmxlID0gIXRoaXMudmlzaWJsZTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Ecm9wZG93bi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRHJvcGRvd24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Ecm9wZG93bi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Zjg2YzI0ZTImXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRHJvcGRvd24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9Ecm9wZG93bi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},172:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js\nvar classCallCheck = __webpack_require__(7);\nvar classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js\nvar createClass = __webpack_require__(8);\nvar createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js\nvar defineProperty = __webpack_require__(2);\nvar defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm.js\nvar vue_runtime_esm = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./src/js/store/index.js\nvar store = __webpack_require__(3);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/Brands.vue?vue&type=template&id=3e901422&\nvar Brandsvue_type_template_id_3e901422_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"catalog"},[_c(\'div\',{staticClass:"catalog__container"},[(_vm.filtredItems.length === 0)?_c(\'div\',[_vm._v("\\n      Не найдено\\n    ")]):_c(\'keep-alive\',[(_vm.view === \'cards\')?_c(\'BrandsCardList\',{key:"cards",attrs:{"brands":_vm.filtredItems}}):_c(\'BrandsNameList\',{key:"list",attrs:{"brands":_vm.filtredItems}})],1)],1)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/brands/Brands.vue?vue&type=template&id=3e901422&\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsNameList.vue?vue&type=template&id=6af71e82&\nvar BrandsNameListvue_type_template_id_6af71e82_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{ref:"macy",staticClass:"brand-name-list",attrs:{"role":"tabpanel"}},_vm._l((_vm.chars),function(item,key){return _c(\'div\',{key:key,staticClass:"brand-name-list__col"},[_c(\'div\',{staticClass:"brand-name-list__content"},[_c(\'div\',{staticClass:"brand-name-list__title"},[_vm._v("\\n        "+_vm._s(key)+"\\n      ")]),_vm._v(" "),_vm._l((item),function(brand){return _c(\'div\',{key:brand.id,staticClass:"brand-name-list__item"},[_c(\'a\',{attrs:{"href":brand.url}},[_vm._v(_vm._s(brand.name))])])})],2)])}),0)}\nvar BrandsNameListvue_type_template_id_6af71e82_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsNameList.vue?vue&type=template&id=6af71e82&\n\n// EXTERNAL MODULE: ./node_modules/macy/dist/macy.js\nvar macy = __webpack_require__(160);\nvar macy_default = /*#__PURE__*/__webpack_require__.n(macy);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsNameList.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var BrandsNameListvue_type_script_lang_js_ = ({\n  name: \'BrandsNameList\',\n  props: {\n    brands: {\n      type: Array,\n      required: true\n    }\n  },\n  computed: {\n    chars: function chars() {\n      var f = {};\n      this.brands.forEach(function (item) {\n        var char = item.name[0];\n\n        if (!f[char]) {\n          f[char] = [];\n        }\n\n        f[char].push(item);\n      });\n      return f;\n    }\n  },\n  watch: {\n    chars: function chars(newValue, oldValue) {\n      var _this = this;\n\n      this.$nextTick(function () {\n        _this.macy.reInit();\n      });\n    }\n  },\n  activated: function activated() {\n    var _this2 = this;\n\n    this.$nextTick(function () {\n      _this2.macy.recalculate();\n    });\n  },\n  mounted: function mounted() {\n    this.macy = macy_default()({\n      container: this.$refs.macy,\n      trueOrder: false,\n      useOwnImageLoader: true,\n      // margin: 24,\n      mobileFirst: true,\n      columns: 2,\n      breakAt: {\n        1240: 6,\n        768: 4,\n        576: 3\n      }\n    });\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsNameList.vue?vue&type=script&lang=js&\n /* harmony default export */ var brands_BrandsNameListvue_type_script_lang_js_ = (BrandsNameListvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsNameList.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  brands_BrandsNameListvue_type_script_lang_js_,\n  BrandsNameListvue_type_template_id_6af71e82_render,\n  BrandsNameListvue_type_template_id_6af71e82_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var BrandsNameList = (component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsCardList.vue?vue&type=template&id=39fd05cc&\nvar BrandsCardListvue_type_template_id_39fd05cc_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"card-list",attrs:{"role":"tabpanel"}},_vm._l((_vm.brands),function(brand){return _c(\'BrandsCardListItem\',{key:brand.id,attrs:{"name":brand.name,"url":brand.url,"img":brand.img,"description":brand.desc,"quantity":brand.count,"link-title":brand.linkTitle}})}),1)}\nvar BrandsCardListvue_type_template_id_39fd05cc_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsCardList.vue?vue&type=template&id=39fd05cc&\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsCardListItem.vue?vue&type=template&id=6f0fb852&\nvar BrandsCardListItemvue_type_template_id_6f0fb852_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"vendor-card"},[_c(\'div\',{staticClass:"vendor-card__wrapper"},[_c(\'a\',{staticClass:"vendor-card__img stretched-link",attrs:{"href":_vm.url,"title":_vm.linkTitle}},[_c(\'img\',{directives:[{name:"lazy",rawName:"v-lazy",value:(_vm.img),expression:"img"}],attrs:{"alt":_vm.name}})]),_vm._v(" "),_c(\'div\',{staticClass:"vendor-card__body"},[_c(\'h2\',{staticClass:"vendor-card__title"},[_vm._v("\\n        "+_vm._s(_vm.name)+"\\n      ")]),_vm._v(" "),_c(\'div\',{staticClass:"vendor-card__description"},[_vm._v("\\n        "+_vm._s(_vm.description)+"\\n      ")])]),_vm._v(" "),_c(\'div\',{staticClass:"vendor-card__footer"},[_c(\'div\',{staticClass:"vendor-card__row"},[(_vm.quantity > 0)?_c(\'div\',{staticClass:"vendor-card__stock-title"},[_vm._v("\\n          "+_vm._s(_vm.quantity)+" "+_vm._s(_vm.quantityText(_vm.quantity))+"\\n        ")]):_c(\'div\',{staticClass:"vendor-card__stock-value"},[_vm._v("\\n          Нет товаров в наличии\\n        ")])])])])])}\nvar BrandsCardListItemvue_type_template_id_6f0fb852_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsCardListItem.vue?vue&type=template&id=6f0fb852&\n\n// EXTERNAL MODULE: ./src/js/utils/index.js\nvar utils = __webpack_require__(20);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsCardListItem.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var BrandsCardListItemvue_type_script_lang_js_ = ({\n  name: \'BrandsItem\',\n  props: {\n    name: {\n      type: String,\n      required: true\n    },\n    url: {\n      type: String,\n      required: true\n    },\n    img: {\n      type: String,\n      default: \'/upload/resizer/notfound.svg?Element+not+found\'\n    },\n    description: {\n      type: String,\n      default: \'\'\n    },\n    quantity: {\n      type: Number,\n      default: 0\n    },\n    linkTitle: {\n      type: String,\n      default: \'\'\n    }\n  },\n  methods: {\n    quantityText: function quantityText(quantity) {\n      return utils["b" /* default */].declOfNum(quantity, [\'товар\', \'товара\', \'товаров\']);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsCardListItem.vue?vue&type=script&lang=js&\n /* harmony default export */ var brands_BrandsCardListItemvue_type_script_lang_js_ = (BrandsCardListItemvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/brands/BrandsCardListItem.vue\n\n\n\n\n\n/* normalize component */\n\nvar BrandsCardListItem_component = Object(componentNormalizer["a" /* default */])(\n  brands_BrandsCardListItemvue_type_script_lang_js_,\n  BrandsCardListItemvue_type_template_id_6f0fb852_render,\n  BrandsCardListItemvue_type_template_id_6f0fb852_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var BrandsCardListItem = (BrandsCardListItem_component.exports);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsCardList.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var BrandsCardListvue_type_script_lang_js_ = ({\n  name: \'BrandsCardList\',\n  components: {\n    BrandsCardListItem: BrandsCardListItem\n  },\n  props: {\n    brands: {\n      type: Array,\n      required: true\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsCardList.vue?vue&type=script&lang=js&\n /* harmony default export */ var brands_BrandsCardListvue_type_script_lang_js_ = (BrandsCardListvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/brands/BrandsCardList.vue\n\n\n\n\n\n/* normalize component */\n\nvar BrandsCardList_component = Object(componentNormalizer["a" /* default */])(\n  brands_BrandsCardListvue_type_script_lang_js_,\n  BrandsCardListvue_type_template_id_39fd05cc_render,\n  BrandsCardListvue_type_template_id_39fd05cc_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var BrandsCardList = (BrandsCardList_component.exports);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/Brands.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ var Brandsvue_type_script_lang_js_ = ({\n  name: \'Brands\',\n  components: {\n    BrandsCardList: BrandsCardList,\n    BrandsNameList: BrandsNameList\n  },\n  props: {\n    brands: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    filterValue: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    searchValue: {\n      type: String,\n      default: \'\'\n    },\n    view: {\n      type: String,\n      default: \'cards\'\n    }\n  },\n  data: function data() {\n    return {// searchValue: \'\',\n      // selectedTab: \'cards\',\n      // filterValue: [],\n    };\n  },\n  computed: {\n    searchItems: function searchItems() {\n      var _this = this;\n\n      if (this.searchValue === \'\') {\n        return this.brands;\n      }\n\n      return this.brands.filter(function (brand) {\n        return brand.name.toLowerCase().indexOf(_this.searchValue) !== -1;\n      });\n    },\n    filtredItems: function filtredItems() {\n      var _this2 = this;\n\n      if (this.filterValue.length === 0) {\n        return this.searchItems;\n      } // return this.searchItems.filter(brand => this.filterValue.every(id => brand.sections.includes(id)));\n\n\n      return this.searchItems.filter(function (brand) {\n        return _this2.filterValue.every(function (ids) {\n          return ids.length === 0 || ids.some(function (id) {\n            return brand.sections.includes(id);\n          });\n        });\n      });\n    }\n  } // created() {\n  //   this.$root.$on(\'update:filters\', (items) => {\n  //     this.filterValue = items;\n  //   });\n  //\n  //   this.$root.$on(\'update:tab\', (tab) => {\n  //     this.selectedTab = tab;\n  //   });\n  //\n  //   this.$root.$on(\'update:search\', (text) => {\n  //     this.searchValue = text;\n  //   });\n  // },\n\n});\n// CONCATENATED MODULE: ./src/js/components/brands/Brands.vue?vue&type=script&lang=js&\n /* harmony default export */ var brands_Brandsvue_type_script_lang_js_ = (Brandsvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/brands/Brands.vue\n\n\n\n\n\n/* normalize component */\n\nvar Brands_component = Object(componentNormalizer["a" /* default */])(\n  brands_Brandsvue_type_script_lang_js_,\n  Brandsvue_type_template_id_3e901422_render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Brands = (Brands_component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsFilter.vue?vue&type=template&id=33a3a032&\nvar BrandsFiltervue_type_template_id_33a3a032_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"catalog-control"},[_c(\'div\',{staticClass:"catalog-control__mobile"},_vm._l((_vm.newFilter),function(filter){return _c(\'CatalogFilterMobileHorizontal\',{key:filter.name,attrs:{"filter":filter},on:{"change":_vm.onChange}})}),1),_vm._v(" "),_c(\'div\',{staticClass:"catalog-control__menu catalog-control__menu_white"},[_c(\'div\',{staticClass:"container"},[_c(\'div\',{staticClass:"view"},[_c(\'div\',{staticClass:"view__category"},[_vm._l((_vm.newFilter),function(filter){return [(filter.type === \'checkbox\')?_c(\'FilterCheckbox\',{key:filter.name,attrs:{"filter":filter},on:{"change":_vm.onChange}}):(filter.type === \'radio\')?_c(\'FilterSelect\',{key:filter.name,attrs:{"filter":filter}}):(filter.type === \'range\')?_c(\'FilterPrice\',{key:filter.name,attrs:{"filter":filter}}):_vm._e()]})],2),_vm._v(" "),_c(\'div\',{staticClass:"view__tab"},[_c(\'div\',{staticClass:"multifilter"},[_c(\'div\',{staticClass:"multifilter__content"},[_c(\'div\',{staticClass:"multifilter__label"},[_vm._v("\\n                Вид:\\n              ")]),_vm._v(" "),_c(\'div\',{staticClass:"multifilter__tablist",attrs:{"role":"tablist"}},[_c(\'button\',{staticClass:"multifilter__tab",class:{ active: _vm.view === \'cards\' },attrs:{"role":"tab"},on:{"click":function($event){$event.preventDefault();return _vm.showTab(\'cards\')}}},[_c(\'i\',{staticClass:"i i-cards"})]),_vm._v(" "),_c(\'button\',{staticClass:"multifilter__tab",class:{ active: _vm.view === \'list\' },attrs:{"role":"tab"},on:{"click":function($event){$event.preventDefault();return _vm.showTab(\'list\')}}},[_c(\'i\',{staticClass:"i i-list"})])])])])])])])])])}\nvar BrandsFiltervue_type_template_id_33a3a032_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsFilter.vue?vue&type=template&id=33a3a032&\n\n// EXTERNAL MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue + 4 modules\nvar CatalogFilterMobileHorizontal = __webpack_require__(44);\n\n// EXTERNAL MODULE: ./src/js/components/catalog/FilterCheckbox.vue + 4 modules\nvar FilterCheckbox = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./src/js/components/catalog/FilterSelect.vue + 4 modules\nvar FilterSelect = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./src/js/components/catalog/FilterPrice.vue + 4 modules\nvar FilterPrice = __webpack_require__(24);\n\n// EXTERNAL MODULE: ./src/js/components/Multifilter.js\nvar Multifilter = __webpack_require__(15);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/brands/BrandsFilter.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ var BrandsFiltervue_type_script_lang_js_ = ({\n  name: \'BrandsFilter\',\n  components: {\n    CatalogFilterMobileHorizontal: CatalogFilterMobileHorizontal["a" /* default */],\n    FilterCheckbox: FilterCheckbox["a" /* default */],\n    FilterSelect: FilterSelect["a" /* default */],\n    FilterPrice: FilterPrice["a" /* default */]\n  },\n  props: {\n    view: {\n      type: String,\n      default: \'cards\'\n    }\n  },\n  data: function data() {\n    return {\n      filters: [] // view: \'cards\',\n\n    };\n  },\n  computed: {\n    // ...mapState(\'filters\', {\n    //   filters: state => state.filters,\n    // }),\n    newFilter: function newFilter() {\n      return this.filters.map(function (filter, i, array) {\n        if (filter.parent) {\n          filter.parent = array.find(function (item) {\n            return item.name === filter.parent;\n          });\n        }\n\n        return filter;\n      });\n    }\n  },\n  created: function created() {\n    this.filters = [].map.call(document.querySelectorAll(\'fieldset.multifilter\'), function (filter) {\n      if (filter.querySelector(\'.multifilter-checkbox\')) {\n        return Multifilter["a" /* CheckboxFilter */].parseSettings(filter);\n      }\n\n      if (filter.querySelector(\'.multifilter-radio\')) {\n        return Multifilter["d" /* SelectFilter */].parseSettings(filter);\n      }\n\n      if (filter.querySelector(\'.multifilter-price\')) {\n        return Multifilter["c" /* PriceFilter */].parseSettings(filter);\n      }\n\n      return null;\n    }).filter(function (item) {\n      return item;\n    });\n  },\n  methods: {\n    onChange: function onChange() {\n      var _this = this;\n\n      this.$nextTick(function () {\n        // [[1040, 1060], [1041, 1042, 1061]]\n        var data = _this.filters.map(function (filter) {\n          return filter.data.filter(function (item) {\n            return item.checked;\n          }).map(function (item) {\n            return parseInt(item.value, 10);\n          });\n        });\n\n        _this.$emit(\'update:filters\', data);\n      });\n    },\n    showTab: function showTab(e) {\n      this.$emit(\'update:view\', e);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/brands/BrandsFilter.vue?vue&type=script&lang=js&\n /* harmony default export */ var brands_BrandsFiltervue_type_script_lang_js_ = (BrandsFiltervue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/brands/BrandsFilter.vue\n\n\n\n\n\n/* normalize component */\n\nvar BrandsFilter_component = Object(componentNormalizer["a" /* default */])(\n  brands_BrandsFiltervue_type_script_lang_js_,\n  BrandsFiltervue_type_template_id_33a3a032_render,\n  BrandsFiltervue_type_template_id_33a3a032_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var BrandsFilter = (BrandsFilter_component.exports);\n// CONCATENATED MODULE: ./src/js/page/vendors.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return vendors_Vendors; });\n\n\n\n\n\n\n\n\nvar vendors_Vendors =\n/*#__PURE__*/\nfunction () {\n  function Vendors() {\n    var _this = this;\n\n    classCallCheck_default()(this, Vendors);\n\n    defineProperty_default()(this, "onSearch", function (event) {\n      event.preventDefault(); // this.brandsVM.$emit(\'update:search\', this.searchField.value.trim().toLowerCase());\n\n      _this.data.searchValue = _this.searchField.value.trim().toLowerCase();\n    });\n\n    this.searchContainer = document.querySelector(\'.page-header .search-fild\');\n    this.searchField = document.querySelector(\'.page-header .search-fild__input\');\n    this.init();\n  }\n\n  createClass_default()(Vendors, [{\n    key: "init",\n    value: function init() {\n      var _this2 = this;\n\n      this.data = vue_runtime_esm["a" /* default */].observable({\n        view: \'cards\',\n        filterValue: [],\n        searchValue: this.searchField.value.trim().toLowerCase()\n      });\n      this.brandsVM = new vue_runtime_esm["a" /* default */]({\n        store: store["a" /* default */],\n        el: \'.catalog\',\n        render: function render(h) {\n          return h(Brands, {\n            props: {\n              brands: window.brands,\n              view: _this2.data.view,\n              searchValue: _this2.data.searchValue,\n              filterValue: _this2.data.filterValue\n            }\n          });\n        }\n      });\n      this.filterVM = new vue_runtime_esm["a" /* default */]({\n        store: store["a" /* default */],\n        el: \'.catalog-control\',\n        render: function render(h) {\n          return h(BrandsFilter, {\n            props: {\n              view: _this2.data.view\n            },\n            on: {\n              // \'update:filters\': e => this.brandsVM.$emit(\'update:filters\', e),\n              // \'update:tab\': e => this.brandsVM.$emit(\'update:tab\', e),\n              \'update:filters\': function updateFilters(e) {\n                _this2.data.filterValue = e;\n              },\n              \'update:view\': function updateView(e) {\n                _this2.data.view = e;\n              }\n            }\n          });\n        }\n      });\n      this.searchContainer.addEventListener(\'submit\', this.onSearch);\n      this.searchField.addEventListener(\'input\', this.onSearch);\n      this.searchField.addEventListener(\'change\', this.onSearch);\n    }\n  }]);\n\n  return Vendors;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzLnZ1ZT82ODJiIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2JyYW5kcy9CcmFuZHNOYW1lTGlzdC52dWU/YzIxNSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvYnJhbmRzL0JyYW5kc05hbWVMaXN0LnZ1ZT8zYjU3Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2JyYW5kcy9CcmFuZHNOYW1lTGlzdC52dWU/ZDZhNiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzTmFtZUxpc3QudnVlP2YyMWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvYnJhbmRzL0JyYW5kc0NhcmRMaXN0LnZ1ZT9lNDIzIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2JyYW5kcy9CcmFuZHNDYXJkTGlzdEl0ZW0udnVlPzI2MjAiLCJ3ZWJwYWNrOi8vL3NyYy9qcy9jb21wb25lbnRzL2JyYW5kcy9CcmFuZHNDYXJkTGlzdEl0ZW0udnVlPzMyNmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvYnJhbmRzL0JyYW5kc0NhcmRMaXN0SXRlbS52dWU/ZjQxYSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzQ2FyZExpc3RJdGVtLnZ1ZT82YTNlIiwid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzQ2FyZExpc3QudnVlPzVlYTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvYnJhbmRzL0JyYW5kc0NhcmRMaXN0LnZ1ZT9kNzgxIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2JyYW5kcy9CcmFuZHNDYXJkTGlzdC52dWU/NjFiZCIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvYnJhbmRzL0JyYW5kcy52dWU/MjJiMCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzLnZ1ZT85ZTllIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2JyYW5kcy9CcmFuZHMudnVlP2MxZDQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvYnJhbmRzL0JyYW5kc0ZpbHRlci52dWU/Zjg5ZSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvYnJhbmRzL0JyYW5kc0ZpbHRlci52dWU/YzcyMiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzRmlsdGVyLnZ1ZT80OGU3Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2JyYW5kcy9CcmFuZHNGaWx0ZXIudnVlP2ViYWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BhZ2UvdmVuZG9ycy5qcz9hOTQ5Il0sIm5hbWVzIjpbIlZlbmRvcnMiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiZGF0YSIsInNlYXJjaFZhbHVlIiwic2VhcmNoRmllbGQiLCJ2YWx1ZSIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsInNlYXJjaENvbnRhaW5lciIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImluaXQiLCJWdWUiLCJvYnNlcnZhYmxlIiwidmlldyIsImZpbHRlclZhbHVlIiwiYnJhbmRzVk0iLCJzdG9yZSIsImVsIiwicmVuZGVyIiwiaCIsIkJyYW5kcyIsInByb3BzIiwiYnJhbmRzIiwid2luZG93IiwiZmlsdGVyVk0iLCJCcmFuZHNGaWx0ZXIiLCJvbiIsImUiLCJhZGRFdmVudExpc3RlbmVyIiwib25TZWFyY2giXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsSUFBSSwwQ0FBTSxnQkFBZ0IsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQixzQkFBc0IsWUFBWSxpQ0FBaUMsOElBQThJLG1CQUFtQiwyQkFBMkIsdUJBQXVCLGtCQUFrQiwyQkFBMkI7QUFDN2E7Ozs7OztBQ0RBLElBQUksa0RBQU0sZ0JBQWdCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsZ0RBQWdELG1CQUFtQix1Q0FBdUMsaUJBQWlCLDJDQUEyQyxZQUFZLHVDQUF1QyxZQUFZLHFDQUFxQywwRkFBMEYsaUJBQWlCLGlEQUFpRCxVQUFVLE9BQU8sa0JBQWtCLGlDQUFpQyxRQUFRO0FBQzVsQixJQUFJLDJEQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMkJuQjtBQUdBO0FBQ0Esd0JBREE7QUFFQTtBQUNBO0FBQ0EsaUJBREE7QUFFQTtBQUZBO0FBREEsR0FGQTtBQVFBO0FBQ0EsU0FEQSxtQkFDQTtBQUNBO0FBRUE7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQVBBO0FBVUE7QUFDQTtBQWZBLEdBUkE7QUF5QkE7QUFDQSxTQURBLGlCQUNBLFFBREEsRUFDQSxRQURBLEVBQ0E7QUFBQTs7QUFDQTtBQUNBO0FBQ0EsT0FGQTtBQUdBO0FBTEEsR0F6QkE7QUFnQ0EsV0FoQ0EsdUJBZ0NBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBLEtBRkE7QUFHQSxHQXBDQTtBQXFDQSxTQXJDQSxxQkFxQ0E7QUFDQTtBQUNBLGdDQURBO0FBRUEsc0JBRkE7QUFHQSw2QkFIQTtBQUlBO0FBQ0EsdUJBTEE7QUFNQSxnQkFOQTtBQU9BO0FBQ0EsZUFEQTtBQUVBLGNBRkE7QUFHQTtBQUhBO0FBUEE7QUFhQTtBQW5EQSxHOztBQy9Cb00sQ0FBZ0Isd0hBQUcsRUFBQyxDOzs7OztBQ0EzSDtBQUMzQjtBQUNMOzs7QUFHN0Q7QUFDZ0c7QUFDaEcsZ0JBQWdCLDhDQUFVO0FBQzFCLEVBQUUsNkNBQU07QUFDUixFQUFFLGtEQUFNO0FBQ1IsRUFBRSwyREFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSxvRTs7QUNsQmYsSUFBSSxrREFBTSxnQkFBZ0IsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQiwrQkFBK0IsbUJBQW1CLHFDQUFxQyxnQ0FBZ0Msb0JBQW9CLGdJQUFnSSxFQUFFO0FBQ3ZYLElBQUksMkRBQWU7Ozs7OztBQ0RuQixJQUFJLHNEQUFNLGdCQUFnQixhQUFhLDBCQUEwQix3QkFBd0IsaUJBQWlCLDBCQUEwQixZQUFZLG1DQUFtQyxVQUFVLHFEQUFxRCxzQ0FBc0MsWUFBWSxhQUFhLDhEQUE4RCxTQUFTLGdCQUFnQiwwQkFBMEIsZ0NBQWdDLFdBQVcsaUNBQWlDLDJFQUEyRSx1Q0FBdUMsb0ZBQW9GLGtDQUFrQyxZQUFZLCtCQUErQiwrQkFBK0IsdUNBQXVDLGtIQUFrSCx1Q0FBdUM7QUFDaCtCLElBQUksK0RBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM0Qm5CO0FBR0E7QUFDQSxvQkFEQTtBQUVBO0FBQ0E7QUFDQSxrQkFEQTtBQUVBO0FBRkEsS0FEQTtBQUtBO0FBQ0Esa0JBREE7QUFFQTtBQUZBLEtBTEE7QUFTQTtBQUNBLGtCQURBO0FBRUE7QUFGQSxLQVRBO0FBYUE7QUFDQSxrQkFEQTtBQUVBO0FBRkEsS0FiQTtBQWlCQTtBQUNBLGtCQURBO0FBRUE7QUFGQSxLQWpCQTtBQXFCQTtBQUNBLGtCQURBO0FBRUE7QUFGQTtBQXJCQSxHQUZBO0FBNEJBO0FBQ0EsZ0JBREEsd0JBQ0EsUUFEQSxFQUNBO0FBQ0E7QUFDQTtBQUhBO0FBNUJBLEc7O0FDaEN3TSxDQUFnQixnSUFBRyxFQUFDLEM7O0FDQTNIO0FBQzNCO0FBQ0w7OztBQUdqRTtBQUNnRztBQUNoRyxJQUFJLDRCQUFTLEdBQUcsOENBQVU7QUFDMUIsRUFBRSxpREFBTTtBQUNSLEVBQUUsc0RBQU07QUFDUixFQUFFLCtEQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLG1GQUFTLFE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQ3hCO0FBR0E7QUFDQSx3QkFEQTtBQUVBO0FBQUE7QUFBQSxHQUZBO0FBR0E7QUFDQTtBQUNBLGlCQURBO0FBRUE7QUFGQTtBQURBO0FBSEEsRzs7QUN0Qm9NLENBQWdCLHdIQUFHLEVBQUMsQzs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBRzdEO0FBQ2dHO0FBQ2hHLElBQUksd0JBQVMsR0FBRyw4Q0FBVTtBQUMxQixFQUFFLDZDQUFNO0FBQ1IsRUFBRSxrREFBTTtBQUNSLEVBQUUsMkRBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsMkVBQVMsUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDS3hCO0FBQ0E7QUFHQTtBQUNBLGdCQURBO0FBRUE7QUFDQSxrQ0FEQTtBQUVBO0FBRkEsR0FGQTtBQU1BO0FBQ0E7QUFDQSxpQkFEQTtBQUVBO0FBQUE7QUFBQTtBQUZBLEtBREE7QUFLQTtBQUNBLGlCQURBO0FBRUE7QUFBQTtBQUFBO0FBRkEsS0FMQTtBQVNBO0FBQ0Esa0JBREE7QUFFQTtBQUZBLEtBVEE7QUFhQTtBQUNBLGtCQURBO0FBRUE7QUFGQTtBQWJBLEdBTkE7QUF3QkEsTUF4QkEsa0JBd0JBO0FBQ0EsWUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBLEdBOUJBO0FBK0JBO0FBQ0EsZUFEQSx5QkFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFDQSxLQVBBO0FBUUEsZ0JBUkEsMEJBUUE7QUFBQTs7QUFDQTtBQUNBO0FBQ0EsT0FIQSxDQUlBOzs7QUFDQTtBQUFBO0FBQUEsaUJBQ0E7QUFBQTtBQUFBLFlBREE7QUFBQTtBQUFBO0FBR0E7QUFoQkEsR0EvQkEsQ0FpREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBN0RBLEc7O0FDM0I0TCxDQUFnQix3R0FBRyxFQUFDLEM7O0FDQTNIO0FBQzNCO0FBQ0w7OztBQUdyRDtBQUNnRztBQUNoRyxJQUFJLGdCQUFTLEdBQUcsOENBQVU7QUFDMUIsRUFBRSxxQ0FBTTtBQUNSLEVBQUUsMENBQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsMkRBQVMsUTs7QUNsQnhCLElBQUksZ0RBQU0sZ0JBQWdCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsOEJBQThCLFlBQVksc0NBQXNDLHlDQUF5QywyQ0FBMkMsdUJBQXVCLGdCQUFnQixLQUFLLHVCQUF1QixFQUFFLDJCQUEyQixnRUFBZ0UsWUFBWSx3QkFBd0IsWUFBWSxtQkFBbUIsWUFBWSw2QkFBNkIsMENBQTBDLDBEQUEwRCx1QkFBdUIsZ0JBQWdCLEtBQUssdUJBQXVCLCtDQUErQyx1QkFBdUIsaUJBQWlCLDhDQUE4Qyx1QkFBdUIsaUJBQWlCLFlBQVksNEJBQTRCLHdCQUF3QixZQUFZLDBCQUEwQixZQUFZLG1DQUFtQyxZQUFZLGlDQUFpQywyRUFBMkUsMENBQTBDLGtCQUFrQixlQUFlLHNDQUFzQywrQkFBK0IsUUFBUSxhQUFhLEtBQUsseUJBQXlCLHdCQUF3Qiw4QkFBOEIsVUFBVSx3QkFBd0IsNkJBQTZCLHNDQUFzQyw4QkFBOEIsUUFBUSxhQUFhLEtBQUsseUJBQXlCLHdCQUF3Qiw2QkFBNkIsVUFBVSx1QkFBdUI7QUFDaG9ELElBQUkseURBQWU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2tFbkI7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVFBO0FBQ0Esc0JBREE7QUFFQTtBQUNBLG1GQURBO0FBRUEscURBRkE7QUFHQSxpREFIQTtBQUlBO0FBSkEsR0FGQTtBQVFBO0FBQ0E7QUFDQSxrQkFEQTtBQUVBO0FBRkE7QUFEQSxHQVJBO0FBY0EsTUFkQSxrQkFjQTtBQUNBO0FBQ0EsaUJBREEsQ0FFQTs7QUFGQTtBQUlBLEdBbkJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFKQSx1QkFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFFQTtBQUNBLE9BTkE7QUFPQTtBQVpBLEdBcEJBO0FBa0NBLFNBbENBLHFCQWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQWRBLEVBY0EsTUFkQSxDQWNBO0FBQUE7QUFBQSxLQWRBO0FBZUEsR0FsREE7QUFtREE7QUFDQSxZQURBLHNCQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBLHFDQUNBO0FBQUEsNkJBQ0EsTUFEQSxDQUNBO0FBQUE7QUFBQSxXQURBLEVBRUEsR0FGQSxDQUVBO0FBQUE7QUFBQSxXQUZBO0FBQUEsU0FEQTs7QUFNQTtBQUNBLE9BVEE7QUFVQSxLQVpBO0FBYUEsV0FiQSxtQkFhQSxDQWJBLEVBYUE7QUFDQTtBQUNBO0FBZkE7QUFuREEsRzs7QUNoRmtNLENBQWdCLG9IQUFHLEVBQUMsQzs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBRzNEO0FBQ2dHO0FBQ2hHLElBQUksc0JBQVMsR0FBRyw4Q0FBVTtBQUMxQixFQUFFLDJDQUFNO0FBQ1IsRUFBRSxnREFBTTtBQUNSLEVBQUUseURBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsdUVBQVMsUTs7Ozs7O0FDbEJ4QjtBQUVBO0FBRUE7QUFDQTs7SUFHcUJBLGU7OztBQUNuQixxQkFBYztBQUFBOztBQUFBOztBQUFBLCtDQXNESCxVQUFDQyxLQUFELEVBQVc7QUFDcEJBLFdBQUssQ0FBQ0MsY0FBTixHQURvQixDQUVwQjs7QUFDQSxXQUFJLENBQUNDLElBQUwsQ0FBVUMsV0FBVixHQUF3QixLQUFJLENBQUNDLFdBQUwsQ0FBaUJDLEtBQWpCLENBQXVCQyxJQUF2QixHQUE4QkMsV0FBOUIsRUFBeEI7QUFDRCxLQTFEYTs7QUFDWixTQUFLQyxlQUFMLEdBQXVCQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsMkJBQXZCLENBQXZCO0FBQ0EsU0FBS04sV0FBTCxHQUFtQkssUUFBUSxDQUFDQyxhQUFULENBQXVCLGtDQUF2QixDQUFuQjtBQUVBLFNBQUtDLElBQUw7QUFDRDs7OzsyQkFFTTtBQUFBOztBQUNMLFdBQUtULElBQUwsR0FBWVUsa0NBQUcsQ0FBQ0MsVUFBSixDQUFlO0FBQ3pCQyxZQUFJLEVBQUUsT0FEbUI7QUFFekJDLG1CQUFXLEVBQUUsRUFGWTtBQUd6QlosbUJBQVcsRUFBRSxLQUFLQyxXQUFMLENBQWlCQyxLQUFqQixDQUF1QkMsSUFBdkIsR0FBOEJDLFdBQTlCO0FBSFksT0FBZixDQUFaO0FBTUEsV0FBS1MsUUFBTCxHQUFnQixJQUFJSixrQ0FBSixDQUFRO0FBQ3RCSyxhQUFLLEVBQUxBLHdCQURzQjtBQUV0QkMsVUFBRSxFQUFFLFVBRmtCO0FBR3RCQyxjQUFNLEVBQUUsZ0JBQUFDLENBQUM7QUFBQSxpQkFBSUEsQ0FBQyxDQUFDQyxNQUFELEVBQVM7QUFDckJDLGlCQUFLLEVBQUU7QUFDTEMsb0JBQU0sRUFBRUMsTUFBTSxDQUFDRCxNQURWO0FBRUxULGtCQUFJLEVBQUUsTUFBSSxDQUFDWixJQUFMLENBQVVZLElBRlg7QUFHTFgseUJBQVcsRUFBRSxNQUFJLENBQUNELElBQUwsQ0FBVUMsV0FIbEI7QUFJTFkseUJBQVcsRUFBRSxNQUFJLENBQUNiLElBQUwsQ0FBVWE7QUFKbEI7QUFEYyxXQUFULENBQUw7QUFBQTtBQUhhLE9BQVIsQ0FBaEI7QUFjQSxXQUFLVSxRQUFMLEdBQWdCLElBQUliLGtDQUFKLENBQVE7QUFDdEJLLGFBQUssRUFBTEEsd0JBRHNCO0FBRXRCQyxVQUFFLEVBQUUsa0JBRmtCO0FBR3RCQyxjQUFNLEVBQUUsZ0JBQUFDLENBQUM7QUFBQSxpQkFBSUEsQ0FBQyxDQUFDTSxZQUFELEVBQWU7QUFDM0JKLGlCQUFLLEVBQUU7QUFDTFIsa0JBQUksRUFBRSxNQUFJLENBQUNaLElBQUwsQ0FBVVk7QUFEWCxhQURvQjtBQUkzQmEsY0FBRSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLGdDQUFrQix1QkFBQ0MsQ0FBRCxFQUFPO0FBQ3ZCLHNCQUFJLENBQUMxQixJQUFMLENBQVVhLFdBQVYsR0FBd0JhLENBQXhCO0FBQ0QsZUFMQztBQU1GLDZCQUFlLG9CQUFDQSxDQUFELEVBQU87QUFDcEIsc0JBQUksQ0FBQzFCLElBQUwsQ0FBVVksSUFBVixHQUFpQmMsQ0FBakI7QUFDRDtBQVJDO0FBSnVCLFdBQWYsQ0FBTDtBQUFBO0FBSGEsT0FBUixDQUFoQjtBQXFCQSxXQUFLcEIsZUFBTCxDQUFxQnFCLGdCQUFyQixDQUFzQyxRQUF0QyxFQUFnRCxLQUFLQyxRQUFyRDtBQUNBLFdBQUsxQixXQUFMLENBQWlCeUIsZ0JBQWpCLENBQWtDLE9BQWxDLEVBQTJDLEtBQUtDLFFBQWhEO0FBQ0EsV0FBSzFCLFdBQUwsQ0FBaUJ5QixnQkFBakIsQ0FBa0MsUUFBbEMsRUFBNEMsS0FBS0MsUUFBakQ7QUFDRCIsImZpbGUiOiIxNzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nXCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nX19jb250YWluZXJcIn0sWyhfdm0uZmlsdHJlZEl0ZW1zLmxlbmd0aCA9PT0gMCk/X2MoJ2RpdicsW192bS5fdihcIlxcbiAgICAgINCd0LUg0L3QsNC50LTQtdC90L5cXG4gICAgXCIpXSk6X2MoJ2tlZXAtYWxpdmUnLFsoX3ZtLnZpZXcgPT09ICdjYXJkcycpP19jKCdCcmFuZHNDYXJkTGlzdCcse2tleTpcImNhcmRzXCIsYXR0cnM6e1wiYnJhbmRzXCI6X3ZtLmZpbHRyZWRJdGVtc319KTpfYygnQnJhbmRzTmFtZUxpc3QnLHtrZXk6XCJsaXN0XCIsYXR0cnM6e1wiYnJhbmRzXCI6X3ZtLmZpbHRyZWRJdGVtc319KV0sMSldLDEpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtyZWY6XCJtYWN5XCIsc3RhdGljQ2xhc3M6XCJicmFuZC1uYW1lLWxpc3RcIixhdHRyczp7XCJyb2xlXCI6XCJ0YWJwYW5lbFwifX0sX3ZtLl9sKChfdm0uY2hhcnMpLGZ1bmN0aW9uKGl0ZW0sa2V5KXtyZXR1cm4gX2MoJ2Rpdicse2tleTprZXksc3RhdGljQ2xhc3M6XCJicmFuZC1uYW1lLWxpc3RfX2NvbFwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiYnJhbmQtbmFtZS1saXN0X19jb250ZW50XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJicmFuZC1uYW1lLWxpc3RfX3RpdGxlXCJ9LFtfdm0uX3YoXCJcXG4gICAgICAgIFwiK192bS5fcyhrZXkpK1wiXFxuICAgICAgXCIpXSksX3ZtLl92KFwiIFwiKSxfdm0uX2woKGl0ZW0pLGZ1bmN0aW9uKGJyYW5kKXtyZXR1cm4gX2MoJ2Rpdicse2tleTpicmFuZC5pZCxzdGF0aWNDbGFzczpcImJyYW5kLW5hbWUtbGlzdF9faXRlbVwifSxbX2MoJ2EnLHthdHRyczp7XCJocmVmXCI6YnJhbmQudXJsfX0sW192bS5fdihfdm0uX3MoYnJhbmQubmFtZSkpXSldKX0pXSwyKV0pfSksMCl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIHJlZj1cIm1hY3lcIlxuICAgIGNsYXNzPVwiYnJhbmQtbmFtZS1saXN0XCJcbiAgICByb2xlPVwidGFicGFuZWxcIlxuICA+XG4gICAgPGRpdlxuICAgICAgdi1mb3I9XCIoaXRlbSwga2V5KSBpbiBjaGFyc1wiXG4gICAgICA6a2V5PVwia2V5XCJcbiAgICAgIGNsYXNzPVwiYnJhbmQtbmFtZS1saXN0X19jb2xcIlxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJicmFuZC1uYW1lLWxpc3RfX2NvbnRlbnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJyYW5kLW5hbWUtbGlzdF9fdGl0bGVcIj5cbiAgICAgICAgICB7eyBrZXkgfX1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICB2LWZvcj1cImJyYW5kIGluIGl0ZW1cIlxuICAgICAgICAgIDprZXk9XCJicmFuZC5pZFwiXG4gICAgICAgICAgY2xhc3M9XCJicmFuZC1uYW1lLWxpc3RfX2l0ZW1cIlxuICAgICAgICA+XG4gICAgICAgICAgPGEgOmhyZWY9XCJicmFuZC51cmxcIj57eyBicmFuZC5uYW1lIH19PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTWFjeSBmcm9tICdtYWN5JztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdCcmFuZHNOYW1lTGlzdCcsXG4gIHByb3BzOiB7XG4gICAgYnJhbmRzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2hhcnMoKSB7XG4gICAgICBjb25zdCBmID0ge307XG5cbiAgICAgIHRoaXMuYnJhbmRzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgY2hhciA9IGl0ZW0ubmFtZVswXTtcbiAgICAgICAgaWYgKCFmW2NoYXJdKSB7XG4gICAgICAgICAgZltjaGFyXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZltjaGFyXS5wdXNoKGl0ZW0pO1xuICAgICAgfSk7XG5cblxuICAgICAgcmV0dXJuIGY7XG4gICAgfSxcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBjaGFycyhuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5tYWN5LnJlSW5pdCgpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgYWN0aXZhdGVkKCkge1xuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgIHRoaXMubWFjeS5yZWNhbGN1bGF0ZSgpO1xuICAgIH0pO1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMubWFjeSA9IE1hY3koe1xuICAgICAgY29udGFpbmVyOiB0aGlzLiRyZWZzLm1hY3ksXG4gICAgICB0cnVlT3JkZXI6IGZhbHNlLFxuICAgICAgdXNlT3duSW1hZ2VMb2FkZXI6IHRydWUsXG4gICAgICAvLyBtYXJnaW46IDI0LFxuICAgICAgbW9iaWxlRmlyc3Q6IHRydWUsXG4gICAgICBjb2x1bW5zOiAyLFxuICAgICAgYnJlYWtBdDoge1xuICAgICAgICAxMjQwOiA2LFxuICAgICAgICA3Njg6IDQsXG4gICAgICAgIDU3NjogMyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0sXG59O1xuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0JyYW5kc05hbWVMaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CcmFuZHNOYW1lTGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0JyYW5kc05hbWVMaXN0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02YWY3MWU4MiZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9CcmFuZHNOYW1lTGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0JyYW5kc05hbWVMaXN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY2FyZC1saXN0XCIsYXR0cnM6e1wicm9sZVwiOlwidGFicGFuZWxcIn19LF92bS5fbCgoX3ZtLmJyYW5kcyksZnVuY3Rpb24oYnJhbmQpe3JldHVybiBfYygnQnJhbmRzQ2FyZExpc3RJdGVtJyx7a2V5OmJyYW5kLmlkLGF0dHJzOntcIm5hbWVcIjpicmFuZC5uYW1lLFwidXJsXCI6YnJhbmQudXJsLFwiaW1nXCI6YnJhbmQuaW1nLFwiZGVzY3JpcHRpb25cIjpicmFuZC5kZXNjLFwicXVhbnRpdHlcIjpicmFuZC5jb3VudCxcImxpbmstdGl0bGVcIjpicmFuZC5saW5rVGl0bGV9fSl9KSwxKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmVuZG9yLWNhcmRcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZlbmRvci1jYXJkX193cmFwcGVyXCJ9LFtfYygnYScse3N0YXRpY0NsYXNzOlwidmVuZG9yLWNhcmRfX2ltZyBzdHJldGNoZWQtbGlua1wiLGF0dHJzOntcImhyZWZcIjpfdm0udXJsLFwidGl0bGVcIjpfdm0ubGlua1RpdGxlfX0sW19jKCdpbWcnLHtkaXJlY3RpdmVzOlt7bmFtZTpcImxhenlcIixyYXdOYW1lOlwidi1sYXp5XCIsdmFsdWU6KF92bS5pbWcpLGV4cHJlc3Npb246XCJpbWdcIn1dLGF0dHJzOntcImFsdFwiOl92bS5uYW1lfX0pXSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2ZW5kb3ItY2FyZF9fYm9keVwifSxbX2MoJ2gyJyx7c3RhdGljQ2xhc3M6XCJ2ZW5kb3ItY2FyZF9fdGl0bGVcIn0sW192bS5fdihcIlxcbiAgICAgICAgXCIrX3ZtLl9zKF92bS5uYW1lKStcIlxcbiAgICAgIFwiKV0pLF92bS5fdihcIiBcIiksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmVuZG9yLWNhcmRfX2Rlc2NyaXB0aW9uXCJ9LFtfdm0uX3YoXCJcXG4gICAgICAgIFwiK192bS5fcyhfdm0uZGVzY3JpcHRpb24pK1wiXFxuICAgICAgXCIpXSldKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZlbmRvci1jYXJkX19mb290ZXJcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZlbmRvci1jYXJkX19yb3dcIn0sWyhfdm0ucXVhbnRpdHkgPiAwKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2ZW5kb3ItY2FyZF9fc3RvY2stdGl0bGVcIn0sW192bS5fdihcIlxcbiAgICAgICAgICBcIitfdm0uX3MoX3ZtLnF1YW50aXR5KStcIiBcIitfdm0uX3MoX3ZtLnF1YW50aXR5VGV4dChfdm0ucXVhbnRpdHkpKStcIlxcbiAgICAgICAgXCIpXSk6X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmVuZG9yLWNhcmRfX3N0b2NrLXZhbHVlXCJ9LFtfdm0uX3YoXCJcXG4gICAgICAgICAg0J3QtdGCINGC0L7QstCw0YDQvtCyINCyINC90LDQu9C40YfQuNC4XFxuICAgICAgICBcIildKV0pXSldKV0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJ2ZW5kb3ItY2FyZFwiPlxuICAgIDxkaXYgY2xhc3M9XCJ2ZW5kb3ItY2FyZF9fd3JhcHBlclwiPlxuICAgICAgPGEgY2xhc3M9XCJ2ZW5kb3ItY2FyZF9faW1nIHN0cmV0Y2hlZC1saW5rXCIgOmhyZWY9XCJ1cmxcIiA6dGl0bGU9XCJsaW5rVGl0bGVcIj5cbiAgICAgICAgPGltZyB2LWxhenk9XCJpbWdcIiA6YWx0PVwibmFtZVwiPlxuICAgICAgPC9hPlxuICAgICAgPGRpdiBjbGFzcz1cInZlbmRvci1jYXJkX19ib2R5XCI+XG4gICAgICAgIDxoMiBjbGFzcz1cInZlbmRvci1jYXJkX190aXRsZVwiPlxuICAgICAgICAgIHt7IG5hbWUgfX1cbiAgICAgICAgPC9oMj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZlbmRvci1jYXJkX19kZXNjcmlwdGlvblwiPlxuICAgICAgICAgIHt7IGRlc2NyaXB0aW9uIH19XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwidmVuZG9yLWNhcmRfX2Zvb3RlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmVuZG9yLWNhcmRfX3Jvd1wiPlxuICAgICAgICAgIDxkaXYgdi1pZj1cInF1YW50aXR5ID4gMFwiIGNsYXNzPVwidmVuZG9yLWNhcmRfX3N0b2NrLXRpdGxlXCI+XG4gICAgICAgICAgICB7eyBxdWFudGl0eSB9fSB7eyBxdWFudGl0eVRleHQocXVhbnRpdHkpIH19XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiB2LWVsc2UgY2xhc3M9XCJ2ZW5kb3ItY2FyZF9fc3RvY2stdmFsdWVcIj5cbiAgICAgICAgICAgINCd0LXRgiDRgtC+0LLQsNGA0L7QsiDQsiDQvdCw0LvQuNGH0LjQuFxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgVXRpbHMgZnJvbSAnQC91dGlscyc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnQnJhbmRzSXRlbScsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIH0sXG4gICAgaW1nOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnL3VwbG9hZC9yZXNpemVyL25vdGZvdW5kLnN2Zz9FbGVtZW50K25vdCtmb3VuZCcsXG4gICAgfSxcbiAgICBkZXNjcmlwdGlvbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJycsXG4gICAgfSxcbiAgICBxdWFudGl0eToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMCxcbiAgICB9LFxuICAgIGxpbmtUaXRsZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJycsXG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHF1YW50aXR5VGV4dChxdWFudGl0eSkge1xuICAgICAgcmV0dXJuIFV0aWxzLmRlY2xPZk51bShxdWFudGl0eSwgWyfRgtC+0LLQsNGAJywgJ9GC0L7QstCw0YDQsCcsICfRgtC+0LLQsNGA0L7QsiddKTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CcmFuZHNDYXJkTGlzdEl0ZW0udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0JyYW5kc0NhcmRMaXN0SXRlbS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0JyYW5kc0NhcmRMaXN0SXRlbS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmYwZmI4NTImXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQnJhbmRzQ2FyZExpc3RJdGVtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQnJhbmRzQ2FyZExpc3RJdGVtLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgY2xhc3M9XCJjYXJkLWxpc3RcIlxuICAgIHJvbGU9XCJ0YWJwYW5lbFwiXG4gID5cbiAgICA8QnJhbmRzQ2FyZExpc3RJdGVtXG4gICAgICB2LWZvcj1cImJyYW5kIGluIGJyYW5kc1wiXG4gICAgICA6a2V5PVwiYnJhbmQuaWRcIlxuICAgICAgOm5hbWU9XCJicmFuZC5uYW1lXCJcbiAgICAgIDp1cmw9XCJicmFuZC51cmxcIlxuICAgICAgOmltZz1cImJyYW5kLmltZ1wiXG4gICAgICA6ZGVzY3JpcHRpb249XCJicmFuZC5kZXNjXCJcbiAgICAgIDpxdWFudGl0eT1cImJyYW5kLmNvdW50XCJcbiAgICAgIDpsaW5rLXRpdGxlPVwiYnJhbmQubGlua1RpdGxlXCJcbiAgICAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQnJhbmRzQ2FyZExpc3RJdGVtIGZyb20gJy4vQnJhbmRzQ2FyZExpc3RJdGVtLnZ1ZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnQnJhbmRzQ2FyZExpc3QnLFxuICBjb21wb25lbnRzOiB7IEJyYW5kc0NhcmRMaXN0SXRlbSB9LFxuICBwcm9wczoge1xuICAgIGJyYW5kczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CcmFuZHNDYXJkTGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQnJhbmRzQ2FyZExpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9CcmFuZHNDYXJkTGlzdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzlmZDA1Y2MmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQnJhbmRzQ2FyZExpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9CcmFuZHNDYXJkTGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImNhdGFsb2dcIj5cbiAgICA8ZGl2IGNsYXNzPVwiY2F0YWxvZ19fY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IHYtaWY9XCJmaWx0cmVkSXRlbXMubGVuZ3RoID09PSAwXCI+XG4gICAgICAgINCd0LUg0L3QsNC50LTQtdC90L5cbiAgICAgIDwvZGl2PlxuICAgICAgPGtlZXAtYWxpdmUgdi1lbHNlPlxuICAgICAgICA8QnJhbmRzQ2FyZExpc3RcbiAgICAgICAgICB2LWlmPVwidmlldyA9PT0gJ2NhcmRzJ1wiXG4gICAgICAgICAga2V5PVwiY2FyZHNcIlxuICAgICAgICAgIDpicmFuZHM9XCJmaWx0cmVkSXRlbXNcIlxuICAgICAgICAvPlxuICAgICAgICA8QnJhbmRzTmFtZUxpc3RcbiAgICAgICAgICB2LWVsc2VcbiAgICAgICAgICBrZXk9XCJsaXN0XCJcbiAgICAgICAgICA6YnJhbmRzPVwiZmlsdHJlZEl0ZW1zXCJcbiAgICAgICAgLz5cbiAgICAgIDwva2VlcC1hbGl2ZT5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IEJyYW5kc05hbWVMaXN0IGZyb20gJy4vQnJhbmRzTmFtZUxpc3QudnVlJztcbmltcG9ydCBCcmFuZHNDYXJkTGlzdCBmcm9tICcuL0JyYW5kc0NhcmRMaXN0LnZ1ZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnQnJhbmRzJyxcbiAgY29tcG9uZW50czoge1xuICAgIEJyYW5kc0NhcmRMaXN0LFxuICAgIEJyYW5kc05hbWVMaXN0LFxuICB9LFxuICBwcm9wczoge1xuICAgIGJyYW5kczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiAoKSA9PiBbXSxcbiAgICB9LFxuICAgIGZpbHRlclZhbHVlOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6ICgpID0+IFtdLFxuICAgIH0sXG4gICAgc2VhcmNoVmFsdWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnLFxuICAgIH0sXG4gICAgdmlldzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2NhcmRzJyxcbiAgICB9LFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBzZWFyY2hWYWx1ZTogJycsXG4gICAgICAvLyBzZWxlY3RlZFRhYjogJ2NhcmRzJyxcbiAgICAgIC8vIGZpbHRlclZhbHVlOiBbXSxcbiAgICB9O1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHNlYXJjaEl0ZW1zKCkge1xuICAgICAgaWYgKHRoaXMuc2VhcmNoVmFsdWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyYW5kcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYnJhbmRzLmZpbHRlcihicmFuZCA9PiBicmFuZC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLnNlYXJjaFZhbHVlKSAhPT0gLTEpO1xuICAgIH0sXG4gICAgZmlsdHJlZEl0ZW1zKCkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaEl0ZW1zO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHRoaXMuc2VhcmNoSXRlbXMuZmlsdGVyKGJyYW5kID0+IHRoaXMuZmlsdGVyVmFsdWUuZXZlcnkoaWQgPT4gYnJhbmQuc2VjdGlvbnMuaW5jbHVkZXMoaWQpKSk7XG4gICAgICByZXR1cm4gdGhpcy5zZWFyY2hJdGVtcy5maWx0ZXIoYnJhbmQgPT4gdGhpcy5maWx0ZXJWYWx1ZS5ldmVyeShpZHMgPT4gKFxuICAgICAgICBpZHMubGVuZ3RoID09PSAwIHx8IGlkcy5zb21lKGlkID0+IGJyYW5kLnNlY3Rpb25zLmluY2x1ZGVzKGlkKSlcbiAgICAgICkpKTtcbiAgICB9LFxuICB9LFxuICAvLyBjcmVhdGVkKCkge1xuICAvLyAgIHRoaXMuJHJvb3QuJG9uKCd1cGRhdGU6ZmlsdGVycycsIChpdGVtcykgPT4ge1xuICAvLyAgICAgdGhpcy5maWx0ZXJWYWx1ZSA9IGl0ZW1zO1xuICAvLyAgIH0pO1xuICAvL1xuICAvLyAgIHRoaXMuJHJvb3QuJG9uKCd1cGRhdGU6dGFiJywgKHRhYikgPT4ge1xuICAvLyAgICAgdGhpcy5zZWxlY3RlZFRhYiA9IHRhYjtcbiAgLy8gICB9KTtcbiAgLy9cbiAgLy8gICB0aGlzLiRyb290LiRvbigndXBkYXRlOnNlYXJjaCcsICh0ZXh0KSA9PiB7XG4gIC8vICAgICB0aGlzLnNlYXJjaFZhbHVlID0gdGV4dDtcbiAgLy8gICB9KTtcbiAgLy8gfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQnJhbmRzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CcmFuZHMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9CcmFuZHMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTNlOTAxNDIyJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0JyYW5kcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0JyYW5kcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGFsb2ctY29udHJvbFwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY2F0YWxvZy1jb250cm9sX19tb2JpbGVcIn0sX3ZtLl9sKChfdm0ubmV3RmlsdGVyKSxmdW5jdGlvbihmaWx0ZXIpe3JldHVybiBfYygnQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwnLHtrZXk6ZmlsdGVyLm5hbWUsYXR0cnM6e1wiZmlsdGVyXCI6ZmlsdGVyfSxvbjp7XCJjaGFuZ2VcIjpfdm0ub25DaGFuZ2V9fSl9KSwxKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGFsb2ctY29udHJvbF9fbWVudSBjYXRhbG9nLWNvbnRyb2xfX21lbnVfd2hpdGVcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbnRhaW5lclwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmlld1wifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmlld19fY2F0ZWdvcnlcIn0sW192bS5fbCgoX3ZtLm5ld0ZpbHRlciksZnVuY3Rpb24oZmlsdGVyKXtyZXR1cm4gWyhmaWx0ZXIudHlwZSA9PT0gJ2NoZWNrYm94Jyk/X2MoJ0ZpbHRlckNoZWNrYm94Jyx7a2V5OmZpbHRlci5uYW1lLGF0dHJzOntcImZpbHRlclwiOmZpbHRlcn0sb246e1wiY2hhbmdlXCI6X3ZtLm9uQ2hhbmdlfX0pOihmaWx0ZXIudHlwZSA9PT0gJ3JhZGlvJyk/X2MoJ0ZpbHRlclNlbGVjdCcse2tleTpmaWx0ZXIubmFtZSxhdHRyczp7XCJmaWx0ZXJcIjpmaWx0ZXJ9fSk6KGZpbHRlci50eXBlID09PSAncmFuZ2UnKT9fYygnRmlsdGVyUHJpY2UnLHtrZXk6ZmlsdGVyLm5hbWUsYXR0cnM6e1wiZmlsdGVyXCI6ZmlsdGVyfX0pOl92bS5fZSgpXX0pXSwyKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZpZXdfX3RhYlwifSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19jb250ZW50XCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fbGFiZWxcIn0sW192bS5fdihcIlxcbiAgICAgICAgICAgICAgICDQktC40LQ6XFxuICAgICAgICAgICAgICBcIildKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX190YWJsaXN0XCIsYXR0cnM6e1wicm9sZVwiOlwidGFibGlzdFwifX0sW19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX190YWJcIixjbGFzczp7IGFjdGl2ZTogX3ZtLnZpZXcgPT09ICdjYXJkcycgfSxhdHRyczp7XCJyb2xlXCI6XCJ0YWJcIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBfdm0uc2hvd1RhYignY2FyZHMnKX19fSxbX2MoJ2knLHtzdGF0aWNDbGFzczpcImkgaS1jYXJkc1wifSldKSxfdm0uX3YoXCIgXCIpLF9jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX190YWJcIixjbGFzczp7IGFjdGl2ZTogX3ZtLnZpZXcgPT09ICdsaXN0JyB9LGF0dHJzOntcInJvbGVcIjpcInRhYlwifSxvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS5zaG93VGFiKCdsaXN0Jyl9fX0sW19jKCdpJyx7c3RhdGljQ2xhc3M6XCJpIGktbGlzdFwifSldKV0pXSldKV0pXSldKV0pXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImNhdGFsb2ctY29udHJvbFwiPlxuICAgIDxkaXYgY2xhc3M9XCJjYXRhbG9nLWNvbnRyb2xfX21vYmlsZVwiPlxuICAgICAgPENhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsXG4gICAgICAgIHYtZm9yPVwiZmlsdGVyIGluIG5ld0ZpbHRlclwiXG4gICAgICAgIDprZXk9XCJmaWx0ZXIubmFtZVwiXG4gICAgICAgIDpmaWx0ZXI9XCJmaWx0ZXJcIlxuICAgICAgICBAY2hhbmdlPVwib25DaGFuZ2VcIlxuICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY2F0YWxvZy1jb250cm9sX19tZW51IGNhdGFsb2ctY29udHJvbF9fbWVudV93aGl0ZVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidmlld1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2aWV3X19jYXRlZ29yeVwiPlxuICAgICAgICAgICAgPHRlbXBsYXRlIHYtZm9yPVwiZmlsdGVyIGluIG5ld0ZpbHRlclwiPlxuICAgICAgICAgICAgICA8RmlsdGVyQ2hlY2tib3hcbiAgICAgICAgICAgICAgICB2LWlmPVwiZmlsdGVyLnR5cGUgPT09ICdjaGVja2JveCdcIlxuICAgICAgICAgICAgICAgIDprZXk9XCJmaWx0ZXIubmFtZVwiXG4gICAgICAgICAgICAgICAgOmZpbHRlcj1cImZpbHRlclwiXG4gICAgICAgICAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPEZpbHRlclNlbGVjdFxuICAgICAgICAgICAgICAgIHYtZWxzZS1pZj1cImZpbHRlci50eXBlID09PSAncmFkaW8nXCJcbiAgICAgICAgICAgICAgICA6a2V5PVwiZmlsdGVyLm5hbWVcIlxuICAgICAgICAgICAgICAgIDpmaWx0ZXI9XCJmaWx0ZXJcIlxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8RmlsdGVyUHJpY2VcbiAgICAgICAgICAgICAgICB2LWVsc2UtaWY9XCJmaWx0ZXIudHlwZSA9PT0gJ3JhbmdlJ1wiXG4gICAgICAgICAgICAgICAgOmtleT1cImZpbHRlci5uYW1lXCJcbiAgICAgICAgICAgICAgICA6ZmlsdGVyPVwiZmlsdGVyXCJcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInZpZXdfX3RhYlwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm11bHRpZmlsdGVyXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlcl9fY29udGVudFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlcl9fbGFiZWxcIj5cbiAgICAgICAgICAgICAgICAgINCS0LjQtDpcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXJfX3RhYmxpc3RcIiByb2xlPVwidGFibGlzdFwiPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm11bHRpZmlsdGVyX190YWJcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7IGFjdGl2ZTogdmlldyA9PT0gJ2NhcmRzJyB9XCJcbiAgICAgICAgICAgICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgICAgICAgICAgIEBjbGljay5wcmV2ZW50PVwic2hvd1RhYignY2FyZHMnKVwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiaSBpLWNhcmRzXCIgLz5cbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cIm11bHRpZmlsdGVyX190YWJcIlxuICAgICAgICAgICAgICAgICAgICA6Y2xhc3M9XCJ7IGFjdGl2ZTogdmlldyA9PT0gJ2xpc3QnIH1cIlxuICAgICAgICAgICAgICAgICAgICByb2xlPVwidGFiXCJcbiAgICAgICAgICAgICAgICAgICAgQGNsaWNrLnByZXZlbnQ9XCJzaG93VGFiKCdsaXN0JylcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImkgaS1saXN0XCIgLz5cbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwgZnJvbSAnQC9jb21wb25lbnRzL0NhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsLnZ1ZSc7XG5pbXBvcnQgRmlsdGVyQ2hlY2tib3ggZnJvbSAnQC9jb21wb25lbnRzL2NhdGFsb2cvRmlsdGVyQ2hlY2tib3gudnVlJztcbmltcG9ydCBGaWx0ZXJTZWxlY3QgZnJvbSAnQC9jb21wb25lbnRzL2NhdGFsb2cvRmlsdGVyU2VsZWN0LnZ1ZSc7XG5pbXBvcnQgRmlsdGVyUHJpY2UgZnJvbSAnQC9jb21wb25lbnRzL2NhdGFsb2cvRmlsdGVyUHJpY2UudnVlJztcblxuaW1wb3J0IHtcbiAgUHJpY2VGaWx0ZXIsXG4gIENoZWNrYm94RmlsdGVyLFxuICBSYWRpb0ZpbHRlcixcbiAgU2VsZWN0RmlsdGVyLFxufSBmcm9tICdAL2NvbXBvbmVudHMvTXVsdGlmaWx0ZXInO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ0JyYW5kc0ZpbHRlcicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDYXRhbG9nRmlsdGVyTW9iaWxlSG9yaXpvbnRhbCxcbiAgICBGaWx0ZXJDaGVja2JveCxcbiAgICBGaWx0ZXJTZWxlY3QsXG4gICAgRmlsdGVyUHJpY2UsXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmlldzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2NhcmRzJyxcbiAgICB9LFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXJzOiBbXSxcbiAgICAgIC8vIHZpZXc6ICdjYXJkcycsXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICAvLyAuLi5tYXBTdGF0ZSgnZmlsdGVycycsIHtcbiAgICAvLyAgIGZpbHRlcnM6IHN0YXRlID0+IHN0YXRlLmZpbHRlcnMsXG4gICAgLy8gfSksXG4gICAgbmV3RmlsdGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycy5tYXAoKGZpbHRlciwgaSwgYXJyYXkpID0+IHtcbiAgICAgICAgaWYgKGZpbHRlci5wYXJlbnQpIHtcbiAgICAgICAgICBmaWx0ZXIucGFyZW50ID0gYXJyYXkuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gZmlsdGVyLnBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcbiAgY3JlYXRlZCgpIHtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXS5tYXAuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdmaWVsZHNldC5tdWx0aWZpbHRlcicpLCAoZmlsdGVyKSA9PiB7XG4gICAgICBpZiAoZmlsdGVyLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlci1jaGVja2JveCcpKSB7XG4gICAgICAgIHJldHVybiBDaGVja2JveEZpbHRlci5wYXJzZVNldHRpbmdzKGZpbHRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXIucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXJhZGlvJykpIHtcbiAgICAgICAgcmV0dXJuIFNlbGVjdEZpbHRlci5wYXJzZVNldHRpbmdzKGZpbHRlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXIucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXByaWNlJykpIHtcbiAgICAgICAgcmV0dXJuIFByaWNlRmlsdGVyLnBhcnNlU2V0dGluZ3MoZmlsdGVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgLy8gW1sxMDQwLCAxMDYwXSwgWzEwNDEsIDEwNDIsIDEwNjFdXVxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5maWx0ZXJzLm1hcChcbiAgICAgICAgICBmaWx0ZXIgPT4gZmlsdGVyLmRhdGFcbiAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpXG4gICAgICAgICAgICAubWFwKGl0ZW0gPT4gcGFyc2VJbnQoaXRlbS52YWx1ZSwgMTApKSxcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6ZmlsdGVycycsIGRhdGEpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzaG93VGFiKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTp2aWV3JywgZSk7XG4gICAgfSxcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQnJhbmRzRmlsdGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9CcmFuZHNGaWx0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9CcmFuZHNGaWx0ZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTMzYTNhMDMyJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0JyYW5kc0ZpbHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0JyYW5kc0ZpbHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcblxuaW1wb3J0IHN0b3JlIGZyb20gJ0Avc3RvcmUnO1xuXG5pbXBvcnQgQnJhbmRzIGZyb20gJ0AvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzLnZ1ZSc7XG5pbXBvcnQgQnJhbmRzRmlsdGVyIGZyb20gJ0AvY29tcG9uZW50cy9icmFuZHMvQnJhbmRzRmlsdGVyLnZ1ZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVuZG9ycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2VhcmNoQ29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBhZ2UtaGVhZGVyIC5zZWFyY2gtZmlsZCcpO1xuICAgIHRoaXMuc2VhcmNoRmllbGQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1oZWFkZXIgLnNlYXJjaC1maWxkX19pbnB1dCcpO1xuXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuZGF0YSA9IFZ1ZS5vYnNlcnZhYmxlKHtcbiAgICAgIHZpZXc6ICdjYXJkcycsXG4gICAgICBmaWx0ZXJWYWx1ZTogW10sXG4gICAgICBzZWFyY2hWYWx1ZTogdGhpcy5zZWFyY2hGaWVsZC52YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKSxcbiAgICB9KTtcblxuICAgIHRoaXMuYnJhbmRzVk0gPSBuZXcgVnVlKHtcbiAgICAgIHN0b3JlLFxuICAgICAgZWw6ICcuY2F0YWxvZycsXG4gICAgICByZW5kZXI6IGggPT4gaChCcmFuZHMsIHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICBicmFuZHM6IHdpbmRvdy5icmFuZHMsXG4gICAgICAgICAgdmlldzogdGhpcy5kYXRhLnZpZXcsXG4gICAgICAgICAgc2VhcmNoVmFsdWU6IHRoaXMuZGF0YS5zZWFyY2hWYWx1ZSxcbiAgICAgICAgICBmaWx0ZXJWYWx1ZTogdGhpcy5kYXRhLmZpbHRlclZhbHVlLFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgfSk7XG5cblxuICAgIHRoaXMuZmlsdGVyVk0gPSBuZXcgVnVlKHtcbiAgICAgIHN0b3JlLFxuICAgICAgZWw6ICcuY2F0YWxvZy1jb250cm9sJyxcbiAgICAgIHJlbmRlcjogaCA9PiBoKEJyYW5kc0ZpbHRlciwge1xuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHZpZXc6IHRoaXMuZGF0YS52aWV3LFxuICAgICAgICB9LFxuICAgICAgICBvbjoge1xuICAgICAgICAgIC8vICd1cGRhdGU6ZmlsdGVycyc6IGUgPT4gdGhpcy5icmFuZHNWTS4kZW1pdCgndXBkYXRlOmZpbHRlcnMnLCBlKSxcbiAgICAgICAgICAvLyAndXBkYXRlOnRhYic6IGUgPT4gdGhpcy5icmFuZHNWTS4kZW1pdCgndXBkYXRlOnRhYicsIGUpLFxuICAgICAgICAgICd1cGRhdGU6ZmlsdGVycyc6IChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuZmlsdGVyVmFsdWUgPSBlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ3VwZGF0ZTp2aWV3JzogKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS52aWV3ID0gZTtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgfSk7XG5cblxuICAgIHRoaXMuc2VhcmNoQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMub25TZWFyY2gpO1xuICAgIHRoaXMuc2VhcmNoRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLm9uU2VhcmNoKTtcbiAgICB0aGlzLnNlYXJjaEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25TZWFyY2gpO1xuICB9XG5cbiAgb25TZWFyY2ggPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIHRoaXMuYnJhbmRzVk0uJGVtaXQoJ3VwZGF0ZTpzZWFyY2gnLCB0aGlzLnNlYXJjaEZpZWxkLnZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB0aGlzLmRhdGEuc2VhcmNoVmFsdWUgPSB0aGlzLnNlYXJjaEZpZWxkLnZhbHVlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICB9O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///172\n')},19:function(module,exports,__webpack_require__){eval('var superPropBase = __webpack_require__(59);\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== "undefined" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanM/ODk2MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IsbUJBQU8sQ0FBQyxFQUFpQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZVwiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n')},22:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterCheckbox.vue?vue&type=template&id=baf1eeb4&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('dropdown',{staticClass:\"multifilter\",class:{ active: _vm.checkedItems.length },attrs:{\"scrolled\":true,\"disabled\":_vm.items.length === 0}},[_c('template',{slot:\"btn\"},[(_vm.filter.replaceTitle)?_c('span',{staticClass:\"multifilter__label\"},[_vm._v(_vm._s(_vm.filter.label))]):_vm._e(),_vm._v(\" \"),(_vm.filter.replaceTitle)?_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(_vm.checkedTitle))]):_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(_vm.filter.label))]),_vm._v(\" \"),(_vm.checkedItems.length)?_c('span',{staticClass:\"multifilter__total\"},[_vm._v(_vm._s(_vm.checkedItems.length))]):_vm._e()]),_vm._v(\" \"),(_vm.checkedItems.length)?_c('button',{staticClass:\"multifilter__btn-clear\",attrs:{\"type\":\"reset\"},on:{\"click\":function($event){$event.preventDefault();return _vm.onReset(_vm.filter)}}},[_vm._v(\"\\n    Сбросить\\n  \")]):_vm._e(),_vm._v(\" \"),_c('template',{slot:\"body\"},[_c('MultifilterCheckboxList',{attrs:{\"items\":_vm.items},on:{\"change\":_vm.onChange}})],1)],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterCheckbox.vue?vue&type=template&id=baf1eeb4&\n\n// EXTERNAL MODULE: ./src/js/components/Dropdown.vue + 4 modules\nvar Dropdown = __webpack_require__(17);\n\n// EXTERNAL MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue + 9 modules\nvar MultifilterCheckboxList = __webpack_require__(25);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterCheckbox.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n// import { mapGetters, mapState, mapActions } from 'vuex'\n// import simplebar from 'simplebar-vue';\n// import 'simplebar/dist/simplebar.min.css';\n\n\n/* harmony default export */ var FilterCheckboxvue_type_script_lang_js_ = ({\n  name: 'Multifilter',\n  components: {\n    MultifilterCheckboxList: MultifilterCheckboxList[\"a\" /* default */],\n    Dropdown: Dropdown[\"a\" /* default */]\n  },\n  props: {\n    filter: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    items: function items() {\n      if (this.filter.parent) {\n        // TODO: Как-то поправить эту хуйню с обновлениием наследника при изменении родителя\n        var parent = typeof this.filter.parent === 'string' ? this.$store.state.filters.filters[this.filter.parent] : this.filter.parent;\n        var checkedParentItemIds = parent.data.filter(function (item) {\n          return item.checked;\n        }).map(function (item) {\n          return item.value;\n        }); // return this.filter.data.filter(item => checkedParentItemIds.includes(item.parent))\n\n        var t = this.filter.data.reduce(function (arr, item) {\n          if (checkedParentItemIds.includes(item.parent)) {\n            arr.push(item);\n          } else {\n            item.checked = false;\n          }\n\n          return arr;\n        }, []); // Срабатывает только тогда, когда изменился родитель\n        // Если меняется родитель, то действие вызывается до того, как обновился наследник и данные неверные.\n        // Поэтому вызываем еще раз\n        // Это все говна кусок, поэтому такой костыль\n        // this.$emit('change');\n\n        this.$store.dispatch('filters/onChange');\n        return t;\n      }\n\n      return this.filter.data;\n    },\n    checkedTitle: function checkedTitle() {\n      if (this.items.length === 0) {\n        return this.filter.labelDisabled;\n      }\n\n      if (this.checkedItems.length) {\n        return this.checkedItems.map(function (item) {\n          return item.label;\n        }).join(', ');\n      }\n\n      return this.filter.labelEmpty;\n    },\n    checkedItems: function checkedItems() {\n      return this.items.filter(function (item) {\n        return item.checked;\n      });\n    }\n  },\n  mounted: function mounted() {\n    this.$root.$on('filter:reset', this.reset);\n  },\n  methods: {\n    reset: function reset() {\n      this.filter.data.forEach(function (item) {\n        item.checked = false;\n      });\n    },\n    onReset: function onReset(filter) {\n      this.reset(); // this.$store.dispatch('filters/filterReset', { container: 'filters', name: filter.name, type: filter.type });\n\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    },\n    onChange: function onChange(e) {\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterCheckbox.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_FilterCheckboxvue_type_script_lang_js_ = (FilterCheckboxvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterCheckbox.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  catalog_FilterCheckboxvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var FilterCheckbox = __webpack_exports__[\"a\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlckNoZWNrYm94LnZ1ZT83NzU4Iiwid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlckNoZWNrYm94LnZ1ZT8zOTA5Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvRmlsdGVyQ2hlY2tib3gudnVlP2M3NDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJDaGVja2JveC52dWU/ZmIyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBCQUEwQixhQUFhLDBCQUEwQix3QkFBd0Isc0JBQXNCLGlDQUFpQyxrQ0FBa0MsUUFBUSxtREFBbUQsaUJBQWlCLFdBQVcsdUNBQXVDLGlDQUFpQywrRkFBK0YsaUNBQWlDLGdEQUFnRCxpQ0FBaUMsc0ZBQXNGLGlDQUFpQywwR0FBMEcsNENBQTRDLGVBQWUsS0FBSyx5QkFBeUIsd0JBQXdCLGlDQUFpQyxxRUFBcUUsWUFBWSxnQ0FBZ0MsT0FBTyxrQkFBa0IsS0FBSyx1QkFBdUI7QUFDM2pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQSxxQkFEQTtBQUVBO0FBQ0EsdUVBREE7QUFFQTtBQUZBLEdBRkE7QUFNQTtBQUNBO0FBQ0Esa0JBREE7QUFFQTtBQUZBO0FBREEsR0FOQTtBQVlBO0FBQ0EsU0FEQSxtQkFDQTtBQUNBO0FBQ0E7QUFFQSw4REFDQSxxREFEQSxHQUVBLGtCQUZBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVBBLENBU0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FGQSxNQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLFNBUEEsRUFPQSxFQVBBLEVBVkEsQ0FrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxLQTdCQTtBQThCQSxnQkE5QkEsMEJBOEJBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQSxLQXRDQTtBQXdDQSxnQkF4Q0EsMEJBd0NBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUExQ0EsR0FaQTtBQXdEQSxTQXhEQSxxQkF3REE7QUFDQTtBQUNBLEdBMURBO0FBMkRBO0FBQ0EsU0FEQSxtQkFDQTtBQUNBO0FBQ0E7QUFDQSxPQUZBO0FBR0EsS0FMQTtBQU1BLFdBTkEsbUJBTUEsTUFOQSxFQU1BO0FBQ0EsbUJBREEsQ0FFQTs7QUFDQTtBQUNBO0FBQ0EsS0FYQTtBQVlBLFlBWkEsb0JBWUEsQ0FaQSxFQVlBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUEzREEsRzs7QUNwRG9NLENBQWdCLHlIQUFHLEVBQUMsQzs7Ozs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBRzdEO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLDhDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLCtGIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Ryb3Bkb3duJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlclwiLGNsYXNzOnsgYWN0aXZlOiBfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCB9LGF0dHJzOntcInNjcm9sbGVkXCI6dHJ1ZSxcImRpc2FibGVkXCI6X3ZtLml0ZW1zLmxlbmd0aCA9PT0gMH19LFtfYygndGVtcGxhdGUnLHtzbG90OlwiYnRuXCJ9LFsoX3ZtLmZpbHRlci5yZXBsYWNlVGl0bGUpP19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fbGFiZWxcIn0sW192bS5fdihfdm0uX3MoX3ZtLmZpbHRlci5sYWJlbCkpXSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSwoX3ZtLmZpbHRlci5yZXBsYWNlVGl0bGUpP19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fdmFsdWVcIn0sW192bS5fdihfdm0uX3MoX3ZtLmNoZWNrZWRUaXRsZSkpXSk6X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX192YWx1ZVwifSxbX3ZtLl92KF92bS5fcyhfdm0uZmlsdGVyLmxhYmVsKSldKSxfdm0uX3YoXCIgXCIpLChfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCk/X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX190b3RhbFwifSxbX3ZtLl92KF92bS5fcyhfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCkpXSk6X3ZtLl9lKCldKSxfdm0uX3YoXCIgXCIpLChfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCk/X2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX2J0bi1jbGVhclwiLGF0dHJzOntcInR5cGVcIjpcInJlc2V0XCJ9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLm9uUmVzZXQoX3ZtLmZpbHRlcil9fX0sW192bS5fdihcIlxcbiAgICDQodCx0YDQvtGB0LjRgtGMXFxuICBcIildKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLF9jKCd0ZW1wbGF0ZScse3Nsb3Q6XCJib2R5XCJ9LFtfYygnTXVsdGlmaWx0ZXJDaGVja2JveExpc3QnLHthdHRyczp7XCJpdGVtc1wiOl92bS5pdGVtc30sb246e1wiY2hhbmdlXCI6X3ZtLm9uQ2hhbmdlfX0pXSwxKV0sMil9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPGRyb3Bkb3duXG4gICAgY2xhc3M9XCJtdWx0aWZpbHRlclwiXG4gICAgOnNjcm9sbGVkPVwidHJ1ZVwiXG4gICAgOmNsYXNzPVwieyBhY3RpdmU6IGNoZWNrZWRJdGVtcy5sZW5ndGggfVwiXG4gICAgOmRpc2FibGVkPVwiaXRlbXMubGVuZ3RoID09PSAwXCJcbiAgPlxuICAgIDx0ZW1wbGF0ZSBzbG90PVwiYnRuXCI+XG4gICAgICA8c3BhblxuICAgICAgICB2LWlmPVwiZmlsdGVyLnJlcGxhY2VUaXRsZVwiXG4gICAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2xhYmVsXCJcbiAgICAgID57eyBmaWx0ZXIubGFiZWwgfX08L3NwYW4+XG4gICAgICA8c3BhblxuICAgICAgICB2LWlmPVwiZmlsdGVyLnJlcGxhY2VUaXRsZVwiXG4gICAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX3ZhbHVlXCJcbiAgICAgID57eyBjaGVja2VkVGl0bGUgfX08L3NwYW4+XG4gICAgICA8c3BhblxuICAgICAgICB2LWVsc2VcbiAgICAgICAgY2xhc3M9XCJtdWx0aWZpbHRlcl9fdmFsdWVcIlxuICAgICAgPnt7IGZpbHRlci5sYWJlbCB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuXG4gICAgICAgIHYtaWY9XCJjaGVja2VkSXRlbXMubGVuZ3RoXCJcbiAgICAgICAgY2xhc3M9XCJtdWx0aWZpbHRlcl9fdG90YWxcIlxuICAgICAgPnt7IGNoZWNrZWRJdGVtcy5sZW5ndGggfX08L3NwYW4+XG4gICAgPC90ZW1wbGF0ZT5cblxuICAgIDxidXR0b25cbiAgICAgIHYtaWY9XCJjaGVja2VkSXRlbXMubGVuZ3RoXCJcbiAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2J0bi1jbGVhclwiXG4gICAgICB0eXBlPVwicmVzZXRcIlxuICAgICAgQGNsaWNrLnByZXZlbnQ9XCJvblJlc2V0KGZpbHRlcilcIlxuICAgID5cbiAgICAgINCh0LHRgNC+0YHQuNGC0YxcbiAgICA8L2J1dHRvbj5cblxuICAgIDx0ZW1wbGF0ZSBzbG90PVwiYm9keVwiPlxuICAgICAgPE11bHRpZmlsdGVyQ2hlY2tib3hMaXN0XG4gICAgICAgIDppdGVtcz1cIml0ZW1zXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgICAgIC8+XG4gICAgPC90ZW1wbGF0ZT5cbiAgPC9kcm9wZG93bj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4vLyBpbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwQWN0aW9ucyB9IGZyb20gJ3Z1ZXgnXG4vLyBpbXBvcnQgc2ltcGxlYmFyIGZyb20gJ3NpbXBsZWJhci12dWUnO1xuLy8gaW1wb3J0ICdzaW1wbGViYXIvZGlzdC9zaW1wbGViYXIubWluLmNzcyc7XG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi4vRHJvcGRvd24udnVlJztcbmltcG9ydCBNdWx0aWZpbHRlckNoZWNrYm94TGlzdCBmcm9tICcuL011bHRpZmlsdGVyQ2hlY2tib3hMaXN0LnZ1ZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnTXVsdGlmaWx0ZXInLFxuICBjb21wb25lbnRzOiB7XG4gICAgTXVsdGlmaWx0ZXJDaGVja2JveExpc3QsXG4gICAgRHJvcGRvd24sXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgZmlsdGVyOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1zKCkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyLnBhcmVudCkge1xuICAgICAgICAvLyBUT0RPOiDQmtCw0Lot0YLQviDQv9C+0L/RgNCw0LLQuNGC0Ywg0Y3RgtGDINGF0YPQudC90Y4g0YEg0L7QsdC90L7QstC70LXQvdC40LjQtdC8INC90LDRgdC70LXQtNC90LjQutCwINC/0YDQuCDQuNC30LzQtdC90LXQvdC40Lgg0YDQvtC00LjRgtC10LvRj1xuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9ICh0eXBlb2YgdGhpcy5maWx0ZXIucGFyZW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgICA/IHRoaXMuJHN0b3JlLnN0YXRlLmZpbHRlcnMuZmlsdGVyc1t0aGlzLmZpbHRlci5wYXJlbnRdXG4gICAgICAgICAgOiB0aGlzLmZpbHRlci5wYXJlbnQ7XG5cbiAgICAgICAgY29uc3QgY2hlY2tlZFBhcmVudEl0ZW1JZHMgPSBwYXJlbnQuZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGlzLmZpbHRlci5kYXRhLmZpbHRlcihpdGVtID0+IGNoZWNrZWRQYXJlbnRJdGVtSWRzLmluY2x1ZGVzKGl0ZW0ucGFyZW50KSlcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZmlsdGVyLmRhdGEucmVkdWNlKChhcnIsIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoY2hlY2tlZFBhcmVudEl0ZW1JZHMuaW5jbHVkZXMoaXRlbS5wYXJlbnQpKSB7XG4gICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgLy8g0KHRgNCw0LHQsNGC0YvQstCw0LXRgiDRgtC+0LvRjNC60L4g0YLQvtCz0LTQsCwg0LrQvtCz0LTQsCDQuNC30LzQtdC90LjQu9GB0Y8g0YDQvtC00LjRgtC10LvRjFxuICAgICAgICAvLyDQldGB0LvQuCDQvNC10L3Rj9C10YLRgdGPINGA0L7QtNC40YLQtdC70YwsINGC0L4g0LTQtdC50YHRgtCy0LjQtSDQstGL0LfRi9Cy0LDQtdGC0YHRjyDQtNC+INGC0L7Qs9C+LCDQutCw0Log0L7QsdC90L7QstC40LvRgdGPINC90LDRgdC70LXQtNC90LjQuiDQuCDQtNCw0L3QvdGL0LUg0L3QtdCy0LXRgNC90YvQtS5cbiAgICAgICAgLy8g0J/QvtGN0YLQvtC80YMg0LLRi9C30YvQstCw0LXQvCDQtdGJ0LUg0YDQsNC3XG4gICAgICAgIC8vINCt0YLQviDQstGB0LUg0LPQvtCy0L3QsCDQutGD0YHQvtC6LCDQv9C+0Y3RgtC+0LzRgyDRgtCw0LrQvtC5INC60L7RgdGC0YvQu9GMXG4gICAgICAgIC8vIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbHRlci5kYXRhO1xuICAgIH0sXG4gICAgY2hlY2tlZFRpdGxlKCkge1xuICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5sYWJlbERpc2FibGVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hlY2tlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VkSXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5sYWJlbCkuam9pbignLCAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbHRlci5sYWJlbEVtcHR5O1xuICAgIH0sXG5cbiAgICBjaGVja2VkSXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpO1xuICAgIH0sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy4kcm9vdC4kb24oJ2ZpbHRlcjpyZXNldCcsIHRoaXMucmVzZXQpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLmZpbHRlci5kYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaXRlbS5jaGVja2VkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uUmVzZXQoZmlsdGVyKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAvLyB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9maWx0ZXJSZXNldCcsIHsgY29udGFpbmVyOiAnZmlsdGVycycsIG5hbWU6IGZpbHRlci5uYW1lLCB0eXBlOiBmaWx0ZXIudHlwZSB9KTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuXG48IS0tPHN0eWxlIHNjb3BlZD4tLT5cblxuPCEtLTwvc3R5bGU+LS0+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0ZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9GaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0ZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iYWYxZWViNCZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9GaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0ZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n")},23:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterSelect.vue?vue&type=template&id=b5db7e18&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'fieldset\',{directives:[{name:"click-outside",rawName:"v-click-outside",value:(_vm.close),expression:"close"}],staticClass:"multifilter",class:{ show: _vm.visible }},[_c(\'button\',{staticClass:"multifilter__content multifilter__content_dropdown",attrs:{"type":"button"},on:{"click":function($event){$event.preventDefault();return _vm.toggle($event)}}},[_c(\'span\',{staticClass:"multifilter__value"},[_vm._v(_vm._s(_vm.filter.label))])]),_vm._v(" "),_c(\'div\',{staticClass:"dropdown-menu",class:{ show: _vm.visible }},_vm._l((_vm.filter.data),function(item){return _c(\'label\',{staticClass:"multifilter-radio"},[_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.filter.selected),expression:"filter.selected"}],staticClass:"multifilter-radio__input",attrs:{"type":"radio","name":item.name},domProps:{"value":item.value,"checked":_vm._q(_vm.filter.selected,item.value)},on:{"change":[function($event){return _vm.$set(_vm.filter, "selected", item.value)},function($event){return _vm.onChange(item)}]}}),_vm._v(" "),_c(\'span\',{staticClass:"multifilter-radio__label"},[_vm._v(_vm._s(item.label))])])}),0)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterSelect.vue?vue&type=template&id=b5db7e18&scoped=true&\n\n// EXTERNAL MODULE: ./src/js/components/Dropdown.vue + 4 modules\nvar Dropdown = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterSelect.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var FilterSelectvue_type_script_lang_js_ = ({\n  name: "FilterSelect",\n  components: {\n    Dropdown: Dropdown["a" /* default */]\n  },\n  props: {\n    filter: Object\n  },\n  data: function data() {\n    return {\n      visible: false\n    };\n  },\n  methods: {\n    onChange: function onChange(item) {\n      this.filter.label = item.label;\n      this.$store.dispatch(\'filters/onChange\');\n      this.close();\n    },\n    open: function open() {\n      this.visible = true;\n    },\n    close: function close() {\n      this.visible = false;\n    },\n    toggle: function toggle() {\n      this.visible = !this.visible;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterSelect.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_FilterSelectvue_type_script_lang_js_ = (FilterSelectvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterSelect.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  catalog_FilterSelectvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "b5db7e18",\n  null\n  \n)\n\n/* harmony default export */ var FilterSelect = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlclNlbGVjdC52dWU/M2QyNSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlP2JjNjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlP2UxZmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlPzBhNmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLHNCQUFzQixhQUFhLG9GQUFvRixtQ0FBbUMscUJBQXFCLGVBQWUsd0VBQXdFLGdCQUFnQixLQUFLLHlCQUF5Qix3QkFBd0IsNEJBQTRCLGFBQWEsaUNBQWlDLDZEQUE2RCxtQ0FBbUMscUJBQXFCLHlDQUF5QyxtQkFBbUIsZ0NBQWdDLGNBQWMsYUFBYSx3RkFBd0YsZ0RBQWdELGdDQUFnQyxXQUFXLG9FQUFvRSxLQUFLLDJCQUEyQixvREFBb0Qsa0JBQWtCLDBCQUEwQixHQUFHLHlCQUF5Qix1Q0FBdUMsaUNBQWlDO0FBQ3RyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3lCQTtBQUdBO0FBQ0Esc0JBREE7QUFFQTtBQUFBO0FBQUEsR0FGQTtBQUdBO0FBQ0E7QUFEQSxHQUhBO0FBTUEsTUFOQSxrQkFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBLEdBVkE7QUFXQTtBQUNBLFlBREEsb0JBQ0EsSUFEQSxFQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EsS0FOQTtBQVFBLFFBUkEsa0JBUUE7QUFDQTtBQUNBLEtBVkE7QUFXQSxTQVhBLG1CQVdBO0FBQ0E7QUFDQSxLQWJBO0FBY0EsVUFkQSxvQkFjQTtBQUNBO0FBQ0E7QUFoQkE7QUFYQSxHOztBQzdCa00sQ0FBZ0IscUhBQUcsRUFBQyxDOzs7OztBQ0EvRztBQUN2QztBQUNMOzs7QUFHM0Q7QUFDZ0c7QUFDaEcsZ0JBQWdCLDhDQUFVO0FBQzFCLEVBQUUsNENBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsNkYiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZmllbGRzZXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcImNsaWNrLW91dHNpZGVcIixyYXdOYW1lOlwidi1jbGljay1vdXRzaWRlXCIsdmFsdWU6KF92bS5jbG9zZSksZXhwcmVzc2lvbjpcImNsb3NlXCJ9XSxzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyXCIsY2xhc3M6eyBzaG93OiBfdm0udmlzaWJsZSB9fSxbX2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX2NvbnRlbnQgbXVsdGlmaWx0ZXJfX2NvbnRlbnRfZHJvcGRvd25cIixhdHRyczp7XCJ0eXBlXCI6XCJidXR0b25cIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBfdm0udG9nZ2xlKCRldmVudCl9fX0sW19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fdmFsdWVcIn0sW192bS5fdihfdm0uX3MoX3ZtLmZpbHRlci5sYWJlbCkpXSldKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLW1lbnVcIixjbGFzczp7IHNob3c6IF92bS52aXNpYmxlIH19LF92bS5fbCgoX3ZtLmZpbHRlci5kYXRhKSxmdW5jdGlvbihpdGVtKXtyZXR1cm4gX2MoJ2xhYmVsJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1yYWRpb1wifSxbX2MoJ2lucHV0Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5maWx0ZXIuc2VsZWN0ZWQpLGV4cHJlc3Npb246XCJmaWx0ZXIuc2VsZWN0ZWRcIn1dLHN0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcmFkaW9fX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwicmFkaW9cIixcIm5hbWVcIjppdGVtLm5hbWV9LGRvbVByb3BzOntcInZhbHVlXCI6aXRlbS52YWx1ZSxcImNoZWNrZWRcIjpfdm0uX3EoX3ZtLmZpbHRlci5zZWxlY3RlZCxpdGVtLnZhbHVlKX0sb246e1wiY2hhbmdlXCI6W2Z1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS4kc2V0KF92bS5maWx0ZXIsIFwic2VsZWN0ZWRcIiwgaXRlbS52YWx1ZSl9LGZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS5vbkNoYW5nZShpdGVtKX1dfX0pLF92bS5fdihcIiBcIiksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXJhZGlvX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhpdGVtLmxhYmVsKSldKV0pfSksMCldKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8ZmllbGRzZXQgY2xhc3M9XCJtdWx0aWZpbHRlclwiXG4gICAgICAgICAgICA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiXG4gICAgICAgICAgICB2LWNsaWNrLW91dHNpZGU9XCJjbG9zZVwiPlxuICAgIDxidXR0b24gY2xhc3M9XCJtdWx0aWZpbHRlcl9fY29udGVudCBtdWx0aWZpbHRlcl9fY29udGVudF9kcm9wZG93blwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIEBjbGljay5wcmV2ZW50PVwidG9nZ2xlXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm11bHRpZmlsdGVyX192YWx1ZVwiPnt7IGZpbHRlci5sYWJlbCB9fTwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiXG4gICAgICAgICA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiPlxuICAgICAgPGxhYmVsIGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9cIiB2LWZvcj1cIml0ZW0gaW4gZmlsdGVyLmRhdGFcIj5cbiAgICAgICAgPGlucHV0IGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9fX2lucHV0XCJcbiAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICA6bmFtZT1cIml0ZW0ubmFtZVwiXG4gICAgICAgICAgICAgICA6dmFsdWU9XCJpdGVtLnZhbHVlXCJcbiAgICAgICAgICAgICAgIHYtbW9kZWw9XCJmaWx0ZXIuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlKGl0ZW0pXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9fX2xhYmVsXCI+e3sgaXRlbS5sYWJlbCB9fTwvc3Bhbj5cbiAgICAgIDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gIDwvZmllbGRzZXQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRHJvcGRvd24gZnJvbSAnLi8uLi9Ecm9wZG93bi52dWUnO1xuXG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiRmlsdGVyU2VsZWN0XCIsXG4gICAgY29tcG9uZW50czogeyBEcm9wZG93biB9LFxuICAgIHByb3BzOiB7XG4gICAgICBmaWx0ZXI6IE9iamVjdCxcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIG9uQ2hhbmdlKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5maWx0ZXIubGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSxcblxuICAgICAgb3BlbigpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICAgICAgfVxuICAgIH0sXG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9GaWx0ZXJTZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0ZpbHRlclNlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0ZpbHRlclNlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjVkYjdlMTgmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRmlsdGVyU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vRmlsdGVyU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiYjVkYjdlMThcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')},24:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterPrice.vue?vue&type=template&id=17759026&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'dropdown\',{staticClass:"multifilter"},[_c(\'template\',{slot:"btn"},[_c(\'span\',{staticClass:"multifilter__value"},[_vm._v(_vm._s(_vm.filter.label))])]),_vm._v(" "),_c(\'template\',{slot:"body"},[_c(\'MultifilterPrice\',{attrs:{"slider":_vm.filter.data},on:{"change":_vm.onChange,"update":_vm.onUpdate}})],1)],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterPrice.vue?vue&type=template&id=17759026&scoped=true&\n\n// EXTERNAL MODULE: ./src/js/components/catalog/MultifilterPrice.vue + 4 modules\nvar MultifilterPrice = __webpack_require__(26);\n\n// EXTERNAL MODULE: ./src/js/components/Dropdown.vue + 4 modules\nvar Dropdown = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterPrice.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ var FilterPricevue_type_script_lang_js_ = ({\n  name: \'FilterPrice\',\n  components: {\n    Dropdown: Dropdown["a" /* default */],\n    MultifilterPrice: MultifilterPrice["a" /* default */]\n  },\n  props: {\n    filter: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: {\n    onChange: function onChange() {\n      this.$store.dispatch(\'filters/onChange\');\n    },\n    onUpdate: function onUpdate(values) {\n      // console.log(e);\n      this.filter.data.minRange = values[0];\n      this.filter.data.maxRange = values[1];\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterPrice.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_FilterPricevue_type_script_lang_js_ = (FilterPricevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterPrice.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  catalog_FilterPricevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "17759026",\n  null\n  \n)\n\n/* harmony default export */ var FilterPrice = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlclByaWNlLnZ1ZT81YmRiIiwid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlclByaWNlLnZ1ZT84NjM1Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvRmlsdGVyUHJpY2UudnVlP2Y4YWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJQcmljZS52dWU/ZDVkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBCQUEwQixhQUFhLDBCQUEwQix3QkFBd0Isc0JBQXNCLDBCQUEwQixpQkFBaUIsV0FBVyxhQUFhLGlDQUFpQyxrRUFBa0UsWUFBWSx5QkFBeUIsT0FBTyx5QkFBeUIsS0FBSyw2Q0FBNkM7QUFDNVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNnQkE7QUFDQTtBQUdBO0FBQ0EscUJBREE7QUFFQTtBQUNBLHlDQURBO0FBRUE7QUFGQSxHQUZBO0FBTUE7QUFDQTtBQUNBLGtCQURBO0FBRUE7QUFGQTtBQURBLEdBTkE7QUFZQTtBQUNBLFlBREEsc0JBQ0E7QUFDQTtBQUNBLEtBSEE7QUFJQSxZQUpBLG9CQUlBLE1BSkEsRUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFaQSxHOztBQ3JCaU0sQ0FBZ0IsbUhBQUcsRUFBQyxDOzs7OztBQ0EvRztBQUN2QztBQUNMOzs7QUFHMUQ7QUFDZ0c7QUFDaEcsZ0JBQWdCLDhDQUFVO0FBQzFCLEVBQUUsMkNBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsNEYiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZHJvcGRvd24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyXCJ9LFtfYygndGVtcGxhdGUnLHtzbG90OlwiYnRuXCJ9LFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX3ZhbHVlXCJ9LFtfdm0uX3YoX3ZtLl9zKF92bS5maWx0ZXIubGFiZWwpKV0pXSksX3ZtLl92KFwiIFwiKSxfYygndGVtcGxhdGUnLHtzbG90OlwiYm9keVwifSxbX2MoJ011bHRpZmlsdGVyUHJpY2UnLHthdHRyczp7XCJzbGlkZXJcIjpfdm0uZmlsdGVyLmRhdGF9LG9uOntcImNoYW5nZVwiOl92bS5vbkNoYW5nZSxcInVwZGF0ZVwiOl92bS5vblVwZGF0ZX19KV0sMSldLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxkcm9wZG93biBjbGFzcz1cIm11bHRpZmlsdGVyXCI+XG4gICAgPHRlbXBsYXRlIHNsb3Q9XCJidG5cIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXJfX3ZhbHVlXCI+e3sgZmlsdGVyLmxhYmVsIH19PC9zcGFuPlxuICAgIDwvdGVtcGxhdGU+XG5cbiAgICA8dGVtcGxhdGUgc2xvdD1cImJvZHlcIj5cbiAgICAgIDxNdWx0aWZpbHRlclByaWNlXG4gICAgICAgIDpzbGlkZXI9XCJmaWx0ZXIuZGF0YVwiXG4gICAgICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXG4gICAgICAgIEB1cGRhdGU9XCJvblVwZGF0ZVwiXG4gICAgICAvPlxuICAgIDwvdGVtcGxhdGU+XG4gIDwvZHJvcGRvd24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE11bHRpZmlsdGVyUHJpY2UgZnJvbSAnLi9NdWx0aWZpbHRlclByaWNlLnZ1ZSc7XG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi4vRHJvcGRvd24udnVlJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdGaWx0ZXJQcmljZScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBEcm9wZG93bixcbiAgICBNdWx0aWZpbHRlclByaWNlLFxuICB9LFxuICBwcm9wczoge1xuICAgIGZpbHRlcjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICB9LFxuICAgIG9uVXBkYXRlKHZhbHVlcykge1xuICAgICAgLy8gY29uc29sZS5sb2coZSk7XG4gICAgICB0aGlzLmZpbHRlci5kYXRhLm1pblJhbmdlID0gdmFsdWVzWzBdO1xuICAgICAgdGhpcy5maWx0ZXIuZGF0YS5tYXhSYW5nZSA9IHZhbHVlc1sxXTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9GaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9GaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTc3NTkwMjYmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9GaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjE3NzU5MDI2XCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n')},25:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=template&id=92617c6c&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"multifilter-checkbox-list"},[(_vm.search && _vm.items.length > 9)?_c(\'div\',{staticClass:"multifilter-search"},[_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.searchQuery),expression:"searchQuery"}],staticClass:"multifilter-search__input",attrs:{"type":"search","placeholder":"Поиск","autocomplete":"off"},domProps:{"value":(_vm.searchQuery)},on:{"input":function($event){if($event.target.composing){ return; }_vm.searchQuery=$event.target.value}}})]):_vm._e(),_vm._v(" "),_vm._l((_vm.availableItems),function(item){return _c(\'MultifilterCheckbox\',{directives:[{name:"show",rawName:"v-show",value:(!item.hidden),expression:"!item.hidden"}],key:item.input.id,attrs:{"name":item.input.name,"disabled":false,"value":item.input.value},on:{"change":function($event){return _vm.$emit(\'change\', item.input)}},model:{value:(item.input.checked),callback:function ($$v) {_vm.$set(item.input, "checked", $$v)},expression:"item.input.checked"}},[_vm._v(_vm._s(item.input.label)+"\\n  ")])}),_vm._v(" "),(_vm.visibleNotAvailableItems.length)?_c(\'div\',{staticClass:"multifilter-delimiter"},[_c(\'span\',{staticClass:"multifilter-delimiter__text"},[_vm._v("Нет в наличии")])]):_vm._e(),_vm._v(" "),_vm._l((_vm.notAvailableItems),function(item){return _c(\'MultifilterCheckbox\',{directives:[{name:"show",rawName:"v-show",value:(!item.hidden),expression:"!item.hidden"}],key:item.input.id,attrs:{"name":item.input.name,"disabled":!item.input.checked,"value":item.input.value},on:{"change":function($event){return _vm.$emit(\'change\', item.input)}},model:{value:(item.input.checked),callback:function ($$v) {_vm.$set(item.input, "checked", $$v)},expression:"item.input.checked"}},[_vm._v(_vm._s(item.input.label)+"\\n  ")])})],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=template&id=92617c6c&\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=template&id=2173bc26&\nvar MultifilterCheckboxvue_type_template_id_2173bc26_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'label\',{staticClass:"multifilter-checkbox"},[_c(\'input\',_vm._b({staticClass:"multifilter-checkbox__input",attrs:{"type":"checkbox"},domProps:{"checked":_vm.checked},on:{"change":function($event){return _vm.$emit(\'change\', $event.target.checked)}}},\'input\',_vm.$attrs,false)),_vm._v(" "),_c(\'span\',{staticClass:"multifilter-checkbox__label"},[_vm._t("default")],2)])}\nvar MultifilterCheckboxvue_type_template_id_2173bc26_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=template&id=2173bc26&\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var MultifilterCheckboxvue_type_script_lang_js_ = ({\n  name: "MultifilterCheckbox",\n  inheritAttrs: false,\n  model: {\n    prop: \'checked\',\n    event: \'change\'\n  },\n  props: {\n    checked: {\n      default: false,\n      type: Boolean\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_MultifilterCheckboxvue_type_script_lang_js_ = (MultifilterCheckboxvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckbox.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  catalog_MultifilterCheckboxvue_type_script_lang_js_,\n  MultifilterCheckboxvue_type_template_id_2173bc26_render,\n  MultifilterCheckboxvue_type_template_id_2173bc26_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var MultifilterCheckbox = (component.exports);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n// import { mapGetters, mapState, mapActions } from \'vuex\'\n\n/* harmony default export */ var MultifilterCheckboxListvue_type_script_lang_js_ = ({\n  name: "MultifilterCheckboxList",\n  props: {\n    items: {\n      type: Array,\n      required: true\n    },\n    search: {\n      type: Boolean,\n      default: true\n    }\n  },\n  components: {\n    MultifilterCheckbox: MultifilterCheckbox\n  },\n  data: function data() {\n    return {\n      searchQuery: \'\'\n    };\n  },\n  computed: {\n    filtredItems: function filtredItems() {\n      var _this = this;\n\n      return this.items.map(function (item) {\n        return {\n          // ...item,\n          input: item,\n          hidden: item.hidden || _this.searchQuery && item.label.toLowerCase().indexOf(_this.searchQuery.toLowerCase()) === -1\n        };\n      });\n    },\n    availableItems: function availableItems() {\n      return this.filtredItems.filter(function (item) {\n        return item.input.available;\n      });\n    },\n    notAvailableItems: function notAvailableItems() {\n      return this.filtredItems.filter(function (item) {\n        return !item.input.available;\n      });\n    },\n    visibleNotAvailableItems: function visibleNotAvailableItems() {\n      return this.notAvailableItems.filter(function (item) {\n        return !item.hidden;\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_MultifilterCheckboxListvue_type_script_lang_js_ = (MultifilterCheckboxListvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue\n\n\n\n\n\n/* normalize component */\n\nvar MultifilterCheckboxList_component = Object(componentNormalizer["a" /* default */])(\n  catalog_MultifilterCheckboxListvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var MultifilterCheckboxList = __webpack_exports__["a"] = (MultifilterCheckboxList_component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyQ2hlY2tib3hMaXN0LnZ1ZT8yNzI3Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/MWM2YyIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9NdWx0aWZpbHRlckNoZWNrYm94LnZ1ZT84MGMzIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/OWY5ZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyQ2hlY2tib3gudnVlPzYwOTkiLCJ3ZWJwYWNrOi8vL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJDaGVja2JveExpc3QudnVlP2FiZmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/NjFlNyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyQ2hlY2tib3hMaXN0LnZ1ZT8zYmYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsd0NBQXdDLGlEQUFpRCxpQ0FBaUMsY0FBYyxhQUFhLGdGQUFnRixpREFBaUQsMkRBQTJELFdBQVcsMEJBQTBCLEtBQUsseUJBQXlCLDRCQUE0QixRQUFRLEVBQUUsc0NBQXNDLG9FQUFvRSxpQ0FBaUMsYUFBYSw0RUFBNEUsMkJBQTJCLGlFQUFpRSxLQUFLLDBCQUEwQix3Q0FBd0MsUUFBUSxvREFBb0QscUNBQXFDLGtDQUFrQyw0Q0FBNEMsOERBQThELG9DQUFvQyxhQUFhLDBDQUEwQyxpR0FBaUcsaUNBQWlDLGFBQWEsNEVBQTRFLDJCQUEyQiwrRUFBK0UsS0FBSywwQkFBMEIsd0NBQXdDLFFBQVEsb0RBQW9ELHFDQUFxQyxrQ0FBa0MsNENBQTRDO0FBQzl5RDs7Ozs7O0FDREEsSUFBSSx1REFBTSxnQkFBZ0IsYUFBYSwwQkFBMEIsd0JBQXdCLG1CQUFtQixtQ0FBbUMscUJBQXFCLGlEQUFpRCxrQkFBa0IsV0FBVyxzQkFBc0IsS0FBSywwQkFBMEIsb0RBQW9ELG1EQUFtRCwwQ0FBMEM7QUFDeGIsSUFBSSxnRUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNXbkI7QUFDQSw2QkFEQTtBQUVBLHFCQUZBO0FBR0E7QUFDQSxtQkFEQTtBQUVBO0FBRkEsR0FIQTtBQU9BO0FBQ0E7QUFDQSxvQkFEQTtBQUVBO0FBRkE7QUFEQTtBQVBBLEc7O0FDWnlNLENBQWdCLG1JQUFHLEVBQUMsQzs7Ozs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBR2xFO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLG1EQUFNO0FBQ1IsRUFBRSx1REFBTTtBQUNSLEVBQUUsZ0VBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUseUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNrQmY7QUFDQTtBQUdBO0FBQ0EsaUNBREE7QUFFQTtBQUNBO0FBQ0EsaUJBREE7QUFFQTtBQUZBLEtBREE7QUFLQTtBQUNBLG1CQURBO0FBRUE7QUFGQTtBQUxBLEdBRkE7QUFZQTtBQUNBO0FBREEsR0FaQTtBQWVBLE1BZkEsa0JBZUE7QUFDQTtBQUNBO0FBREE7QUFHQSxHQW5CQTtBQW9CQTtBQUNBLGdCQURBLDBCQUNBO0FBQUE7O0FBQ0E7QUFBQTtBQUNBO0FBQ0EscUJBRkE7QUFHQSwrRUFDQSxPQURBLENBQ0EsK0JBREEsTUFDQTtBQUpBO0FBQUE7QUFNQSxLQVJBO0FBU0Esa0JBVEEsNEJBU0E7QUFDQTtBQUFBO0FBQUE7QUFDQSxLQVhBO0FBWUEscUJBWkEsK0JBWUE7QUFDQTtBQUFBO0FBQUE7QUFDQSxLQWRBO0FBZUEsNEJBZkEsc0NBZUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWpCQTtBQXBCQSxHOztBQ3hDNk0sQ0FBZ0IsMklBQUcsRUFBQyxDOztBQ0EzSDtBQUMzQjtBQUNMOzs7QUFHdEU7QUFDZ0c7QUFDaEcsSUFBSSxpQ0FBUyxHQUFHLDhDQUFVO0FBQzFCLEVBQUUsdURBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsd0hBQVMsUSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLWNoZWNrYm94LWxpc3RcIn0sWyhfdm0uc2VhcmNoICYmIF92bS5pdGVtcy5sZW5ndGggPiA5KT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1zZWFyY2hcIn0sW19jKCdpbnB1dCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwibW9kZWxcIixyYXdOYW1lOlwidi1tb2RlbFwiLHZhbHVlOihfdm0uc2VhcmNoUXVlcnkpLGV4cHJlc3Npb246XCJzZWFyY2hRdWVyeVwifV0sc3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1zZWFyY2hfX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwic2VhcmNoXCIsXCJwbGFjZWhvbGRlclwiOlwi0J/QvtC40YHQulwiLFwiYXV0b2NvbXBsZXRlXCI6XCJvZmZcIn0sZG9tUHJvcHM6e1widmFsdWVcIjooX3ZtLnNlYXJjaFF1ZXJ5KX0sb246e1wiaW5wdXRcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXsgcmV0dXJuOyB9X3ZtLnNlYXJjaFF1ZXJ5PSRldmVudC50YXJnZXQudmFsdWV9fX0pXSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfdm0uX2woKF92bS5hdmFpbGFibGVJdGVtcyksZnVuY3Rpb24oaXRlbSl7cmV0dXJuIF9jKCdNdWx0aWZpbHRlckNoZWNrYm94Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOighaXRlbS5oaWRkZW4pLGV4cHJlc3Npb246XCIhaXRlbS5oaWRkZW5cIn1dLGtleTppdGVtLmlucHV0LmlkLGF0dHJzOntcIm5hbWVcIjppdGVtLmlucHV0Lm5hbWUsXCJkaXNhYmxlZFwiOmZhbHNlLFwidmFsdWVcIjppdGVtLmlucHV0LnZhbHVlfSxvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uJGVtaXQoJ2NoYW5nZScsIGl0ZW0uaW5wdXQpfX0sbW9kZWw6e3ZhbHVlOihpdGVtLmlucHV0LmNoZWNrZWQpLGNhbGxiYWNrOmZ1bmN0aW9uICgkJHYpIHtfdm0uJHNldChpdGVtLmlucHV0LCBcImNoZWNrZWRcIiwgJCR2KX0sZXhwcmVzc2lvbjpcIml0ZW0uaW5wdXQuY2hlY2tlZFwifX0sW192bS5fdihfdm0uX3MoaXRlbS5pbnB1dC5sYWJlbCkrXCJcXG4gIFwiKV0pfSksX3ZtLl92KFwiIFwiKSwoX3ZtLnZpc2libGVOb3RBdmFpbGFibGVJdGVtcy5sZW5ndGgpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLWRlbGltaXRlclwifSxbX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLWRlbGltaXRlcl9fdGV4dFwifSxbX3ZtLl92KFwi0J3QtdGCINCyINC90LDQu9C40YfQuNC4XCIpXSldKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLF92bS5fbCgoX3ZtLm5vdEF2YWlsYWJsZUl0ZW1zKSxmdW5jdGlvbihpdGVtKXtyZXR1cm4gX2MoJ011bHRpZmlsdGVyQ2hlY2tib3gnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KCFpdGVtLmhpZGRlbiksZXhwcmVzc2lvbjpcIiFpdGVtLmhpZGRlblwifV0sa2V5Oml0ZW0uaW5wdXQuaWQsYXR0cnM6e1wibmFtZVwiOml0ZW0uaW5wdXQubmFtZSxcImRpc2FibGVkXCI6IWl0ZW0uaW5wdXQuY2hlY2tlZCxcInZhbHVlXCI6aXRlbS5pbnB1dC52YWx1ZX0sb246e1wiY2hhbmdlXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLiRlbWl0KCdjaGFuZ2UnLCBpdGVtLmlucHV0KX19LG1vZGVsOnt2YWx1ZTooaXRlbS5pbnB1dC5jaGVja2VkKSxjYWxsYmFjazpmdW5jdGlvbiAoJCR2KSB7X3ZtLiRzZXQoaXRlbS5pbnB1dCwgXCJjaGVja2VkXCIsICQkdil9LGV4cHJlc3Npb246XCJpdGVtLmlucHV0LmNoZWNrZWRcIn19LFtfdm0uX3YoX3ZtLl9zKGl0ZW0uaW5wdXQubGFiZWwpK1wiXFxuICBcIildKX0pXSwyKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2xhYmVsJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1jaGVja2JveFwifSxbX2MoJ2lucHV0Jyxfdm0uX2Ioe3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwiY2hlY2tib3hcIn0sZG9tUHJvcHM6e1wiY2hlY2tlZFwiOl92bS5jaGVja2VkfSxvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uJGVtaXQoJ2NoYW5nZScsICRldmVudC50YXJnZXQuY2hlY2tlZCl9fX0sJ2lucHV0Jyxfdm0uJGF0dHJzLGZhbHNlKSksX3ZtLl92KFwiIFwiKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2xhYmVsXCJ9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKV0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxsYWJlbCBjbGFzcz1cIm11bHRpZmlsdGVyLWNoZWNrYm94XCI+XG4gICAgPGlucHV0IGNsYXNzPVwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2lucHV0XCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICB2LWJpbmQ9XCIkYXR0cnNcIlxuICAgICAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkXCJcbiAgICAgICAgICAgIEBjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgJGV2ZW50LnRhcmdldC5jaGVja2VkKVwiPlxuICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2xhYmVsXCI+PHNsb3Q+PC9zbG90Pjwvc3Bhbj5cbiAgPC9sYWJlbD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiBcIk11bHRpZmlsdGVyQ2hlY2tib3hcIixcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIG1vZGVsOiB7XG4gICAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBjaGVja2VkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgfSxcbiAgICB9LFxuICB9XG48L3NjcmlwdD5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL011bHRpZmlsdGVyQ2hlY2tib3gudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIxNzNiYzI2JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL011bHRpZmlsdGVyQ2hlY2tib3gudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NdWx0aWZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItY2hlY2tib3gtbGlzdFwiPlxuICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1zZWFyY2hcIiB2LWlmPVwic2VhcmNoICYmIGl0ZW1zLmxlbmd0aCA+IDlcIj5cbiAgICAgIDxpbnB1dCBjbGFzcz1cIm11bHRpZmlsdGVyLXNlYXJjaF9faW5wdXRcIiB0eXBlPVwic2VhcmNoXCIgcGxhY2Vob2xkZXI9XCLQn9C+0LjRgdC6XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgdi1tb2RlbD1cInNlYXJjaFF1ZXJ5XCI+XG4gICAgPC9kaXY+XG4gICAgPE11bHRpZmlsdGVyQ2hlY2tib3hcbiAgICAgIHYtZm9yPVwiaXRlbSBpbiBhdmFpbGFibGVJdGVtc1wiXG4gICAgICA6a2V5PVwiaXRlbS5pbnB1dC5pZFwiXG4gICAgICB2LXNob3c9XCIhaXRlbS5oaWRkZW5cIlxuICAgICAgdi1tb2RlbD1cIml0ZW0uaW5wdXQuY2hlY2tlZFwiXG4gICAgICA6bmFtZT1cIml0ZW0uaW5wdXQubmFtZVwiXG4gICAgICA6ZGlzYWJsZWQ9XCJmYWxzZVwiXG4gICAgICA6dmFsdWU9XCJpdGVtLmlucHV0LnZhbHVlXCJcbiAgICAgIEBjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgaXRlbS5pbnB1dClcIlxuICAgID57e2l0ZW0uaW5wdXQubGFiZWx9fVxuICAgIDwvTXVsdGlmaWx0ZXJDaGVja2JveD5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItZGVsaW1pdGVyXCIgdi1pZj1cInZpc2libGVOb3RBdmFpbGFibGVJdGVtcy5sZW5ndGhcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXItZGVsaW1pdGVyX190ZXh0XCI+0J3QtdGCINCyINC90LDQu9C40YfQuNC4PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxNdWx0aWZpbHRlckNoZWNrYm94XG4gICAgICB2LWZvcj1cIml0ZW0gaW4gbm90QXZhaWxhYmxlSXRlbXNcIlxuICAgICAgOmtleT1cIml0ZW0uaW5wdXQuaWRcIlxuICAgICAgdi1zaG93PVwiIWl0ZW0uaGlkZGVuXCJcbiAgICAgIHYtbW9kZWw9XCJpdGVtLmlucHV0LmNoZWNrZWRcIlxuICAgICAgOm5hbWU9XCJpdGVtLmlucHV0Lm5hbWVcIlxuICAgICAgOmRpc2FibGVkPVwiIWl0ZW0uaW5wdXQuY2hlY2tlZFwiXG4gICAgICA6dmFsdWU9XCJpdGVtLmlucHV0LnZhbHVlXCJcbiAgICAgIEBjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgaXRlbS5pbnB1dClcIlxuICAgID57e2l0ZW0uaW5wdXQubGFiZWx9fVxuICAgIDwvTXVsdGlmaWx0ZXJDaGVja2JveD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAvLyBpbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwQWN0aW9ucyB9IGZyb20gJ3Z1ZXgnXG4gIGltcG9ydCBNdWx0aWZpbHRlckNoZWNrYm94IGZyb20gJy4vTXVsdGlmaWx0ZXJDaGVja2JveC52dWUnO1xuXG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiTXVsdGlmaWx0ZXJDaGVja2JveExpc3RcIixcbiAgICBwcm9wczoge1xuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHNlYXJjaDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgTXVsdGlmaWx0ZXJDaGVja2JveCxcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWFyY2hRdWVyeTogJycsXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZmlsdHJlZEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgIC8vIC4uLml0ZW0sXG4gICAgICAgICAgaW5wdXQ6IGl0ZW0sXG4gICAgICAgICAgaGlkZGVuOiBpdGVtLmhpZGRlbiB8fCAodGhpcy5zZWFyY2hRdWVyeSAmJiBpdGVtLmxhYmVsLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5pbmRleE9mKHRoaXMuc2VhcmNoUXVlcnkudG9Mb3dlckNhc2UoKSkgPT09IC0xKSxcbiAgICAgICAgfSkpXG4gICAgICB9LFxuICAgICAgYXZhaWxhYmxlSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRyZWRJdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmlucHV0LmF2YWlsYWJsZSlcbiAgICAgIH0sXG4gICAgICBub3RBdmFpbGFibGVJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdHJlZEl0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmlucHV0LmF2YWlsYWJsZSlcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlTm90QXZhaWxhYmxlSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdEF2YWlsYWJsZUl0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmhpZGRlbilcbiAgICAgIH0sXG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPCEtLTxzdHlsZSBzY29wZWQ+LS0+XG5cbjwhLS08L3N0eWxlPi0tPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJDaGVja2JveExpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OTI2MTdjNmMmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vTXVsdGlmaWx0ZXJDaGVja2JveExpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n')},26:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterPrice.vue?vue&type=template&id=730447f8&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"multifilter-price\"},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.minRange),expression:\"minRange\"}],attrs:{\"type\":\"hidden\",\"name\":\"price[from]\"},domProps:{\"value\":(_vm.minRange)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.minRange=$event.target.value}}}),_vm._v(\" \"),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.maxRange),expression:\"maxRange\"}],attrs:{\"type\":\"hidden\",\"name\":\"price[to]\"},domProps:{\"value\":(_vm.maxRange)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.maxRange=$event.target.value}}}),_vm._v(\" \"),_vm._m(0),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__range\"},[_c('div',{ref:\"slider\",staticClass:\"input-range\"})]),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__num\"},[_c('div',{staticClass:\"multifilter-price__start\"},[_vm._v(_vm._s(_vm.slider.priceMin)+\" ₽\")]),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__end\"},[_vm._v(_vm._s(_vm.slider.priceMax)+\" ₽\")])])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"multifilter-price__title\"},[_c('div',{staticClass:\"multifilter-price__start\"},[_vm._v(\"От\")]),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__end\"},[_vm._v(\"До\")])])}]\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterPrice.vue?vue&type=template&id=730447f8&\n\n// EXTERNAL MODULE: ./node_modules/nouislider/distribute/nouislider.js\nvar nouislider = __webpack_require__(43);\nvar nouislider_default = /*#__PURE__*/__webpack_require__.n(nouislider);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterPrice.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n // import Dropdown from './Dropdown.vue';\n\n/* harmony default export */ var MultifilterPricevue_type_script_lang_js_ = ({\n  name: 'MultifilterPrice',\n  // components: {\n  //   Dropdown,\n  // },\n  props: {\n    slider: {\n      type: Object,\n      default: null\n    }\n  },\n  data: function data() {\n    return {\n      callback: true,\n      minRange: null,\n      maxRange: null // slider: {\n      //   priceFrom: 0,\n      //   priceTo: 2740,\n      //   priceMin: 0,\n      //   priceMax: 2740,\n      // }\n\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    nouislider_default.a.create(this.$refs.slider, {\n      start: [this.slider.priceFrom, this.slider.priceTo],\n      // start: [this.slider.priceMin, this.slider.priceMax],\n      step: 1,\n      connect: true,\n      tooltips: true,\n      range: {\n        min: this.slider.priceMin,\n        max: this.slider.priceMax\n      },\n      format: {\n        to: function to(value) {\n          return \"\".concat(Math.floor(value), \" \\u20BD\");\n        },\n        from: function from(value) {\n          return value.replace(/[^0-9]/g, '');\n        }\n      },\n      cssPrefix: 'input-range',\n      cssClasses: {\n        target: '',\n        base: '__base',\n        origin: '__origin',\n        handle: '__handle',\n        handleLower: '__handle-lower',\n        handleUpper: '__handle-upper',\n        touchArea: '__touch-area',\n        horizontal: '_horizontal',\n        vertical: '_vertical',\n        background: '__background',\n        connect: '__connect',\n        connects: '__connects',\n        ltr: '_ltr',\n        rtl: '_rtl',\n        draggable: '_draggable',\n        drag: '_state-drag',\n        tap: '_state-tap',\n        active: '__active',\n        tooltip: '__tooltip',\n        // Шкала\n        pips: '__pips',\n        pipsHorizontal: '__pips_horizontal',\n        pipsVertical: '__pips_vertical',\n        // Деления на шкале\n        marker: '__marker',\n        markerHorizontal: '__marker_horizontal',\n        markerVertical: '__marker_vertical',\n        markerNormal: '__marker_normal',\n        markerLarge: '__marker_large',\n        markerSub: '__marker_sub',\n        // Значения на шкале\n        value: '__value',\n        valueHorizontal: '__value_horizontal',\n        valueVertical: '__value_vertical',\n        valueNormal: '__value_normal',\n        valueLarge: '__value_large',\n        valueSub: '__value_sub'\n      }\n    }); // this.$refs.slider.noUiSlider.set([this.slider.priceFrom, this.slider.priceTo]);\n\n    this.$refs.slider.noUiSlider.on('update', function (values, handle) {\n      var t = parseInt(values[handle]);\n      _this[handle ? 'maxRange' : 'minRange'] = t !== _this.slider[handle ? 'priceMax' : 'priceMin'] ? t : '';\n\n      _this.$emit('update', [_this.minRange, _this.maxRange]); // console.log([this.minRange, this.maxRange], handle);\n\n    });\n    this.$refs.slider.noUiSlider.on('set', function () {\n      if (_this.callback) {\n        // this.$root.$emit('filter:change');\n        _this.$emit('change'); // this.$store.dispatch('filters/filterChange');\n\n      }\n    }, 100); // this.$store.subscribeAction((action, state) => {\n    //   console.log(action.type);\n    //   console.log(action.payload);\n    // });\n\n    this.$root.$on('filter:reset', function () {\n      _this.callback = false; // this.$refs.slider.noUiSlider.reset();\n\n      _this.$refs.slider.noUiSlider.set([_this.slider.priceMin, _this.slider.priceMax]);\n\n      _this.callback = true;\n    }); // this.rangeEl.noUiSlider.on('set', this.onChange, 100);\n  },\n  methods: {}\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterPrice.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_MultifilterPricevue_type_script_lang_js_ = (MultifilterPricevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterPrice.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  catalog_MultifilterPricevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var MultifilterPrice = __webpack_exports__[\"a\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyUHJpY2UudnVlPzg2OGQiLCJ3ZWJwYWNrOi8vL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJQcmljZS52dWU/YTI5MSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyUHJpY2UudnVlP2Y3ODEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9NdWx0aWZpbHRlclByaWNlLnZ1ZT83MmNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsZ0NBQWdDLGNBQWMsYUFBYSwwRUFBMEUsU0FBUyxxQ0FBcUMsV0FBVyx1QkFBdUIsS0FBSyx5QkFBeUIsNEJBQTRCLFFBQVEsRUFBRSxtQ0FBbUMsMEJBQTBCLGFBQWEsMEVBQTBFLFNBQVMsbUNBQW1DLFdBQVcsdUJBQXVCLEtBQUsseUJBQXlCLDRCQUE0QixRQUFRLEVBQUUsbUNBQW1DLDhDQUE4Qyx1Q0FBdUMsWUFBWSx1Q0FBdUMsMEJBQTBCLHFDQUFxQyxZQUFZLHVDQUF1QyxtRUFBbUUscUNBQXFDO0FBQzlpQyxvQ0FBb0MsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQix1Q0FBdUMsWUFBWSx1Q0FBdUMsdUNBQXVDLHFDQUFxQyxtQkFBbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0NtQjdTOztBQUVBO0FBQ0EsMEJBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBREE7QUFFQTtBQUZBO0FBREEsR0FMQTtBQVdBLE1BWEEsa0JBV0E7QUFDQTtBQUNBLG9CQURBO0FBRUEsb0JBRkE7QUFHQSxvQkFIQSxDQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVdBLEdBdkJBO0FBd0JBLFNBeEJBLHFCQXdCQTtBQUFBOztBQUNBO0FBQ0EseURBREE7QUFFQTtBQUNBLGFBSEE7QUFJQSxtQkFKQTtBQUtBLG9CQUxBO0FBTUE7QUFDQSxpQ0FEQTtBQUVBO0FBRkEsT0FOQTtBQVVBO0FBQ0EsVUFEQSxjQUNBLEtBREEsRUFDQTtBQUNBO0FBQ0EsU0FIQTtBQUlBLFlBSkEsZ0JBSUEsS0FKQSxFQUlBO0FBQ0E7QUFDQTtBQU5BLE9BVkE7QUFrQkEsOEJBbEJBO0FBbUJBO0FBQ0Esa0JBREE7QUFFQSxzQkFGQTtBQUdBLDBCQUhBO0FBSUEsMEJBSkE7QUFLQSxxQ0FMQTtBQU1BLHFDQU5BO0FBT0EsaUNBUEE7QUFRQSxpQ0FSQTtBQVNBLDZCQVRBO0FBVUEsa0NBVkE7QUFXQSw0QkFYQTtBQVlBLDhCQVpBO0FBYUEsbUJBYkE7QUFjQSxtQkFkQTtBQWVBLCtCQWZBO0FBZ0JBLDJCQWhCQTtBQWlCQSx5QkFqQkE7QUFrQkEsMEJBbEJBO0FBbUJBLDRCQW5CQTtBQXFCQTtBQUNBLHNCQXRCQTtBQXVCQSwyQ0F2QkE7QUF3QkEsdUNBeEJBO0FBMEJBO0FBQ0EsMEJBM0JBO0FBNEJBLCtDQTVCQTtBQTZCQSwyQ0E3QkE7QUE4QkEsdUNBOUJBO0FBK0JBLHFDQS9CQTtBQWdDQSxpQ0FoQ0E7QUFrQ0E7QUFDQSx3QkFuQ0E7QUFvQ0EsNkNBcENBO0FBcUNBLHlDQXJDQTtBQXNDQSxxQ0F0Q0E7QUF1Q0EsbUNBdkNBO0FBd0NBO0FBeENBO0FBbkJBLE9BREEsQ0FnRUE7O0FBR0E7QUFDQTtBQUNBLGdEQUNBLDZEQURBOztBQUdBLDhEQUxBLENBTUE7O0FBQ0EsS0FQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBLDhCQUZBLENBR0E7O0FBQ0E7QUFDQSxLQU5BLEVBTUEsR0FOQSxFQTVFQSxDQW9GQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQURBLENBRUE7O0FBQ0E7O0FBQ0E7QUFDQSxLQUxBLEVBekZBLENBZ0dBO0FBQ0EsR0F6SEE7QUEwSEE7QUExSEEsRzs7QUN0QnNNLENBQWdCLDZIQUFHLEVBQUMsQzs7Ozs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBRy9EO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLGdEQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLGlHIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcHJpY2VcIn0sW19jKCdpbnB1dCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwibW9kZWxcIixyYXdOYW1lOlwidi1tb2RlbFwiLHZhbHVlOihfdm0ubWluUmFuZ2UpLGV4cHJlc3Npb246XCJtaW5SYW5nZVwifV0sYXR0cnM6e1widHlwZVwiOlwiaGlkZGVuXCIsXCJuYW1lXCI6XCJwcmljZVtmcm9tXVwifSxkb21Qcm9wczp7XCJ2YWx1ZVwiOihfdm0ubWluUmFuZ2UpfSxvbjp7XCJpbnB1dFwiOmZ1bmN0aW9uKCRldmVudCl7aWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpeyByZXR1cm47IH1fdm0ubWluUmFuZ2U9JGV2ZW50LnRhcmdldC52YWx1ZX19fSksX3ZtLl92KFwiIFwiKSxfYygnaW5wdXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLm1heFJhbmdlKSxleHByZXNzaW9uOlwibWF4UmFuZ2VcIn1dLGF0dHJzOntcInR5cGVcIjpcImhpZGRlblwiLFwibmFtZVwiOlwicHJpY2VbdG9dXCJ9LGRvbVByb3BzOntcInZhbHVlXCI6KF92bS5tYXhSYW5nZSl9LG9uOntcImlucHV0XCI6ZnVuY3Rpb24oJGV2ZW50KXtpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZyl7IHJldHVybjsgfV92bS5tYXhSYW5nZT0kZXZlbnQudGFyZ2V0LnZhbHVlfX19KSxfdm0uX3YoXCIgXCIpLF92bS5fbSgwKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXByaWNlX19yYW5nZVwifSxbX2MoJ2Rpdicse3JlZjpcInNsaWRlclwiLHN0YXRpY0NsYXNzOlwiaW5wdXQtcmFuZ2VcIn0pXSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fbnVtXCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fc3RhcnRcIn0sW192bS5fdihfdm0uX3MoX3ZtLnNsaWRlci5wcmljZU1pbikrXCIg4oK9XCIpXSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fZW5kXCJ9LFtfdm0uX3YoX3ZtLl9zKF92bS5zbGlkZXIucHJpY2VNYXgpK1wiIOKCvVwiKV0pXSldKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fdGl0bGVcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXByaWNlX19zdGFydFwifSxbX3ZtLl92KFwi0J7RglwiKV0pLF92bS5fdihcIiBcIiksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcHJpY2VfX2VuZFwifSxbX3ZtLl92KFwi0JTQvlwiKV0pXSl9XVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VcIj5cbiAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJwcmljZVtmcm9tXVwiIHYtbW9kZWw9XCJtaW5SYW5nZVwiPlxuICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInByaWNlW3RvXVwiIHYtbW9kZWw9XCJtYXhSYW5nZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1wcmljZV9fdGl0bGVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1wcmljZV9fc3RhcnRcIj7QntGCPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VfX2VuZFwiPtCU0L48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VfX3JhbmdlXCI+XG4gICAgICA8ZGl2IHJlZj1cInNsaWRlclwiIGNsYXNzPVwiaW5wdXQtcmFuZ2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VfX251bVwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm11bHRpZmlsdGVyLXByaWNlX19zdGFydFwiPnt7IHNsaWRlci5wcmljZU1pbiB9fSDigr08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1wcmljZV9fZW5kXCI+e3sgc2xpZGVyLnByaWNlTWF4IH19IOKCvTwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgbm9VaVNsaWRlciBmcm9tICdub3Vpc2xpZGVyJztcbi8vIGltcG9ydCBEcm9wZG93biBmcm9tICcuL0Ryb3Bkb3duLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ011bHRpZmlsdGVyUHJpY2UnLFxuICAvLyBjb21wb25lbnRzOiB7XG4gIC8vICAgRHJvcGRvd24sXG4gIC8vIH0sXG4gIHByb3BzOiB7XG4gICAgc2xpZGVyOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgIH0sXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGxiYWNrOiB0cnVlLFxuICAgICAgbWluUmFuZ2U6IG51bGwsXG4gICAgICBtYXhSYW5nZTogbnVsbCxcbiAgICAgIC8vIHNsaWRlcjoge1xuICAgICAgLy8gICBwcmljZUZyb206IDAsXG4gICAgICAvLyAgIHByaWNlVG86IDI3NDAsXG4gICAgICAvLyAgIHByaWNlTWluOiAwLFxuICAgICAgLy8gICBwcmljZU1heDogMjc0MCxcbiAgICAgIC8vIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgbm9VaVNsaWRlci5jcmVhdGUodGhpcy4kcmVmcy5zbGlkZXIsIHtcbiAgICAgIHN0YXJ0OiBbdGhpcy5zbGlkZXIucHJpY2VGcm9tLCB0aGlzLnNsaWRlci5wcmljZVRvXSxcbiAgICAgIC8vIHN0YXJ0OiBbdGhpcy5zbGlkZXIucHJpY2VNaW4sIHRoaXMuc2xpZGVyLnByaWNlTWF4XSxcbiAgICAgIHN0ZXA6IDEsXG4gICAgICBjb25uZWN0OiB0cnVlLFxuICAgICAgdG9vbHRpcHM6IHRydWUsXG4gICAgICByYW5nZToge1xuICAgICAgICBtaW46IHRoaXMuc2xpZGVyLnByaWNlTWluLFxuICAgICAgICBtYXg6IHRoaXMuc2xpZGVyLnByaWNlTWF4LFxuICAgICAgfSxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICB0byh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBgJHtNYXRoLmZsb29yKHZhbHVlKX0g4oK9YDtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXjAtOV0vZywgJycpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGNzc1ByZWZpeDogJ2lucHV0LXJhbmdlJyxcbiAgICAgIGNzc0NsYXNzZXM6IHtcbiAgICAgICAgdGFyZ2V0OiAnJyxcbiAgICAgICAgYmFzZTogJ19fYmFzZScsXG4gICAgICAgIG9yaWdpbjogJ19fb3JpZ2luJyxcbiAgICAgICAgaGFuZGxlOiAnX19oYW5kbGUnLFxuICAgICAgICBoYW5kbGVMb3dlcjogJ19faGFuZGxlLWxvd2VyJyxcbiAgICAgICAgaGFuZGxlVXBwZXI6ICdfX2hhbmRsZS11cHBlcicsXG4gICAgICAgIHRvdWNoQXJlYTogJ19fdG91Y2gtYXJlYScsXG4gICAgICAgIGhvcml6b250YWw6ICdfaG9yaXpvbnRhbCcsXG4gICAgICAgIHZlcnRpY2FsOiAnX3ZlcnRpY2FsJyxcbiAgICAgICAgYmFja2dyb3VuZDogJ19fYmFja2dyb3VuZCcsXG4gICAgICAgIGNvbm5lY3Q6ICdfX2Nvbm5lY3QnLFxuICAgICAgICBjb25uZWN0czogJ19fY29ubmVjdHMnLFxuICAgICAgICBsdHI6ICdfbHRyJyxcbiAgICAgICAgcnRsOiAnX3J0bCcsXG4gICAgICAgIGRyYWdnYWJsZTogJ19kcmFnZ2FibGUnLFxuICAgICAgICBkcmFnOiAnX3N0YXRlLWRyYWcnLFxuICAgICAgICB0YXA6ICdfc3RhdGUtdGFwJyxcbiAgICAgICAgYWN0aXZlOiAnX19hY3RpdmUnLFxuICAgICAgICB0b29sdGlwOiAnX190b29sdGlwJyxcblxuICAgICAgICAvLyDQqNC60LDQu9CwXG4gICAgICAgIHBpcHM6ICdfX3BpcHMnLFxuICAgICAgICBwaXBzSG9yaXpvbnRhbDogJ19fcGlwc19ob3Jpem9udGFsJyxcbiAgICAgICAgcGlwc1ZlcnRpY2FsOiAnX19waXBzX3ZlcnRpY2FsJyxcblxuICAgICAgICAvLyDQlNC10LvQtdC90LjRjyDQvdCwINGI0LrQsNC70LVcbiAgICAgICAgbWFya2VyOiAnX19tYXJrZXInLFxuICAgICAgICBtYXJrZXJIb3Jpem9udGFsOiAnX19tYXJrZXJfaG9yaXpvbnRhbCcsXG4gICAgICAgIG1hcmtlclZlcnRpY2FsOiAnX19tYXJrZXJfdmVydGljYWwnLFxuICAgICAgICBtYXJrZXJOb3JtYWw6ICdfX21hcmtlcl9ub3JtYWwnLFxuICAgICAgICBtYXJrZXJMYXJnZTogJ19fbWFya2VyX2xhcmdlJyxcbiAgICAgICAgbWFya2VyU3ViOiAnX19tYXJrZXJfc3ViJyxcblxuICAgICAgICAvLyDQl9C90LDRh9C10L3QuNGPINC90LAg0YjQutCw0LvQtVxuICAgICAgICB2YWx1ZTogJ19fdmFsdWUnLFxuICAgICAgICB2YWx1ZUhvcml6b250YWw6ICdfX3ZhbHVlX2hvcml6b250YWwnLFxuICAgICAgICB2YWx1ZVZlcnRpY2FsOiAnX192YWx1ZV92ZXJ0aWNhbCcsXG4gICAgICAgIHZhbHVlTm9ybWFsOiAnX192YWx1ZV9ub3JtYWwnLFxuICAgICAgICB2YWx1ZUxhcmdlOiAnX192YWx1ZV9sYXJnZScsXG4gICAgICAgIHZhbHVlU3ViOiAnX192YWx1ZV9zdWInLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIHRoaXMuJHJlZnMuc2xpZGVyLm5vVWlTbGlkZXIuc2V0KFt0aGlzLnNsaWRlci5wcmljZUZyb20sIHRoaXMuc2xpZGVyLnByaWNlVG9dKTtcblxuXG4gICAgdGhpcy4kcmVmcy5zbGlkZXIubm9VaVNsaWRlci5vbigndXBkYXRlJywgKHZhbHVlcywgaGFuZGxlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gcGFyc2VJbnQodmFsdWVzW2hhbmRsZV0pO1xuICAgICAgdGhpc1toYW5kbGUgPyAnbWF4UmFuZ2UnIDogJ21pblJhbmdlJ11cbiAgICAgICAgPSAodCAhPT0gdGhpcy5zbGlkZXJbaGFuZGxlID8gJ3ByaWNlTWF4JyA6ICdwcmljZU1pbiddKSA/IHQgOiAnJztcblxuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlJywgW3RoaXMubWluUmFuZ2UsIHRoaXMubWF4UmFuZ2VdKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFt0aGlzLm1pblJhbmdlLCB0aGlzLm1heFJhbmdlXSwgaGFuZGxlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHJlZnMuc2xpZGVyLm5vVWlTbGlkZXIub24oJ3NldCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHRoaXMuJHJvb3QuJGVtaXQoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgIC8vIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL2ZpbHRlckNoYW5nZScpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG5cbiAgICAvLyB0aGlzLiRzdG9yZS5zdWJzY3JpYmVBY3Rpb24oKGFjdGlvbiwgc3RhdGUpID0+IHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGFjdGlvbi50eXBlKTtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAvLyB9KTtcblxuICAgIHRoaXMuJHJvb3QuJG9uKCdmaWx0ZXI6cmVzZXQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gZmFsc2U7XG4gICAgICAvLyB0aGlzLiRyZWZzLnNsaWRlci5ub1VpU2xpZGVyLnJlc2V0KCk7XG4gICAgICB0aGlzLiRyZWZzLnNsaWRlci5ub1VpU2xpZGVyLnNldChbdGhpcy5zbGlkZXIucHJpY2VNaW4sIHRoaXMuc2xpZGVyLnByaWNlTWF4XSk7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMucmFuZ2VFbC5ub1VpU2xpZGVyLm9uKCdzZXQnLCB0aGlzLm9uQ2hhbmdlLCAxMDApO1xuICB9LFxuICBtZXRob2RzOiB7fVxufVxuPC9zY3JpcHQ+XG5cbjwhLS08c3R5bGUgc2NvcGVkPi0tPlxuXG48IS0tPC9zdHlsZT4tLT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL011bHRpZmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTczMDQ0N2Y4JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL011bHRpZmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NdWx0aWZpbHRlclByaWNlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n")},262:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var domready__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var domready__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(domready__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _simple__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47);\n/* harmony import */ var _js_page_vendors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(172);\n\n\n\n\nif (false) {}\n\ndomready__WEBPACK_IMPORTED_MODULE_0___default()(function () {\n  global.PageVendors = new _js_page_vendors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9ycy5qcz9kNmY0Il0sIm5hbWVzIjpbInByb2Nlc3MiLCJyZWFkeSIsImdsb2JhbCIsIlBhZ2VWZW5kb3JzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUNBOztBQUdBLElBQUlBLEtBQUosRUFBMkMsRUFFMUM7O0FBR0RDLCtDQUFLLENBQUMsWUFBTTtBQUNWQyxRQUFNLENBQUNDLFdBQVAsR0FBcUIsSUFBSUEsZ0VBQUosRUFBckI7QUFDRCxDQUZJLENBQUwsQyIsImZpbGUiOiIyNjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVhZHkgZnJvbSAnZG9tcmVhZHknO1xuXG5pbXBvcnQgJy4vc2ltcGxlJztcbmltcG9ydCBQYWdlVmVuZG9ycyBmcm9tICcuL2pzL3BhZ2UvdmVuZG9ycyc7XG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcmVxdWlyZSgnLi92ZW5kb3JzLnB1ZycpO1xufVxuXG5cbnJlYWR5KCgpID0+IHtcbiAgZ2xvYmFsLlBhZ2VWZW5kb3JzID0gbmV3IFBhZ2VWZW5kb3JzKCk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///262\n')},41:function(module,exports,__webpack_require__){eval('var _typeof = __webpack_require__(63);\n\nvar assertThisInitialized = __webpack_require__(9);\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzPzZiNTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLEVBQW1COztBQUV6Qyw0QkFBNEIsbUJBQU8sQ0FBQyxDQUF5Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n')},42:function(module,exports,__webpack_require__){eval('var setPrototypeOf = __webpack_require__(58);\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9lZDZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLEVBQWtCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n')},43:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 13.1.4 - 3/20/2019 */\n(function(factory) {\r\n    if (true) {\r\n        // AMD. Register as an anonymous module.\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else {}\r\n})(function() {\r\n    "use strict";\r\n\r\n    var VERSION = "13.1.4";\r\n\r\n    //region Helper Methods\r\n\r\n    function isValidFormatter(entry) {\r\n        return typeof entry === "object" && typeof entry.to === "function" && typeof entry.from === "function";\r\n    }\r\n\r\n    function removeElement(el) {\r\n        el.parentElement.removeChild(el);\r\n    }\r\n\r\n    function isSet(value) {\r\n        return value !== null && value !== undefined;\r\n    }\r\n\r\n    // Bindable version\r\n    function preventDefault(e) {\r\n        e.preventDefault();\r\n    }\r\n\r\n    // Removes duplicates from an array.\r\n    function unique(array) {\r\n        return array.filter(function(a) {\r\n            return !this[a] ? (this[a] = true) : false;\r\n        }, {});\r\n    }\r\n\r\n    // Round a value to the closest \'to\'.\r\n    function closest(value, to) {\r\n        return Math.round(value / to) * to;\r\n    }\r\n\r\n    // Current position of an element relative to the document.\r\n    function offset(elem, orientation) {\r\n        var rect = elem.getBoundingClientRect();\r\n        var doc = elem.ownerDocument;\r\n        var docElem = doc.documentElement;\r\n        var pageOffset = getPageOffset(doc);\r\n\r\n        // getBoundingClientRect contains left scroll in Chrome on Android.\r\n        // I haven\'t found a feature detection that proves this. Worst case\r\n        // scenario on mis-match: the \'tap\' feature on horizontal sliders breaks.\r\n        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {\r\n            pageOffset.x = 0;\r\n        }\r\n\r\n        return orientation\r\n            ? rect.top + pageOffset.y - docElem.clientTop\r\n            : rect.left + pageOffset.x - docElem.clientLeft;\r\n    }\r\n\r\n    // Checks whether a value is numerical.\r\n    function isNumeric(a) {\r\n        return typeof a === "number" && !isNaN(a) && isFinite(a);\r\n    }\r\n\r\n    // Sets a class and removes it after [duration] ms.\r\n    function addClassFor(element, className, duration) {\r\n        if (duration > 0) {\r\n            addClass(element, className);\r\n            setTimeout(function() {\r\n                removeClass(element, className);\r\n            }, duration);\r\n        }\r\n    }\r\n\r\n    // Limits a value to 0 - 100\r\n    function limit(a) {\r\n        return Math.max(Math.min(a, 100), 0);\r\n    }\r\n\r\n    // Wraps a variable as an array, if it isn\'t one yet.\r\n    // Note that an input array is returned by reference!\r\n    function asArray(a) {\r\n        return Array.isArray(a) ? a : [a];\r\n    }\r\n\r\n    // Counts decimals\r\n    function countDecimals(numStr) {\r\n        numStr = String(numStr);\r\n        var pieces = numStr.split(".");\r\n        return pieces.length > 1 ? pieces[1].length : 0;\r\n    }\r\n\r\n    // http://youmightnotneedjquery.com/#add_class\r\n    function addClass(el, className) {\r\n        if (el.classList) {\r\n            el.classList.add(className);\r\n        } else {\r\n            el.className += " " + className;\r\n        }\r\n    }\r\n\r\n    // http://youmightnotneedjquery.com/#remove_class\r\n    function removeClass(el, className) {\r\n        if (el.classList) {\r\n            el.classList.remove(className);\r\n        } else {\r\n            el.className = el.className.replace(\r\n                new RegExp("(^|\\\\b)" + className.split(" ").join("|") + "(\\\\b|$)", "gi"),\r\n                " "\r\n            );\r\n        }\r\n    }\r\n\r\n    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\r\n    function hasClass(el, className) {\r\n        return el.classList\r\n            ? el.classList.contains(className)\r\n            : new RegExp("\\\\b" + className + "\\\\b").test(el.className);\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\r\n    function getPageOffset(doc) {\r\n        var supportPageOffset = window.pageXOffset !== undefined;\r\n        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";\r\n        var x = supportPageOffset\r\n            ? window.pageXOffset\r\n            : isCSS1Compat\r\n                ? doc.documentElement.scrollLeft\r\n                : doc.body.scrollLeft;\r\n        var y = supportPageOffset\r\n            ? window.pageYOffset\r\n            : isCSS1Compat\r\n                ? doc.documentElement.scrollTop\r\n                : doc.body.scrollTop;\r\n\r\n        return {\r\n            x: x,\r\n            y: y\r\n        };\r\n    }\r\n\r\n    // we provide a function to compute constants instead\r\n    // of accessing window.* as soon as the module needs it\r\n    // so that we do not compute anything if not needed\r\n    function getActions() {\r\n        // Determine the events to bind. IE11 implements pointerEvents without\r\n        // a prefix, which breaks compatibility with the IE10 implementation.\r\n        return window.navigator.pointerEnabled\r\n            ? {\r\n                  start: "pointerdown",\r\n                  move: "pointermove",\r\n                  end: "pointerup"\r\n              }\r\n            : window.navigator.msPointerEnabled\r\n                ? {\r\n                      start: "MSPointerDown",\r\n                      move: "MSPointerMove",\r\n                      end: "MSPointerUp"\r\n                  }\r\n                : {\r\n                      start: "mousedown touchstart",\r\n                      move: "mousemove touchmove",\r\n                      end: "mouseup touchend"\r\n                  };\r\n    }\r\n\r\n    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n    // Issue #785\r\n    function getSupportsPassive() {\r\n        var supportsPassive = false;\r\n\r\n        /* eslint-disable */\r\n        try {\r\n            var opts = Object.defineProperty({}, "passive", {\r\n                get: function() {\r\n                    supportsPassive = true;\r\n                }\r\n            });\r\n\r\n            window.addEventListener("test", null, opts);\r\n        } catch (e) {}\r\n        /* eslint-enable */\r\n\r\n        return supportsPassive;\r\n    }\r\n\r\n    function getSupportsTouchActionNone() {\r\n        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region Range Calculation\r\n\r\n    // Determine the size of a sub-range in relation to a full range.\r\n    function subRangeRatio(pa, pb) {\r\n        return 100 / (pb - pa);\r\n    }\r\n\r\n    // (percentage) How many percent is this value of this range?\r\n    function fromPercentage(range, value) {\r\n        return (value * 100) / (range[1] - range[0]);\r\n    }\r\n\r\n    // (percentage) Where is this value on this range?\r\n    function toPercentage(range, value) {\r\n        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0]);\r\n    }\r\n\r\n    // (value) How much is this percentage on this range?\r\n    function isPercentage(range, value) {\r\n        return (value * (range[1] - range[0])) / 100 + range[0];\r\n    }\r\n\r\n    function getJ(value, arr) {\r\n        var j = 1;\r\n\r\n        while (value >= arr[j]) {\r\n            j += 1;\r\n        }\r\n\r\n        return j;\r\n    }\r\n\r\n    // (percentage) Input a value, find where, on a scale of 0-100, it applies.\r\n    function toStepping(xVal, xPct, value) {\r\n        if (value >= xVal.slice(-1)[0]) {\r\n            return 100;\r\n        }\r\n\r\n        var j = getJ(value, xVal);\r\n        var va = xVal[j - 1];\r\n        var vb = xVal[j];\r\n        var pa = xPct[j - 1];\r\n        var pb = xPct[j];\r\n\r\n        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);\r\n    }\r\n\r\n    // (value) Input a percentage, find where it is on the specified range.\r\n    function fromStepping(xVal, xPct, value) {\r\n        // There is no range group that fits 100\r\n        if (value >= 100) {\r\n            return xVal.slice(-1)[0];\r\n        }\r\n\r\n        var j = getJ(value, xPct);\r\n        var va = xVal[j - 1];\r\n        var vb = xVal[j];\r\n        var pa = xPct[j - 1];\r\n        var pb = xPct[j];\r\n\r\n        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));\r\n    }\r\n\r\n    // (percentage) Get the step that applies at a certain value.\r\n    function getStep(xPct, xSteps, snap, value) {\r\n        if (value === 100) {\r\n            return value;\r\n        }\r\n\r\n        var j = getJ(value, xPct);\r\n        var a = xPct[j - 1];\r\n        var b = xPct[j];\r\n\r\n        // If \'snap\' is set, steps are used as fixed points on the slider.\r\n        if (snap) {\r\n            // Find the closest position, a or b.\r\n            if (value - a > (b - a) / 2) {\r\n                return b;\r\n            }\r\n\r\n            return a;\r\n        }\r\n\r\n        if (!xSteps[j - 1]) {\r\n            return value;\r\n        }\r\n\r\n        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);\r\n    }\r\n\r\n    function handleEntryPoint(index, value, that) {\r\n        var percentage;\r\n\r\n        // Wrap numerical input in an array.\r\n        if (typeof value === "number") {\r\n            value = [value];\r\n        }\r\n\r\n        // Reject any invalid input, by testing whether value is an array.\r\n        if (!Array.isArray(value)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' contains invalid value.");\r\n        }\r\n\r\n        // Covert min/max syntax to 0 and 100.\r\n        if (index === "min") {\r\n            percentage = 0;\r\n        } else if (index === "max") {\r\n            percentage = 100;\r\n        } else {\r\n            percentage = parseFloat(index);\r\n        }\r\n\r\n        // Check for correct input.\r\n        if (!isNumeric(percentage) || !isNumeric(value[0])) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' value isn\'t numeric.");\r\n        }\r\n\r\n        // Store values.\r\n        that.xPct.push(percentage);\r\n        that.xVal.push(value[0]);\r\n\r\n        // NaN will evaluate to false too, but to keep\r\n        // logging clear, set step explicitly. Make sure\r\n        // not to override the \'step\' setting with false.\r\n        if (!percentage) {\r\n            if (!isNaN(value[1])) {\r\n                that.xSteps[0] = value[1];\r\n            }\r\n        } else {\r\n            that.xSteps.push(isNaN(value[1]) ? false : value[1]);\r\n        }\r\n\r\n        that.xHighestCompleteStep.push(0);\r\n    }\r\n\r\n    function handleStepPoint(i, n, that) {\r\n        // Ignore \'false\' stepping.\r\n        if (!n) {\r\n            return;\r\n        }\r\n\r\n        // Step over zero-length ranges (#948);\r\n        if (that.xVal[i] === that.xVal[i + 1]) {\r\n            that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];\r\n\r\n            return;\r\n        }\r\n\r\n        // Factor to range ratio\r\n        that.xSteps[i] =\r\n            fromPercentage([that.xVal[i], that.xVal[i + 1]], n) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);\r\n\r\n        var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];\r\n        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\r\n        var step = that.xVal[i] + that.xNumSteps[i] * highestStep;\r\n\r\n        that.xHighestCompleteStep[i] = step;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region Spectrum\r\n\r\n    function Spectrum(entry, snap, singleStep) {\r\n        this.xPct = [];\r\n        this.xVal = [];\r\n        this.xSteps = [singleStep || false];\r\n        this.xNumSteps = [false];\r\n        this.xHighestCompleteStep = [];\r\n\r\n        this.snap = snap;\r\n\r\n        var index;\r\n        var ordered = []; // [0, \'min\'], [1, \'50%\'], [2, \'max\']\r\n\r\n        // Map the object keys to an array.\r\n        for (index in entry) {\r\n            if (entry.hasOwnProperty(index)) {\r\n                ordered.push([entry[index], index]);\r\n            }\r\n        }\r\n\r\n        // Sort all entries by value (numeric sort).\r\n        if (ordered.length && typeof ordered[0][0] === "object") {\r\n            ordered.sort(function(a, b) {\r\n                return a[0][0] - b[0][0];\r\n            });\r\n        } else {\r\n            ordered.sort(function(a, b) {\r\n                return a[0] - b[0];\r\n            });\r\n        }\r\n\r\n        // Convert all entries to subranges.\r\n        for (index = 0; index < ordered.length; index++) {\r\n            handleEntryPoint(ordered[index][1], ordered[index][0], this);\r\n        }\r\n\r\n        // Store the actual step values.\r\n        // xSteps is sorted in the same order as xPct and xVal.\r\n        this.xNumSteps = this.xSteps.slice(0);\r\n\r\n        // Convert all numeric steps to the percentage of the subrange they represent.\r\n        for (index = 0; index < this.xNumSteps.length; index++) {\r\n            handleStepPoint(index, this.xNumSteps[index], this);\r\n        }\r\n    }\r\n\r\n    Spectrum.prototype.getMargin = function(value) {\r\n        var step = this.xNumSteps[0];\r\n\r\n        if (step && (value / step) % 1 !== 0) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'limit\', \'margin\' and \'padding\' must be divisible by step.");\r\n        }\r\n\r\n        return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\r\n    };\r\n\r\n    Spectrum.prototype.toStepping = function(value) {\r\n        value = toStepping(this.xVal, this.xPct, value);\r\n\r\n        return value;\r\n    };\r\n\r\n    Spectrum.prototype.fromStepping = function(value) {\r\n        return fromStepping(this.xVal, this.xPct, value);\r\n    };\r\n\r\n    Spectrum.prototype.getStep = function(value) {\r\n        value = getStep(this.xPct, this.xSteps, this.snap, value);\r\n\r\n        return value;\r\n    };\r\n\r\n    Spectrum.prototype.getDefaultStep = function(value, isDown, size) {\r\n        var j = getJ(value, this.xPct);\r\n\r\n        // When at the top or stepping down, look at the previous sub-range\r\n        if (value === 100 || (isDown && value === this.xPct[j - 1])) {\r\n            j = Math.max(j - 1, 1);\r\n        }\r\n\r\n        return (this.xVal[j] - this.xVal[j - 1]) / size;\r\n    };\r\n\r\n    Spectrum.prototype.getNearbySteps = function(value) {\r\n        var j = getJ(value, this.xPct);\r\n\r\n        return {\r\n            stepBefore: {\r\n                startValue: this.xVal[j - 2],\r\n                step: this.xNumSteps[j - 2],\r\n                highestStep: this.xHighestCompleteStep[j - 2]\r\n            },\r\n            thisStep: {\r\n                startValue: this.xVal[j - 1],\r\n                step: this.xNumSteps[j - 1],\r\n                highestStep: this.xHighestCompleteStep[j - 1]\r\n            },\r\n            stepAfter: {\r\n                startValue: this.xVal[j],\r\n                step: this.xNumSteps[j],\r\n                highestStep: this.xHighestCompleteStep[j]\r\n            }\r\n        };\r\n    };\r\n\r\n    Spectrum.prototype.countStepDecimals = function() {\r\n        var stepDecimals = this.xNumSteps.map(countDecimals);\r\n        return Math.max.apply(null, stepDecimals);\r\n    };\r\n\r\n    // Outside testing\r\n    Spectrum.prototype.convert = function(value) {\r\n        return this.getStep(this.toStepping(value));\r\n    };\r\n\r\n    //endregion\r\n\r\n    //region Options\r\n\r\n    /*\tEvery input option is tested and parsed. This\'ll prevent\r\n        endless validation in internal methods. These tests are\r\n        structured with an item for every option available. An\r\n        option can be marked as required by setting the \'r\' flag.\r\n        The testing function is provided with three arguments:\r\n            - The provided value for the option;\r\n            - A reference to the options object;\r\n            - The name for the option;\r\n\r\n        The testing function returns false when an error is detected,\r\n        or true when everything is OK. It can also modify the option\r\n        object, to make sure all values can be correctly looped elsewhere. */\r\n\r\n    var defaultFormatter = {\r\n        to: function(value) {\r\n            return value !== undefined && value.toFixed(2);\r\n        },\r\n        from: Number\r\n    };\r\n\r\n    function validateFormat(entry) {\r\n        // Any object with a to and from method is supported.\r\n        if (isValidFormatter(entry)) {\r\n            return true;\r\n        }\r\n\r\n        throw new Error("noUiSlider (" + VERSION + "): \'format\' requires \'to\' and \'from\' methods.");\r\n    }\r\n\r\n    function testStep(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'step\' is not numeric.");\r\n        }\r\n\r\n        // The step option can still be used to set stepping\r\n        // for linear sliders. Overwritten if set in \'range\'.\r\n        parsed.singleStep = entry;\r\n    }\r\n\r\n    function testRange(parsed, entry) {\r\n        // Filter incorrect input.\r\n        if (typeof entry !== "object" || Array.isArray(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' is not an object.");\r\n        }\r\n\r\n        // Catch missing start or end.\r\n        if (entry.min === undefined || entry.max === undefined) {\r\n            throw new Error("noUiSlider (" + VERSION + "): Missing \'min\' or \'max\' in \'range\'.");\r\n        }\r\n\r\n        // Catch equal start or end.\r\n        if (entry.min === entry.max) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' \'min\' and \'max\' cannot be equal.");\r\n        }\r\n\r\n        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);\r\n    }\r\n\r\n    function testStart(parsed, entry) {\r\n        entry = asArray(entry);\r\n\r\n        // Validate input. Values aren\'t tested, as the public .val method\r\n        // will always provide a valid location.\r\n        if (!Array.isArray(entry) || !entry.length) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'start\' option is incorrect.");\r\n        }\r\n\r\n        // Store the number of handles.\r\n        parsed.handles = entry.length;\r\n\r\n        // When the slider is initialized, the .val method will\r\n        // be called with the start options.\r\n        parsed.start = entry;\r\n    }\r\n\r\n    function testSnap(parsed, entry) {\r\n        // Enforce 100% stepping within subranges.\r\n        parsed.snap = entry;\r\n\r\n        if (typeof entry !== "boolean") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'snap\' option must be a boolean.");\r\n        }\r\n    }\r\n\r\n    function testAnimate(parsed, entry) {\r\n        // Enforce 100% stepping within subranges.\r\n        parsed.animate = entry;\r\n\r\n        if (typeof entry !== "boolean") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'animate\' option must be a boolean.");\r\n        }\r\n    }\r\n\r\n    function testAnimationDuration(parsed, entry) {\r\n        parsed.animationDuration = entry;\r\n\r\n        if (typeof entry !== "number") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'animationDuration\' option must be a number.");\r\n        }\r\n    }\r\n\r\n    function testConnect(parsed, entry) {\r\n        var connect = [false];\r\n        var i;\r\n\r\n        // Map legacy options\r\n        if (entry === "lower") {\r\n            entry = [true, false];\r\n        } else if (entry === "upper") {\r\n            entry = [false, true];\r\n        }\r\n\r\n        // Handle boolean options\r\n        if (entry === true || entry === false) {\r\n            for (i = 1; i < parsed.handles; i++) {\r\n                connect.push(entry);\r\n            }\r\n\r\n            connect.push(false);\r\n        }\r\n\r\n        // Reject invalid input\r\n        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'connect\' option doesn\'t match handle count.");\r\n        } else {\r\n            connect = entry;\r\n        }\r\n\r\n        parsed.connect = connect;\r\n    }\r\n\r\n    function testOrientation(parsed, entry) {\r\n        // Set orientation to an a numerical value for easy\r\n        // array selection.\r\n        switch (entry) {\r\n            case "horizontal":\r\n                parsed.ort = 0;\r\n                break;\r\n            case "vertical":\r\n                parsed.ort = 1;\r\n                break;\r\n            default:\r\n                throw new Error("noUiSlider (" + VERSION + "): \'orientation\' option is invalid.");\r\n        }\r\n    }\r\n\r\n    function testMargin(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'margin\' option must be numeric.");\r\n        }\r\n\r\n        // Issue #582\r\n        if (entry === 0) {\r\n            return;\r\n        }\r\n\r\n        parsed.margin = parsed.spectrum.getMargin(entry);\r\n\r\n        if (!parsed.margin) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'margin\' option is only supported on linear sliders.");\r\n        }\r\n    }\r\n\r\n    function testLimit(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'limit\' option must be numeric.");\r\n        }\r\n\r\n        parsed.limit = parsed.spectrum.getMargin(entry);\r\n\r\n        if (!parsed.limit || parsed.handles < 2) {\r\n            throw new Error(\r\n                "noUiSlider (" +\r\n                    VERSION +\r\n                    "): \'limit\' option is only supported on linear sliders with 2 or more handles."\r\n            );\r\n        }\r\n    }\r\n\r\n    function testPadding(parsed, entry) {\r\n        if (!isNumeric(entry) && !Array.isArray(entry)) {\r\n            throw new Error(\r\n                "noUiSlider (" + VERSION + "): \'padding\' option must be numeric or array of exactly 2 numbers."\r\n            );\r\n        }\r\n\r\n        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {\r\n            throw new Error(\r\n                "noUiSlider (" + VERSION + "): \'padding\' option must be numeric or array of exactly 2 numbers."\r\n            );\r\n        }\r\n\r\n        if (entry === 0) {\r\n            return;\r\n        }\r\n\r\n        if (!Array.isArray(entry)) {\r\n            entry = [entry, entry];\r\n        }\r\n\r\n        // \'getMargin\' returns false for invalid values.\r\n        parsed.padding = [parsed.spectrum.getMargin(entry[0]), parsed.spectrum.getMargin(entry[1])];\r\n\r\n        if (parsed.padding[0] === false || parsed.padding[1] === false) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'padding\' option is only supported on linear sliders.");\r\n        }\r\n\r\n        if (parsed.padding[0] < 0 || parsed.padding[1] < 0) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must be a positive number(s).");\r\n        }\r\n\r\n        if (parsed.padding[0] + parsed.padding[1] >= 100) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must not exceed 100% of the range.");\r\n        }\r\n    }\r\n\r\n    function testDirection(parsed, entry) {\r\n        // Set direction as a numerical value for easy parsing.\r\n        // Invert connection for RTL sliders, so that the proper\r\n        // handles get the connect/background classes.\r\n        switch (entry) {\r\n            case "ltr":\r\n                parsed.dir = 0;\r\n                break;\r\n            case "rtl":\r\n                parsed.dir = 1;\r\n                break;\r\n            default:\r\n                throw new Error("noUiSlider (" + VERSION + "): \'direction\' option was not recognized.");\r\n        }\r\n    }\r\n\r\n    function testBehaviour(parsed, entry) {\r\n        // Make sure the input is a string.\r\n        if (typeof entry !== "string") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'behaviour\' must be a string containing options.");\r\n        }\r\n\r\n        // Check if the string contains any keywords.\r\n        // None are required.\r\n        var tap = entry.indexOf("tap") >= 0;\r\n        var drag = entry.indexOf("drag") >= 0;\r\n        var fixed = entry.indexOf("fixed") >= 0;\r\n        var snap = entry.indexOf("snap") >= 0;\r\n        var hover = entry.indexOf("hover") >= 0;\r\n        var unconstrained = entry.indexOf("unconstrained") >= 0;\r\n\r\n        if (fixed) {\r\n            if (parsed.handles !== 2) {\r\n                throw new Error("noUiSlider (" + VERSION + "): \'fixed\' behaviour must be used with 2 handles");\r\n            }\r\n\r\n            // Use margin to enforce fixed state\r\n            testMargin(parsed, parsed.start[1] - parsed.start[0]);\r\n        }\r\n\r\n        if (unconstrained && (parsed.margin || parsed.limit)) {\r\n            throw new Error(\r\n                "noUiSlider (" + VERSION + "): \'unconstrained\' behaviour cannot be used with margin or limit"\r\n            );\r\n        }\r\n\r\n        parsed.events = {\r\n            tap: tap || snap,\r\n            drag: drag,\r\n            fixed: fixed,\r\n            snap: snap,\r\n            hover: hover,\r\n            unconstrained: unconstrained\r\n        };\r\n    }\r\n\r\n    function testTooltips(parsed, entry) {\r\n        if (entry === false) {\r\n            return;\r\n        }\r\n\r\n        if (entry === true) {\r\n            parsed.tooltips = [];\r\n\r\n            for (var i = 0; i < parsed.handles; i++) {\r\n                parsed.tooltips.push(true);\r\n            }\r\n        } else {\r\n            parsed.tooltips = asArray(entry);\r\n\r\n            if (parsed.tooltips.length !== parsed.handles) {\r\n                throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");\r\n            }\r\n\r\n            parsed.tooltips.forEach(function(formatter) {\r\n                if (\r\n                    typeof formatter !== "boolean" &&\r\n                    (typeof formatter !== "object" || typeof formatter.to !== "function")\r\n                ) {\r\n                    throw new Error("noUiSlider (" + VERSION + "): \'tooltips\' must be passed a formatter or \'false\'.");\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function testAriaFormat(parsed, entry) {\r\n        parsed.ariaFormat = entry;\r\n        validateFormat(entry);\r\n    }\r\n\r\n    function testFormat(parsed, entry) {\r\n        parsed.format = entry;\r\n        validateFormat(entry);\r\n    }\r\n\r\n    function testKeyboardSupport(parsed, entry) {\r\n        parsed.keyboardSupport = entry;\r\n\r\n        if (typeof entry !== "boolean") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'keyboardSupport\' option must be a boolean.");\r\n        }\r\n    }\r\n\r\n    function testDocumentElement(parsed, entry) {\r\n        // This is an advanced option. Passed values are used without validation.\r\n        parsed.documentElement = entry;\r\n    }\r\n\r\n    function testCssPrefix(parsed, entry) {\r\n        if (typeof entry !== "string" && entry !== false) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'cssPrefix\' must be a string or `false`.");\r\n        }\r\n\r\n        parsed.cssPrefix = entry;\r\n    }\r\n\r\n    function testCssClasses(parsed, entry) {\r\n        if (typeof entry !== "object") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'cssClasses\' must be an object.");\r\n        }\r\n\r\n        if (typeof parsed.cssPrefix === "string") {\r\n            parsed.cssClasses = {};\r\n\r\n            for (var key in entry) {\r\n                if (!entry.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n\r\n                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];\r\n            }\r\n        } else {\r\n            parsed.cssClasses = entry;\r\n        }\r\n    }\r\n\r\n    // Test all developer settings and parse to assumption-safe values.\r\n    function testOptions(options) {\r\n        // To prove a fix for #537, freeze options here.\r\n        // If the object is modified, an error will be thrown.\r\n        // Object.freeze(options);\r\n\r\n        var parsed = {\r\n            margin: 0,\r\n            limit: 0,\r\n            padding: 0,\r\n            animate: true,\r\n            animationDuration: 300,\r\n            ariaFormat: defaultFormatter,\r\n            format: defaultFormatter\r\n        };\r\n\r\n        // Tests are executed in the order they are presented here.\r\n        var tests = {\r\n            step: { r: false, t: testStep },\r\n            start: { r: true, t: testStart },\r\n            connect: { r: true, t: testConnect },\r\n            direction: { r: true, t: testDirection },\r\n            snap: { r: false, t: testSnap },\r\n            animate: { r: false, t: testAnimate },\r\n            animationDuration: { r: false, t: testAnimationDuration },\r\n            range: { r: true, t: testRange },\r\n            orientation: { r: false, t: testOrientation },\r\n            margin: { r: false, t: testMargin },\r\n            limit: { r: false, t: testLimit },\r\n            padding: { r: false, t: testPadding },\r\n            behaviour: { r: true, t: testBehaviour },\r\n            ariaFormat: { r: false, t: testAriaFormat },\r\n            format: { r: false, t: testFormat },\r\n            tooltips: { r: false, t: testTooltips },\r\n            keyboardSupport: { r: true, t: testKeyboardSupport },\r\n            documentElement: { r: false, t: testDocumentElement },\r\n            cssPrefix: { r: true, t: testCssPrefix },\r\n            cssClasses: { r: true, t: testCssClasses }\r\n        };\r\n\r\n        var defaults = {\r\n            connect: false,\r\n            direction: "ltr",\r\n            behaviour: "tap",\r\n            orientation: "horizontal",\r\n            keyboardSupport: true,\r\n            cssPrefix: "noUi-",\r\n            cssClasses: {\r\n                target: "target",\r\n                base: "base",\r\n                origin: "origin",\r\n                handle: "handle",\r\n                handleLower: "handle-lower",\r\n                handleUpper: "handle-upper",\r\n                touchArea: "touch-area",\r\n                horizontal: "horizontal",\r\n                vertical: "vertical",\r\n                background: "background",\r\n                connect: "connect",\r\n                connects: "connects",\r\n                ltr: "ltr",\r\n                rtl: "rtl",\r\n                draggable: "draggable",\r\n                drag: "state-drag",\r\n                tap: "state-tap",\r\n                active: "active",\r\n                tooltip: "tooltip",\r\n                pips: "pips",\r\n                pipsHorizontal: "pips-horizontal",\r\n                pipsVertical: "pips-vertical",\r\n                marker: "marker",\r\n                markerHorizontal: "marker-horizontal",\r\n                markerVertical: "marker-vertical",\r\n                markerNormal: "marker-normal",\r\n                markerLarge: "marker-large",\r\n                markerSub: "marker-sub",\r\n                value: "value",\r\n                valueHorizontal: "value-horizontal",\r\n                valueVertical: "value-vertical",\r\n                valueNormal: "value-normal",\r\n                valueLarge: "value-large",\r\n                valueSub: "value-sub"\r\n            }\r\n        };\r\n\r\n        // AriaFormat defaults to regular format, if any.\r\n        if (options.format && !options.ariaFormat) {\r\n            options.ariaFormat = options.format;\r\n        }\r\n\r\n        // Run all options through a testing mechanism to ensure correct\r\n        // input. It should be noted that options might get modified to\r\n        // be handled properly. E.g. wrapping integers in arrays.\r\n        Object.keys(tests).forEach(function(name) {\r\n            // If the option isn\'t set, but it is required, throw an error.\r\n            if (!isSet(options[name]) && defaults[name] === undefined) {\r\n                if (tests[name].r) {\r\n                    throw new Error("noUiSlider (" + VERSION + "): \'" + name + "\' is required.");\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);\r\n        });\r\n\r\n        // Forward pips options\r\n        parsed.pips = options.pips;\r\n\r\n        // All recent browsers accept unprefixed transform.\r\n        // We need -ms- for IE9 and -webkit- for older Android;\r\n        // Assume use of -webkit- if unprefixed and -ms- are not supported.\r\n        // https://caniuse.com/#feat=transforms2d\r\n        var d = document.createElement("div");\r\n        var msPrefix = d.style.msTransform !== undefined;\r\n        var noPrefix = d.style.transform !== undefined;\r\n\r\n        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";\r\n\r\n        // Pips don\'t move, so we can place them using left/top.\r\n        var styles = [["left", "top"], ["right", "bottom"]];\r\n\r\n        parsed.style = styles[parsed.dir][parsed.ort];\r\n\r\n        return parsed;\r\n    }\r\n\r\n    //endregion\r\n\r\n    function scope(target, options, originalOptions) {\r\n        var actions = getActions();\r\n        var supportsTouchActionNone = getSupportsTouchActionNone();\r\n        var supportsPassive = supportsTouchActionNone && getSupportsPassive();\r\n\r\n        // All variables local to \'scope\' are prefixed with \'scope_\'\r\n\r\n        // Slider DOM Nodes\r\n        var scope_Target = target;\r\n        var scope_Base;\r\n        var scope_Handles;\r\n        var scope_Connects;\r\n        var scope_Pips;\r\n        var scope_Tooltips;\r\n\r\n        // Slider state values\r\n        var scope_Spectrum = options.spectrum;\r\n        var scope_Values = [];\r\n        var scope_Locations = [];\r\n        var scope_HandleNumbers = [];\r\n        var scope_ActiveHandlesCount = 0;\r\n        var scope_Events = {};\r\n\r\n        // Exposed API\r\n        var scope_Self;\r\n\r\n        // Document Nodes\r\n        var scope_Document = target.ownerDocument;\r\n        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;\r\n        var scope_Body = scope_Document.body;\r\n\r\n        // Pips constants\r\n        var PIPS_NONE = -1;\r\n        var PIPS_NO_VALUE = 0;\r\n        var PIPS_LARGE_VALUE = 1;\r\n        var PIPS_SMALL_VALUE = 2;\r\n\r\n        // For horizontal sliders in standard ltr documents,\r\n        // make .noUi-origin overflow to the left so the document doesn\'t scroll.\r\n        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;\r\n\r\n        // Creates a node, adds it to target, returns the new node.\r\n        function addNodeTo(addTarget, className) {\r\n            var div = scope_Document.createElement("div");\r\n\r\n            if (className) {\r\n                addClass(div, className);\r\n            }\r\n\r\n            addTarget.appendChild(div);\r\n\r\n            return div;\r\n        }\r\n\r\n        // Append a origin to the base\r\n        function addOrigin(base, handleNumber) {\r\n            var origin = addNodeTo(base, options.cssClasses.origin);\r\n            var handle = addNodeTo(origin, options.cssClasses.handle);\r\n\r\n            addNodeTo(handle, options.cssClasses.touchArea);\r\n\r\n            handle.setAttribute("data-handle", handleNumber);\r\n\r\n            if (options.keyboardSupport) {\r\n                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n                // 0 = focusable and reachable\r\n                handle.setAttribute("tabindex", "0");\r\n                handle.addEventListener("keydown", function(event) {\r\n                    return eventKeydown(event, handleNumber);\r\n                });\r\n            }\r\n\r\n            handle.setAttribute("role", "slider");\r\n            handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");\r\n\r\n            if (handleNumber === 0) {\r\n                addClass(handle, options.cssClasses.handleLower);\r\n            } else if (handleNumber === options.handles - 1) {\r\n                addClass(handle, options.cssClasses.handleUpper);\r\n            }\r\n\r\n            return origin;\r\n        }\r\n\r\n        // Insert nodes for connect elements\r\n        function addConnect(base, add) {\r\n            if (!add) {\r\n                return false;\r\n            }\r\n\r\n            return addNodeTo(base, options.cssClasses.connect);\r\n        }\r\n\r\n        // Add handles to the slider base.\r\n        function addElements(connectOptions, base) {\r\n            var connectBase = addNodeTo(base, options.cssClasses.connects);\r\n\r\n            scope_Handles = [];\r\n            scope_Connects = [];\r\n\r\n            scope_Connects.push(addConnect(connectBase, connectOptions[0]));\r\n\r\n            // [::::O====O====O====]\r\n            // connectOptions = [0, 1, 1, 1]\r\n\r\n            for (var i = 0; i < options.handles; i++) {\r\n                // Keep a list of all added handles.\r\n                scope_Handles.push(addOrigin(base, i));\r\n                scope_HandleNumbers[i] = i;\r\n                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));\r\n            }\r\n        }\r\n\r\n        // Initialize a single slider.\r\n        function addSlider(addTarget) {\r\n            // Apply classes and data to the target.\r\n            addClass(addTarget, options.cssClasses.target);\r\n\r\n            if (options.dir === 0) {\r\n                addClass(addTarget, options.cssClasses.ltr);\r\n            } else {\r\n                addClass(addTarget, options.cssClasses.rtl);\r\n            }\r\n\r\n            if (options.ort === 0) {\r\n                addClass(addTarget, options.cssClasses.horizontal);\r\n            } else {\r\n                addClass(addTarget, options.cssClasses.vertical);\r\n            }\r\n\r\n            return addNodeTo(addTarget, options.cssClasses.base);\r\n        }\r\n\r\n        function addTooltip(handle, handleNumber) {\r\n            if (!options.tooltips[handleNumber]) {\r\n                return false;\r\n            }\r\n\r\n            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);\r\n        }\r\n\r\n        function isSliderDisabled() {\r\n            return scope_Target.hasAttribute("disabled");\r\n        }\r\n\r\n        // Disable the slider dragging if any handle is disabled\r\n        function isHandleDisabled(handleNumber) {\r\n            var handleOrigin = scope_Handles[handleNumber];\r\n            return handleOrigin.hasAttribute("disabled");\r\n        }\r\n\r\n        function removeTooltips() {\r\n            if (scope_Tooltips) {\r\n                removeEvent("update.tooltips");\r\n                scope_Tooltips.forEach(function(tooltip) {\r\n                    if (tooltip) {\r\n                        removeElement(tooltip);\r\n                    }\r\n                });\r\n                scope_Tooltips = null;\r\n            }\r\n        }\r\n\r\n        // The tooltips option is a shorthand for using the \'update\' event.\r\n        function tooltips() {\r\n            removeTooltips();\r\n\r\n            // Tooltips are added with options.tooltips in original order.\r\n            scope_Tooltips = scope_Handles.map(addTooltip);\r\n\r\n            bindEvent("update.tooltips", function(values, handleNumber, unencoded) {\r\n                if (!scope_Tooltips[handleNumber]) {\r\n                    return;\r\n                }\r\n\r\n                var formattedValue = values[handleNumber];\r\n\r\n                if (options.tooltips[handleNumber] !== true) {\r\n                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\r\n                }\r\n\r\n                scope_Tooltips[handleNumber].innerHTML = formattedValue;\r\n            });\r\n        }\r\n\r\n        function aria() {\r\n            bindEvent("update", function(values, handleNumber, unencoded, tap, positions) {\r\n                // Update Aria Values for all handles, as a change in one changes min and max values for the next.\r\n                scope_HandleNumbers.forEach(function(index) {\r\n                    var handle = scope_Handles[index];\r\n\r\n                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);\r\n                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);\r\n\r\n                    var now = positions[index];\r\n\r\n                    // Formatted value for display\r\n                    var text = options.ariaFormat.to(unencoded[index]);\r\n\r\n                    // Map to slider range values\r\n                    min = scope_Spectrum.fromStepping(min).toFixed(1);\r\n                    max = scope_Spectrum.fromStepping(max).toFixed(1);\r\n                    now = scope_Spectrum.fromStepping(now).toFixed(1);\r\n\r\n                    handle.children[0].setAttribute("aria-valuemin", min);\r\n                    handle.children[0].setAttribute("aria-valuemax", max);\r\n                    handle.children[0].setAttribute("aria-valuenow", now);\r\n                    handle.children[0].setAttribute("aria-valuetext", text);\r\n                });\r\n            });\r\n        }\r\n\r\n        function getGroup(mode, values, stepped) {\r\n            // Use the range.\r\n            if (mode === "range" || mode === "steps") {\r\n                return scope_Spectrum.xVal;\r\n            }\r\n\r\n            if (mode === "count") {\r\n                if (values < 2) {\r\n                    throw new Error("noUiSlider (" + VERSION + "): \'values\' (>= 2) required for mode \'count\'.");\r\n                }\r\n\r\n                // Divide 0 - 100 in \'count\' parts.\r\n                var interval = values - 1;\r\n                var spread = 100 / interval;\r\n\r\n                values = [];\r\n\r\n                // List these parts and have them handled as \'positions\'.\r\n                while (interval--) {\r\n                    values[interval] = interval * spread;\r\n                }\r\n\r\n                values.push(100);\r\n\r\n                mode = "positions";\r\n            }\r\n\r\n            if (mode === "positions") {\r\n                // Map all percentages to on-range values.\r\n                return values.map(function(value) {\r\n                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);\r\n                });\r\n            }\r\n\r\n            if (mode === "values") {\r\n                // If the value must be stepped, it needs to be converted to a percentage first.\r\n                if (stepped) {\r\n                    return values.map(function(value) {\r\n                        // Convert to percentage, apply step, return to value.\r\n                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));\r\n                    });\r\n                }\r\n\r\n                // Otherwise, we can simply use the values.\r\n                return values;\r\n            }\r\n        }\r\n\r\n        function generateSpread(density, mode, group) {\r\n            function safeIncrement(value, increment) {\r\n                // Avoid floating point variance by dropping the smallest decimal places.\r\n                return (value + increment).toFixed(7) / 1;\r\n            }\r\n\r\n            var indexes = {};\r\n            var firstInRange = scope_Spectrum.xVal[0];\r\n            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];\r\n            var ignoreFirst = false;\r\n            var ignoreLast = false;\r\n            var prevPct = 0;\r\n\r\n            // Create a copy of the group, sort it and filter away all duplicates.\r\n            group = unique(\r\n                group.slice().sort(function(a, b) {\r\n                    return a - b;\r\n                })\r\n            );\r\n\r\n            // Make sure the range starts with the first element.\r\n            if (group[0] !== firstInRange) {\r\n                group.unshift(firstInRange);\r\n                ignoreFirst = true;\r\n            }\r\n\r\n            // Likewise for the last one.\r\n            if (group[group.length - 1] !== lastInRange) {\r\n                group.push(lastInRange);\r\n                ignoreLast = true;\r\n            }\r\n\r\n            group.forEach(function(current, index) {\r\n                // Get the current step and the lower + upper positions.\r\n                var step;\r\n                var i;\r\n                var q;\r\n                var low = current;\r\n                var high = group[index + 1];\r\n                var newPct;\r\n                var pctDifference;\r\n                var pctPos;\r\n                var type;\r\n                var steps;\r\n                var realSteps;\r\n                var stepSize;\r\n                var isSteps = mode === "steps";\r\n\r\n                // When using \'steps\' mode, use the provided steps.\r\n                // Otherwise, we\'ll step on to the next subrange.\r\n                if (isSteps) {\r\n                    step = scope_Spectrum.xNumSteps[index];\r\n                }\r\n\r\n                // Default to a \'full\' step.\r\n                if (!step) {\r\n                    step = high - low;\r\n                }\r\n\r\n                // Low can be 0, so test for false. If high is undefined,\r\n                // we are at the last subrange. Index 0 is already handled.\r\n                if (low === false || high === undefined) {\r\n                    return;\r\n                }\r\n\r\n                // Make sure step isn\'t 0, which would cause an infinite loop (#654)\r\n                step = Math.max(step, 0.0000001);\r\n\r\n                // Find all steps in the subrange.\r\n                for (i = low; i <= high; i = safeIncrement(i, step)) {\r\n                    // Get the percentage value for the current step,\r\n                    // calculate the size for the subrange.\r\n                    newPct = scope_Spectrum.toStepping(i);\r\n                    pctDifference = newPct - prevPct;\r\n\r\n                    steps = pctDifference / density;\r\n                    realSteps = Math.round(steps);\r\n\r\n                    // This ratio represents the amount of percentage-space a point indicates.\r\n                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.\r\n                    // Round the percentage offset to an even number, then divide by two\r\n                    // to spread the offset on both sides of the range.\r\n                    stepSize = pctDifference / realSteps;\r\n\r\n                    // Divide all points evenly, adding the correct number to this subrange.\r\n                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.\r\n                    for (q = 1; q <= realSteps; q += 1) {\r\n                        // The ratio between the rounded value and the actual size might be ~1% off.\r\n                        // Correct the percentage offset by the number of points\r\n                        // per subrange. density = 1 will result in 100 points on the\r\n                        // full range, 2 for 50, 4 for 25, etc.\r\n                        pctPos = prevPct + q * stepSize;\r\n                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];\r\n                    }\r\n\r\n                    // Determine the point type.\r\n                    type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE;\r\n\r\n                    // Enforce the \'ignoreFirst\' option by overwriting the type for 0.\r\n                    if (!index && ignoreFirst) {\r\n                        type = 0;\r\n                    }\r\n\r\n                    if (!(i === high && ignoreLast)) {\r\n                        // Mark the \'type\' of this point. 0 = plain, 1 = real value, 2 = step value.\r\n                        indexes[newPct.toFixed(5)] = [i, type];\r\n                    }\r\n\r\n                    // Update the percentage count.\r\n                    prevPct = newPct;\r\n                }\r\n            });\r\n\r\n            return indexes;\r\n        }\r\n\r\n        function addMarking(spread, filterFunc, formatter) {\r\n            var element = scope_Document.createElement("div");\r\n\r\n            var valueSizeClasses = [];\r\n            valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;\r\n            valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;\r\n            valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;\r\n\r\n            var markerSizeClasses = [];\r\n            markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;\r\n            markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;\r\n            markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;\r\n\r\n            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];\r\n            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];\r\n\r\n            addClass(element, options.cssClasses.pips);\r\n            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\r\n\r\n            function getClasses(type, source) {\r\n                var a = source === options.cssClasses.value;\r\n                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\r\n                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;\r\n\r\n                return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];\r\n            }\r\n\r\n            function addSpread(offset, value, type) {\r\n                // Apply the filter function, if it is set.\r\n                type = filterFunc ? filterFunc(value, type) : type;\r\n\r\n                if (type === PIPS_NONE) {\r\n                    return;\r\n                }\r\n\r\n                // Add a marker for every point\r\n                var node = addNodeTo(element, false);\r\n                node.className = getClasses(type, options.cssClasses.marker);\r\n                node.style[options.style] = offset + "%";\r\n\r\n                // Values are only appended for points marked \'1\' or \'2\'.\r\n                if (type > PIPS_NO_VALUE) {\r\n                    node = addNodeTo(element, false);\r\n                    node.className = getClasses(type, options.cssClasses.value);\r\n                    node.setAttribute("data-value", value);\r\n                    node.style[options.style] = offset + "%";\r\n                    node.innerHTML = formatter.to(value);\r\n                }\r\n            }\r\n\r\n            // Append all points.\r\n            Object.keys(spread).forEach(function(offset) {\r\n                addSpread(offset, spread[offset][0], spread[offset][1]);\r\n            });\r\n\r\n            return element;\r\n        }\r\n\r\n        function removePips() {\r\n            if (scope_Pips) {\r\n                removeElement(scope_Pips);\r\n                scope_Pips = null;\r\n            }\r\n        }\r\n\r\n        function pips(grid) {\r\n            // Fix #669\r\n            removePips();\r\n\r\n            var mode = grid.mode;\r\n            var density = grid.density || 1;\r\n            var filter = grid.filter || false;\r\n            var values = grid.values || false;\r\n            var stepped = grid.stepped || false;\r\n            var group = getGroup(mode, values, stepped);\r\n            var spread = generateSpread(density, mode, group);\r\n            var format = grid.format || {\r\n                to: Math.round\r\n            };\r\n\r\n            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));\r\n\r\n            return scope_Pips;\r\n        }\r\n\r\n        // Shorthand for base dimensions.\r\n        function baseSize() {\r\n            var rect = scope_Base.getBoundingClientRect();\r\n            var alt = "offset" + ["Width", "Height"][options.ort];\r\n            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];\r\n        }\r\n\r\n        // Handler for attaching events trough a proxy.\r\n        function attachEvent(events, element, callback, data) {\r\n            // This function can be used to \'filter\' events to the slider.\r\n            // element is a node, not a nodeList\r\n\r\n            var method = function(e) {\r\n                e = fixEvent(e, data.pageOffset, data.target || element);\r\n\r\n                // fixEvent returns false if this event has a different target\r\n                // when handling (multi-) touch events;\r\n                if (!e) {\r\n                    return false;\r\n                }\r\n\r\n                // doNotReject is passed by all end events to make sure released touches\r\n                // are not rejected, leaving the slider "stuck" to the cursor;\r\n                if (isSliderDisabled() && !data.doNotReject) {\r\n                    return false;\r\n                }\r\n\r\n                // Stop if an active \'tap\' transition is taking place.\r\n                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {\r\n                    return false;\r\n                }\r\n\r\n                // Ignore right or middle clicks on start #454\r\n                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {\r\n                    return false;\r\n                }\r\n\r\n                // Ignore right or middle clicks on start #454\r\n                if (data.hover && e.buttons) {\r\n                    return false;\r\n                }\r\n\r\n                // \'supportsPassive\' is only true if a browser also supports touch-action: none in CSS.\r\n                // iOS safari does not, so it doesn\'t get to benefit from passive scrolling. iOS does support\r\n                // touch-action: manipulation, but that allows panning, which breaks\r\n                // sliders after zooming/on non-responsive pages.\r\n                // See: https://bugs.webkit.org/show_bug.cgi?id=133112\r\n                if (!supportsPassive) {\r\n                    e.preventDefault();\r\n                }\r\n\r\n                e.calcPoint = e.points[options.ort];\r\n\r\n                // Call the event handler with the event [ and additional data ].\r\n                callback(e, data);\r\n            };\r\n\r\n            var methods = [];\r\n\r\n            // Bind a closure on the target for every event type.\r\n            events.split(" ").forEach(function(eventName) {\r\n                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);\r\n                methods.push([eventName, method]);\r\n            });\r\n\r\n            return methods;\r\n        }\r\n\r\n        // Provide a clean event with standardized offset values.\r\n        function fixEvent(e, pageOffset, eventTarget) {\r\n            // Filter the event to register the type, which can be\r\n            // touch, mouse or pointer. Offset changes need to be\r\n            // made on an event specific basis.\r\n            var touch = e.type.indexOf("touch") === 0;\r\n            var mouse = e.type.indexOf("mouse") === 0;\r\n            var pointer = e.type.indexOf("pointer") === 0;\r\n\r\n            var x;\r\n            var y;\r\n\r\n            // IE10 implemented pointer events with a prefix;\r\n            if (e.type.indexOf("MSPointer") === 0) {\r\n                pointer = true;\r\n            }\r\n\r\n            // The only thing one handle should be concerned about is the touches that originated on top of it.\r\n            if (touch) {\r\n                // Returns true if a touch originated on the target.\r\n                var isTouchOnTarget = function(checkTouch) {\r\n                    return checkTouch.target === eventTarget || eventTarget.contains(checkTouch.target);\r\n                };\r\n\r\n                // In the case of touchstart events, we need to make sure there is still no more than one\r\n                // touch on the target so we look amongst all touches.\r\n                if (e.type === "touchstart") {\r\n                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);\r\n\r\n                    // Do not support more than one touch per handle.\r\n                    if (targetTouches.length > 1) {\r\n                        return false;\r\n                    }\r\n\r\n                    x = targetTouches[0].pageX;\r\n                    y = targetTouches[0].pageY;\r\n                } else {\r\n                    // In the other cases, find on changedTouches is enough.\r\n                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);\r\n\r\n                    // Cancel if the target touch has not moved.\r\n                    if (!targetTouch) {\r\n                        return false;\r\n                    }\r\n\r\n                    x = targetTouch.pageX;\r\n                    y = targetTouch.pageY;\r\n                }\r\n            }\r\n\r\n            pageOffset = pageOffset || getPageOffset(scope_Document);\r\n\r\n            if (mouse || pointer) {\r\n                x = e.clientX + pageOffset.x;\r\n                y = e.clientY + pageOffset.y;\r\n            }\r\n\r\n            e.pageOffset = pageOffset;\r\n            e.points = [x, y];\r\n            e.cursor = mouse || pointer; // Fix #435\r\n\r\n            return e;\r\n        }\r\n\r\n        // Translate a coordinate in the document to a percentage on the slider\r\n        function calcPointToPercentage(calcPoint) {\r\n            var location = calcPoint - offset(scope_Base, options.ort);\r\n            var proposal = (location * 100) / baseSize();\r\n\r\n            // Clamp proposal between 0% and 100%\r\n            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements\r\n            // are used (e.g. contained handles feature)\r\n            proposal = limit(proposal);\r\n\r\n            return options.dir ? 100 - proposal : proposal;\r\n        }\r\n\r\n        // Find handle closest to a certain percentage on the slider\r\n        function getClosestHandle(proposal) {\r\n            var closest = 100;\r\n            var handleNumber = false;\r\n\r\n            scope_Handles.forEach(function(handle, index) {\r\n                // Disabled handles are ignored\r\n                if (isHandleDisabled(index)) {\r\n                    return;\r\n                }\r\n\r\n                var pos = Math.abs(scope_Locations[index] - proposal);\r\n\r\n                if (pos < closest || (pos === 100 && closest === 100)) {\r\n                    handleNumber = index;\r\n                    closest = pos;\r\n                }\r\n            });\r\n\r\n            return handleNumber;\r\n        }\r\n\r\n        // Fire \'end\' when a mouse or pen leaves the document.\r\n        function documentLeave(event, data) {\r\n            if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {\r\n                eventEnd(event, data);\r\n            }\r\n        }\r\n\r\n        // Handle movement on document for handle and range drag.\r\n        function eventMove(event, data) {\r\n            // Fix #498\r\n            // Check value of .buttons in \'start\' to work around a bug in IE10 mobile (data.buttonsProperty).\r\n            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\r\n            // IE9 has .buttons and .which zero on mousemove.\r\n            // Firefox breaks the spec MDN defines.\r\n            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {\r\n                return eventEnd(event, data);\r\n            }\r\n\r\n            // Check if we are moving up or down\r\n            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\r\n\r\n            // Convert the movement into a percentage of the slider width/height\r\n            var proposal = (movement * 100) / data.baseSize;\r\n\r\n            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\r\n        }\r\n\r\n        // Unbind move events on document, call callbacks.\r\n        function eventEnd(event, data) {\r\n            // The handle is no longer active, so remove the class.\r\n            if (data.handle) {\r\n                removeClass(data.handle, options.cssClasses.active);\r\n                scope_ActiveHandlesCount -= 1;\r\n            }\r\n\r\n            // Unbind the move and end events, which are added on \'start\'.\r\n            data.listeners.forEach(function(c) {\r\n                scope_DocumentElement.removeEventListener(c[0], c[1]);\r\n            });\r\n\r\n            if (scope_ActiveHandlesCount === 0) {\r\n                // Remove dragging class.\r\n                removeClass(scope_Target, options.cssClasses.drag);\r\n                setZindex();\r\n\r\n                // Remove cursor styles and text-selection events bound to the body.\r\n                if (event.cursor) {\r\n                    scope_Body.style.cursor = "";\r\n                    scope_Body.removeEventListener("selectstart", preventDefault);\r\n                }\r\n            }\r\n\r\n            data.handleNumbers.forEach(function(handleNumber) {\r\n                fireEvent("change", handleNumber);\r\n                fireEvent("set", handleNumber);\r\n                fireEvent("end", handleNumber);\r\n            });\r\n        }\r\n\r\n        // Bind move events on document.\r\n        function eventStart(event, data) {\r\n            // Ignore event if any handle is disabled\r\n            if (data.handleNumbers.some(isHandleDisabled)) {\r\n                return false;\r\n            }\r\n\r\n            var handle;\r\n\r\n            if (data.handleNumbers.length === 1) {\r\n                var handleOrigin = scope_Handles[data.handleNumbers[0]];\r\n\r\n                handle = handleOrigin.children[0];\r\n                scope_ActiveHandlesCount += 1;\r\n\r\n                // Mark the handle as \'active\' so it can be styled.\r\n                addClass(handle, options.cssClasses.active);\r\n            }\r\n\r\n            // A drag should never propagate up to the \'tap\' event.\r\n            event.stopPropagation();\r\n\r\n            // Record the event listeners.\r\n            var listeners = [];\r\n\r\n            // Attach the move and end events.\r\n            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\r\n                // The event target has changed so we need to propagate the original one so that we keep\r\n                // relying on it to extract target touches.\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                startCalcPoint: event.calcPoint,\r\n                baseSize: baseSize(),\r\n                pageOffset: event.pageOffset,\r\n                handleNumbers: data.handleNumbers,\r\n                buttonsProperty: event.buttons,\r\n                locations: scope_Locations.slice()\r\n            });\r\n\r\n            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                doNotReject: true,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n\r\n            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                doNotReject: true,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n\r\n            // We want to make sure we pushed the listeners in the listener list rather than creating\r\n            // a new one as it has already been passed to the event handlers.\r\n            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));\r\n\r\n            // Text selection isn\'t an issue on touch devices,\r\n            // so adding cursor styles can be skipped.\r\n            if (event.cursor) {\r\n                // Prevent the \'I\' cursor and extend the range-drag cursor.\r\n                scope_Body.style.cursor = getComputedStyle(event.target).cursor;\r\n\r\n                // Mark the target with a dragging state.\r\n                if (scope_Handles.length > 1) {\r\n                    addClass(scope_Target, options.cssClasses.drag);\r\n                }\r\n\r\n                // Prevent text selection when dragging the handles.\r\n                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\r\n                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\r\n                // meaning the only holdout is iOS Safari. This doesn\'t matter: text selection isn\'t triggered there.\r\n                // The \'cursor\' flag is false.\r\n                // See: http://caniuse.com/#search=selectstart\r\n                scope_Body.addEventListener("selectstart", preventDefault, false);\r\n            }\r\n\r\n            data.handleNumbers.forEach(function(handleNumber) {\r\n                fireEvent("start", handleNumber);\r\n            });\r\n        }\r\n\r\n        // Move closest handle to tapped location.\r\n        function eventTap(event) {\r\n            // The tap event shouldn\'t propagate up\r\n            event.stopPropagation();\r\n\r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n            var handleNumber = getClosestHandle(proposal);\r\n\r\n            // Tackle the case that all handles are \'disabled\'.\r\n            if (handleNumber === false) {\r\n                return false;\r\n            }\r\n\r\n            // Flag the slider as it is now in a transitional state.\r\n            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\r\n            if (!options.events.snap) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n\r\n            setHandle(handleNumber, proposal, true, true);\r\n\r\n            setZindex();\r\n\r\n            fireEvent("slide", handleNumber, true);\r\n            fireEvent("update", handleNumber, true);\r\n            fireEvent("change", handleNumber, true);\r\n            fireEvent("set", handleNumber, true);\r\n\r\n            if (options.events.snap) {\r\n                eventStart(event, { handleNumbers: [handleNumber] });\r\n            }\r\n        }\r\n\r\n        // Fires a \'hover\' event for a hovered mouse/pen position.\r\n        function eventHover(event) {\r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n\r\n            var to = scope_Spectrum.getStep(proposal);\r\n            var value = scope_Spectrum.fromStepping(to);\r\n\r\n            Object.keys(scope_Events).forEach(function(targetEvent) {\r\n                if ("hover" === targetEvent.split(".")[0]) {\r\n                    scope_Events[targetEvent].forEach(function(callback) {\r\n                        callback.call(scope_Self, value);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        // Handles keydown on focused handles\r\n        // Don\'t move the document when pressing arrow keys on focused handles\r\n        function eventKeydown(event, handleNumber) {\r\n            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {\r\n                return false;\r\n            }\r\n\r\n            var horizontalKeys = ["Left", "Right"];\r\n            var verticalKeys = ["Down", "Up"];\r\n\r\n            if (options.dir && !options.ort) {\r\n                // On an right-to-left slider, the left and right keys act inverted\r\n                horizontalKeys.reverse();\r\n            } else if (options.ort && !options.dir) {\r\n                // On a top-to-bottom slider, the up and down keys act inverted\r\n                verticalKeys.reverse();\r\n            }\r\n\r\n            // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n            var key = event.key.replace("Arrow", "");\r\n            var isDown = key === verticalKeys[0] || key === horizontalKeys[0];\r\n            var isUp = key === verticalKeys[1] || key === horizontalKeys[1];\r\n\r\n            if (!isDown && !isUp) {\r\n                return true;\r\n            }\r\n\r\n            event.preventDefault();\r\n\r\n            var direction = isDown ? 0 : 1;\r\n            var steps = getNextStepsForHandle(handleNumber);\r\n            var step = steps[direction];\r\n\r\n            // At the edge of a slider, do nothing\r\n            if (step === null) {\r\n                return false;\r\n            }\r\n\r\n            // No step set, use the default of 10% of the sub-range\r\n            if (step === false) {\r\n                step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, 10);\r\n            }\r\n\r\n            // Step over zero-length ranges (#948);\r\n            step = Math.max(step, 0.0000001);\r\n\r\n            // Decrement for down steps\r\n            step = (isDown ? -1 : 1) * step;\r\n\r\n            valueSetHandle(handleNumber, scope_Values[handleNumber] + step, true);\r\n\r\n            return false;\r\n        }\r\n\r\n        // Attach events to several slider parts.\r\n        function bindSliderEvents(behaviour) {\r\n            // Attach the standard drag event to the handles.\r\n            if (!behaviour.fixed) {\r\n                scope_Handles.forEach(function(handle, index) {\r\n                    // These events are only bound to the visual handle\r\n                    // element, not the \'real\' origin element.\r\n                    attachEvent(actions.start, handle.children[0], eventStart, {\r\n                        handleNumbers: [index]\r\n                    });\r\n                });\r\n            }\r\n\r\n            // Attach the tap event to the slider base.\r\n            if (behaviour.tap) {\r\n                attachEvent(actions.start, scope_Base, eventTap, {});\r\n            }\r\n\r\n            // Fire hover events\r\n            if (behaviour.hover) {\r\n                attachEvent(actions.move, scope_Base, eventHover, {\r\n                    hover: true\r\n                });\r\n            }\r\n\r\n            // Make the range draggable.\r\n            if (behaviour.drag) {\r\n                scope_Connects.forEach(function(connect, index) {\r\n                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {\r\n                        return;\r\n                    }\r\n\r\n                    var handleBefore = scope_Handles[index - 1];\r\n                    var handleAfter = scope_Handles[index];\r\n                    var eventHolders = [connect];\r\n\r\n                    addClass(connect, options.cssClasses.draggable);\r\n\r\n                    // When the range is fixed, the entire range can\r\n                    // be dragged by the handles. The handle in the first\r\n                    // origin will propagate the start event upward,\r\n                    // but it needs to be bound manually on the other.\r\n                    if (behaviour.fixed) {\r\n                        eventHolders.push(handleBefore.children[0]);\r\n                        eventHolders.push(handleAfter.children[0]);\r\n                    }\r\n\r\n                    eventHolders.forEach(function(eventHolder) {\r\n                        attachEvent(actions.start, eventHolder, eventStart, {\r\n                            handles: [handleBefore, handleAfter],\r\n                            handleNumbers: [index - 1, index]\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        // Attach an event to this slider, possibly including a namespace\r\n        function bindEvent(namespacedEvent, callback) {\r\n            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\r\n            scope_Events[namespacedEvent].push(callback);\r\n\r\n            // If the event bound is \'update,\' fire it immediately for all handles.\r\n            if (namespacedEvent.split(".")[0] === "update") {\r\n                scope_Handles.forEach(function(a, index) {\r\n                    fireEvent("update", index);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Undo attachment of event\r\n        function removeEvent(namespacedEvent) {\r\n            var event = namespacedEvent && namespacedEvent.split(".")[0];\r\n            var namespace = event && namespacedEvent.substring(event.length);\r\n\r\n            Object.keys(scope_Events).forEach(function(bind) {\r\n                var tEvent = bind.split(".")[0];\r\n                var tNamespace = bind.substring(tEvent.length);\r\n\r\n                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {\r\n                    delete scope_Events[bind];\r\n                }\r\n            });\r\n        }\r\n\r\n        // External event handling\r\n        function fireEvent(eventName, handleNumber, tap) {\r\n            Object.keys(scope_Events).forEach(function(targetEvent) {\r\n                var eventType = targetEvent.split(".")[0];\r\n\r\n                if (eventName === eventType) {\r\n                    scope_Events[targetEvent].forEach(function(callback) {\r\n                        callback.call(\r\n                            // Use the slider public API as the scope (\'this\')\r\n                            scope_Self,\r\n                            // Return values as array, so arg_1[arg_2] is always valid.\r\n                            scope_Values.map(options.format.to),\r\n                            // Handle index, 0 or 1\r\n                            handleNumber,\r\n                            // Un-formatted slider values\r\n                            scope_Values.slice(),\r\n                            // Event is fired by tap, true or false\r\n                            tap || false,\r\n                            // Left offset of the handle, in relation to the slider\r\n                            scope_Locations.slice()\r\n                        );\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        // Split out the handle positioning logic so the Move event can use it, too\r\n        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {\r\n            // For sliders with multiple handles, limit movement to the other handle.\r\n            // Apply the margin option by adding it to the handle positions.\r\n            if (scope_Handles.length > 1 && !options.events.unconstrained) {\r\n                if (lookBackward && handleNumber > 0) {\r\n                    to = Math.max(to, reference[handleNumber - 1] + options.margin);\r\n                }\r\n\r\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\r\n                    to = Math.min(to, reference[handleNumber + 1] - options.margin);\r\n                }\r\n            }\r\n\r\n            // The limit option has the opposite effect, limiting handles to a\r\n            // maximum distance from another. Limit must be > 0, as otherwise\r\n            // handles would be unmovable.\r\n            if (scope_Handles.length > 1 && options.limit) {\r\n                if (lookBackward && handleNumber > 0) {\r\n                    to = Math.min(to, reference[handleNumber - 1] + options.limit);\r\n                }\r\n\r\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\r\n                    to = Math.max(to, reference[handleNumber + 1] - options.limit);\r\n                }\r\n            }\r\n\r\n            // The padding option keeps the handles a certain distance from the\r\n            // edges of the slider. Padding must be > 0.\r\n            if (options.padding) {\r\n                if (handleNumber === 0) {\r\n                    to = Math.max(to, options.padding[0]);\r\n                }\r\n\r\n                if (handleNumber === scope_Handles.length - 1) {\r\n                    to = Math.min(to, 100 - options.padding[1]);\r\n                }\r\n            }\r\n\r\n            to = scope_Spectrum.getStep(to);\r\n\r\n            // Limit percentage to the 0 - 100 range\r\n            to = limit(to);\r\n\r\n            // Return false if handle can\'t move\r\n            if (to === reference[handleNumber] && !getValue) {\r\n                return false;\r\n            }\r\n\r\n            return to;\r\n        }\r\n\r\n        // Uses slider orientation to create CSS rules. a = base value;\r\n        function inRuleOrder(v, a) {\r\n            var o = options.ort;\r\n            return (o ? a : v) + ", " + (o ? v : a);\r\n        }\r\n\r\n        // Moves handle(s) by a percentage\r\n        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\r\n        function moveHandles(upward, proposal, locations, handleNumbers) {\r\n            var proposals = locations.slice();\r\n\r\n            var b = [!upward, upward];\r\n            var f = [upward, !upward];\r\n\r\n            // Copy handleNumbers so we don\'t change the dataset\r\n            handleNumbers = handleNumbers.slice();\r\n\r\n            // Check to see which handle is \'leading\'.\r\n            // If that one can\'t move the second can\'t either.\r\n            if (upward) {\r\n                handleNumbers.reverse();\r\n            }\r\n\r\n            // Step 1: get the maximum percentage that any of the handles can move\r\n            if (handleNumbers.length > 1) {\r\n                handleNumbers.forEach(function(handleNumber, o) {\r\n                    var to = checkHandlePosition(\r\n                        proposals,\r\n                        handleNumber,\r\n                        proposals[handleNumber] + proposal,\r\n                        b[o],\r\n                        f[o],\r\n                        false\r\n                    );\r\n\r\n                    // Stop if one of the handles can\'t move.\r\n                    if (to === false) {\r\n                        proposal = 0;\r\n                    } else {\r\n                        proposal = to - proposals[handleNumber];\r\n                        proposals[handleNumber] = to;\r\n                    }\r\n                });\r\n            }\r\n\r\n            // If using one handle, check backward AND forward\r\n            else {\r\n                b = f = [true];\r\n            }\r\n\r\n            var state = false;\r\n\r\n            // Step 2: Try to set the handles with the found percentage\r\n            handleNumbers.forEach(function(handleNumber, o) {\r\n                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\r\n            });\r\n\r\n            // Step 3: If a handle moved, fire events\r\n            if (state) {\r\n                handleNumbers.forEach(function(handleNumber) {\r\n                    fireEvent("update", handleNumber);\r\n                    fireEvent("slide", handleNumber);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Takes a base value and an offset. This offset is used for the connect bar size.\r\n        // In the initial design for this feature, the origin element was 1% wide.\r\n        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature\r\n        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223\r\n        function transformDirection(a, b) {\r\n            return options.dir ? 100 - a - b : a;\r\n        }\r\n\r\n        // Updates scope_Locations and scope_Values, updates visual state\r\n        function updateHandlePosition(handleNumber, to) {\r\n            // Update locations.\r\n            scope_Locations[handleNumber] = to;\r\n\r\n            // Convert the value to the slider stepping/range.\r\n            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\r\n\r\n            var rule = "translate(" + inRuleOrder(transformDirection(to, 0) - scope_DirOffset + "%", "0") + ")";\r\n            scope_Handles[handleNumber].style[options.transformRule] = rule;\r\n\r\n            updateConnect(handleNumber);\r\n            updateConnect(handleNumber + 1);\r\n        }\r\n\r\n        // Handles before the slider middle are stacked later = higher,\r\n        // Handles after the middle later is lower\r\n        // [[7] [8] .......... | .......... [5] [4]\r\n        function setZindex() {\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;\r\n                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);\r\n                scope_Handles[handleNumber].style.zIndex = zIndex;\r\n            });\r\n        }\r\n\r\n        // Test suggested values and apply margin, step.\r\n        function setHandle(handleNumber, to, lookBackward, lookForward) {\r\n            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);\r\n\r\n            if (to === false) {\r\n                return false;\r\n            }\r\n\r\n            updateHandlePosition(handleNumber, to);\r\n\r\n            return true;\r\n        }\r\n\r\n        // Updates style attribute for connect nodes\r\n        function updateConnect(index) {\r\n            // Skip connects set to false\r\n            if (!scope_Connects[index]) {\r\n                return;\r\n            }\r\n\r\n            var l = 0;\r\n            var h = 100;\r\n\r\n            if (index !== 0) {\r\n                l = scope_Locations[index - 1];\r\n            }\r\n\r\n            if (index !== scope_Connects.length - 1) {\r\n                h = scope_Locations[index];\r\n            }\r\n\r\n            // We use two rules:\r\n            // \'translate\' to change the left/top offset;\r\n            // \'scale\' to change the width of the element;\r\n            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)\r\n            var connectWidth = h - l;\r\n            var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";\r\n            var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";\r\n\r\n            scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;\r\n        }\r\n\r\n        // Parses value passed to .set method. Returns current value if not parse-able.\r\n        function resolveToValue(to, handleNumber) {\r\n            // Setting with null indicates an \'ignore\'.\r\n            // Inputting \'false\' is invalid.\r\n            if (to === null || to === false || to === undefined) {\r\n                return scope_Locations[handleNumber];\r\n            }\r\n\r\n            // If a formatted number was passed, attempt to decode it.\r\n            if (typeof to === "number") {\r\n                to = String(to);\r\n            }\r\n\r\n            to = options.format.from(to);\r\n            to = scope_Spectrum.toStepping(to);\r\n\r\n            // If parsing the number failed, use the current value.\r\n            if (to === false || isNaN(to)) {\r\n                return scope_Locations[handleNumber];\r\n            }\r\n\r\n            return to;\r\n        }\r\n\r\n        // Set the slider value.\r\n        function valueSet(input, fireSetEvent) {\r\n            var values = asArray(input);\r\n            var isInit = scope_Locations[0] === undefined;\r\n\r\n            // Event fires by default\r\n            fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;\r\n\r\n            // Animation is optional.\r\n            // Make sure the initial values were set before using animated placement.\r\n            if (options.animate && !isInit) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n\r\n            // First pass, without lookAhead but with lookBackward. Values are set from left to right.\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false);\r\n            });\r\n\r\n            // Second pass. Now that all base values are set, apply constraints\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                setHandle(handleNumber, scope_Locations[handleNumber], true, true);\r\n            });\r\n\r\n            setZindex();\r\n\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                fireEvent("update", handleNumber);\r\n\r\n                // Fire the event only for handles that received a new value, as per #579\r\n                if (values[handleNumber] !== null && fireSetEvent) {\r\n                    fireEvent("set", handleNumber);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Reset slider to initial values\r\n        function valueReset(fireSetEvent) {\r\n            valueSet(options.start, fireSetEvent);\r\n        }\r\n\r\n        // Set value for a single handle\r\n        function valueSetHandle(handleNumber, value, fireSetEvent) {\r\n            // Ensure numeric input\r\n            handleNumber = Number(handleNumber);\r\n\r\n            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {\r\n                throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);\r\n            }\r\n\r\n            // Look both backward and forward, since we don\'t want this handle to "push" other handles (#960);\r\n            setHandle(handleNumber, resolveToValue(value, handleNumber), true, true);\r\n\r\n            fireEvent("update", handleNumber);\r\n\r\n            if (fireSetEvent) {\r\n                fireEvent("set", handleNumber);\r\n            }\r\n        }\r\n\r\n        // Get the slider value.\r\n        function valueGet() {\r\n            var values = scope_Values.map(options.format.to);\r\n\r\n            // If only one handle is used, return a single value.\r\n            if (values.length === 1) {\r\n                return values[0];\r\n            }\r\n\r\n            return values;\r\n        }\r\n\r\n        // Removes classes from the root and empties it.\r\n        function destroy() {\r\n            for (var key in options.cssClasses) {\r\n                if (!options.cssClasses.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n                removeClass(scope_Target, options.cssClasses[key]);\r\n            }\r\n\r\n            while (scope_Target.firstChild) {\r\n                scope_Target.removeChild(scope_Target.firstChild);\r\n            }\r\n\r\n            delete scope_Target.noUiSlider;\r\n        }\r\n\r\n        function getNextStepsForHandle(handleNumber) {\r\n            var location = scope_Locations[handleNumber];\r\n            var nearbySteps = scope_Spectrum.getNearbySteps(location);\r\n            var value = scope_Values[handleNumber];\r\n            var increment = nearbySteps.thisStep.step;\r\n            var decrement = null;\r\n\r\n            // If snapped, directly use defined step value\r\n            if (options.snap) {\r\n                return [\r\n                    value - nearbySteps.stepBefore.startValue || null,\r\n                    nearbySteps.stepAfter.startValue - value || null\r\n                ];\r\n            }\r\n\r\n            // If the next value in this step moves into the next step,\r\n            // the increment is the start of the next step - the current value\r\n            if (increment !== false) {\r\n                if (value + increment > nearbySteps.stepAfter.startValue) {\r\n                    increment = nearbySteps.stepAfter.startValue - value;\r\n                }\r\n            }\r\n\r\n            // If the value is beyond the starting point\r\n            if (value > nearbySteps.thisStep.startValue) {\r\n                decrement = nearbySteps.thisStep.step;\r\n            } else if (nearbySteps.stepBefore.step === false) {\r\n                decrement = false;\r\n            }\r\n\r\n            // If a handle is at the start of a step, it always steps back into the previous step first\r\n            else {\r\n                decrement = value - nearbySteps.stepBefore.highestStep;\r\n            }\r\n\r\n            // Now, if at the slider edges, there is no in/decrement\r\n            if (location === 100) {\r\n                increment = null;\r\n            } else if (location === 0) {\r\n                decrement = null;\r\n            }\r\n\r\n            // As per #391, the comparison for the decrement step can have some rounding issues.\r\n            var stepDecimals = scope_Spectrum.countStepDecimals();\r\n\r\n            // Round per #391\r\n            if (increment !== null && increment !== false) {\r\n                increment = Number(increment.toFixed(stepDecimals));\r\n            }\r\n\r\n            if (decrement !== null && decrement !== false) {\r\n                decrement = Number(decrement.toFixed(stepDecimals));\r\n            }\r\n\r\n            return [decrement, increment];\r\n        }\r\n\r\n        // Get the current step size for the slider.\r\n        function getNextSteps() {\r\n            return scope_HandleNumbers.map(getNextStepsForHandle);\r\n        }\r\n\r\n        // Updateable: margin, limit, padding, step, range, animate, snap\r\n        function updateOptions(optionsToUpdate, fireSetEvent) {\r\n            // Spectrum is created using the range, snap, direction and step options.\r\n            // \'snap\' and \'step\' can be updated.\r\n            // If \'snap\' and \'step\' are not passed, they should remain unchanged.\r\n            var v = valueGet();\r\n\r\n            var updateAble = [\r\n                "margin",\r\n                "limit",\r\n                "padding",\r\n                "range",\r\n                "animate",\r\n                "snap",\r\n                "step",\r\n                "format",\r\n                "pips",\r\n                "tooltips"\r\n            ];\r\n\r\n            // Only change options that we\'re actually passed to update.\r\n            updateAble.forEach(function(name) {\r\n                // Check for undefined. null removes the value.\r\n                if (optionsToUpdate[name] !== undefined) {\r\n                    originalOptions[name] = optionsToUpdate[name];\r\n                }\r\n            });\r\n\r\n            var newOptions = testOptions(originalOptions);\r\n\r\n            // Load new options into the slider state\r\n            updateAble.forEach(function(name) {\r\n                if (optionsToUpdate[name] !== undefined) {\r\n                    options[name] = newOptions[name];\r\n                }\r\n            });\r\n\r\n            scope_Spectrum = newOptions.spectrum;\r\n\r\n            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\r\n            options.margin = newOptions.margin;\r\n            options.limit = newOptions.limit;\r\n            options.padding = newOptions.padding;\r\n\r\n            // Update pips, removes existing.\r\n            if (options.pips) {\r\n                pips(options.pips);\r\n            } else {\r\n                removePips();\r\n            }\r\n\r\n            // Update tooltips, removes existing.\r\n            if (options.tooltips) {\r\n                tooltips();\r\n            } else {\r\n                removeTooltips();\r\n            }\r\n\r\n            // Invalidate the current positioning so valueSet forces an update.\r\n            scope_Locations = [];\r\n            valueSet(optionsToUpdate.start || v, fireSetEvent);\r\n        }\r\n\r\n        // Initialization steps\r\n        function setupSlider() {\r\n            // Create the base element, initialize HTML and set classes.\r\n            // Add handles and connect elements.\r\n            scope_Base = addSlider(scope_Target);\r\n\r\n            addElements(options.connect, scope_Base);\r\n\r\n            // Attach user events.\r\n            bindSliderEvents(options.events);\r\n\r\n            // Use the public value method to set the start values.\r\n            valueSet(options.start);\r\n\r\n            if (options.pips) {\r\n                pips(options.pips);\r\n            }\r\n\r\n            if (options.tooltips) {\r\n                tooltips();\r\n            }\r\n\r\n            aria();\r\n        }\r\n\r\n        setupSlider();\r\n\r\n        // noinspection JSUnusedGlobalSymbols\r\n        scope_Self = {\r\n            destroy: destroy,\r\n            steps: getNextSteps,\r\n            on: bindEvent,\r\n            off: removeEvent,\r\n            get: valueGet,\r\n            set: valueSet,\r\n            setHandle: valueSetHandle,\r\n            reset: valueReset,\r\n            // Exposed for unit testing, don\'t use this in your application.\r\n            __moveHandles: function(a, b, c) {\r\n                moveHandles(a, b, scope_Locations, c);\r\n            },\r\n            options: originalOptions, // Issue #600, #678\r\n            updateOptions: updateOptions,\r\n            target: scope_Target, // Issue #597\r\n            removePips: removePips,\r\n            removeTooltips: removeTooltips,\r\n            pips: pips // Issue #594\r\n        };\r\n\r\n        return scope_Self;\r\n    }\r\n\r\n    // Run the standard initializer\r\n    function initialize(target, originalOptions) {\r\n        if (!target || !target.nodeName) {\r\n            throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);\r\n        }\r\n\r\n        // Throw an error if the slider was already initialized.\r\n        if (target.noUiSlider) {\r\n            throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");\r\n        }\r\n\r\n        // Test the options and create the slider environment;\r\n        var options = testOptions(originalOptions, target);\r\n        var api = scope(target, options, originalOptions);\r\n\r\n        target.noUiSlider = api;\r\n\r\n        return api;\r\n    }\r\n\r\n    // Use an object instead of a function for future expandability;\r\n    return {\r\n        // Exposed for unit testing, don\'t use this in your application.\r\n        __spectrum: Spectrum,\r\n        version: VERSION,\r\n        create: initialize\r\n    };\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuanM/ZTlmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRDtBQUNBLFFBQVEsaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzNCLEtBQUssTUFBTSxFQU1OO0FBQ0wsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLG9CQUFvQix3QkFBd0I7QUFDNUMsc0JBQXNCLDBCQUEwQjtBQUNoRCx3QkFBd0IsNEJBQTRCO0FBQ3BELG1CQUFtQix3QkFBd0I7QUFDM0Msc0JBQXNCLDJCQUEyQjtBQUNqRCxnQ0FBZ0MscUNBQXFDO0FBQ3JFLG9CQUFvQix3QkFBd0I7QUFDNUMsMEJBQTBCLCtCQUErQjtBQUN6RCxxQkFBcUIsMEJBQTBCO0FBQy9DLG9CQUFvQix5QkFBeUI7QUFDN0Msc0JBQXNCLDJCQUEyQjtBQUNqRCx3QkFBd0IsNEJBQTRCO0FBQ3BELHlCQUF5Qiw4QkFBOEI7QUFDdkQscUJBQXFCLDBCQUEwQjtBQUMvQyx1QkFBdUIsNEJBQTRCO0FBQ25ELDhCQUE4QixrQ0FBa0M7QUFDaEUsOEJBQThCLG1DQUFtQztBQUNqRSx3QkFBd0IsNEJBQTRCO0FBQ3BELHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSxnQkFBZ0I7QUFDL0Y7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBub3Vpc2xpZGVyIC0gMTMuMS40IC0gMy8yMC8yMDE5ICovXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgLy8gTm9kZS9Db21tb25KU1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgICAgICB3aW5kb3cubm9VaVNsaWRlciA9IGZhY3RvcnkoKTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24oKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgVkVSU0lPTiA9IFwiMTMuMS40XCI7XHJcblxyXG4gICAgLy9yZWdpb24gSGVscGVyIE1ldGhvZHNcclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRm9ybWF0dGVyKGVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkudG8gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW50cnkuZnJvbSA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcclxuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJpbmRhYmxlIHZlcnNpb25cclxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gYW4gYXJyYXkuXHJcbiAgICBmdW5jdGlvbiB1bmlxdWUoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzW2FdID8gKHRoaXNbYV0gPSB0cnVlKSA6IGZhbHNlO1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBjbG9zZXN0ICd0bycuXHJcbiAgICBmdW5jdGlvbiBjbG9zZXN0KHZhbHVlLCB0bykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3VycmVudCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cclxuICAgIGZ1bmN0aW9uIG9mZnNldChlbGVtLCBvcmllbnRhdGlvbikge1xyXG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xyXG4gICAgICAgIHZhciBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxyXG4gICAgICAgIC8vIEkgaGF2ZW4ndCBmb3VuZCBhIGZlYXR1cmUgZGV0ZWN0aW9uIHRoYXQgcHJvdmVzIHRoaXMuIFdvcnN0IGNhc2VcclxuICAgICAgICAvLyBzY2VuYXJpbyBvbiBtaXMtbWF0Y2g6IHRoZSAndGFwJyBmZWF0dXJlIG9uIGhvcml6b250YWwgc2xpZGVycyBicmVha3MuXHJcbiAgICAgICAgaWYgKC93ZWJraXQuKkNocm9tZS4qTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICAgICAgICBwYWdlT2Zmc2V0LnggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uXHJcbiAgICAgICAgICAgID8gcmVjdC50b3AgKyBwYWdlT2Zmc2V0LnkgLSBkb2NFbGVtLmNsaWVudFRvcFxyXG4gICAgICAgICAgICA6IHJlY3QubGVmdCArIHBhZ2VPZmZzZXQueCAtIGRvY0VsZW0uY2xpZW50TGVmdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIG51bWVyaWNhbC5cclxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmICFpc05hTihhKSAmJiBpc0Zpbml0ZShhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIGEgY2xhc3MgYW5kIHJlbW92ZXMgaXQgYWZ0ZXIgW2R1cmF0aW9uXSBtcy5cclxuICAgIGZ1bmN0aW9uIGFkZENsYXNzRm9yKGVsZW1lbnQsIGNsYXNzTmFtZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIExpbWl0cyBhIHZhbHVlIHRvIDAgLSAxMDBcclxuICAgIGZ1bmN0aW9uIGxpbWl0KGEpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV3JhcHMgYSB2YXJpYWJsZSBhcyBhbiBhcnJheSwgaWYgaXQgaXNuJ3Qgb25lIHlldC5cclxuICAgIC8vIE5vdGUgdGhhdCBhbiBpbnB1dCBhcnJheSBpcyByZXR1cm5lZCBieSByZWZlcmVuY2UhXHJcbiAgICBmdW5jdGlvbiBhc0FycmF5KGEpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ291bnRzIGRlY2ltYWxzXHJcbiAgICBmdW5jdGlvbiBjb3VudERlY2ltYWxzKG51bVN0cikge1xyXG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xyXG4gICAgICAgIHZhciBwaWVjZXMgPSBudW1TdHIuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIHJldHVybiBwaWVjZXMubGVuZ3RoID4gMSA/IHBpZWNlc1sxXS5sZW5ndGggOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNhZGRfY2xhc3NcclxuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcclxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNyZW1vdmVfY2xhc3NcclxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcclxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShcclxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLFxyXG4gICAgICAgICAgICAgICAgXCIgXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXHJcbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdFxyXG4gICAgICAgICAgICA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXHJcbiAgICAgICAgICAgIDogbmV3IFJlZ0V4cChcIlxcXFxiXCIgKyBjbGFzc05hbWUgKyBcIlxcXFxiXCIpLnRlc3QoZWwuY2xhc3NOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Njcm9sbFkjTm90ZXNcclxuICAgIGZ1bmN0aW9uIGdldFBhZ2VPZmZzZXQoZG9jKSB7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGlzQ1NTMUNvbXBhdCA9IChkb2MuY29tcGF0TW9kZSB8fCBcIlwiKSA9PT0gXCJDU1MxQ29tcGF0XCI7XHJcbiAgICAgICAgdmFyIHggPSBzdXBwb3J0UGFnZU9mZnNldFxyXG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWE9mZnNldFxyXG4gICAgICAgICAgICA6IGlzQ1NTMUNvbXBhdFxyXG4gICAgICAgICAgICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcclxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsTGVmdDtcclxuICAgICAgICB2YXIgeSA9IHN1cHBvcnRQYWdlT2Zmc2V0XHJcbiAgICAgICAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XHJcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XHJcbiAgICAgICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXHJcbiAgICAgICAgICAgICAgICA6IGRvYy5ib2R5LnNjcm9sbFRvcDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgY29uc3RhbnRzIGluc3RlYWRcclxuICAgIC8vIG9mIGFjY2Vzc2luZyB3aW5kb3cuKiBhcyBzb29uIGFzIHRoZSBtb2R1bGUgbmVlZHMgaXRcclxuICAgIC8vIHNvIHRoYXQgd2UgZG8gbm90IGNvbXB1dGUgYW55dGhpbmcgaWYgbm90IG5lZWRlZFxyXG4gICAgZnVuY3Rpb24gZ2V0QWN0aW9ucygpIHtcclxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGV2ZW50cyB0byBiaW5kLiBJRTExIGltcGxlbWVudHMgcG9pbnRlckV2ZW50cyB3aXRob3V0XHJcbiAgICAgICAgLy8gYSBwcmVmaXgsIHdoaWNoIGJyZWFrcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIElFMTAgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWRcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsXHJcbiAgICAgICAgICAgICAgICAgIG1vdmU6IFwicG9pbnRlcm1vdmVcIixcclxuICAgICAgICAgICAgICAgICAgZW5kOiBcInBvaW50ZXJ1cFwiXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtb3ZlOiBcIk1TUG9pbnRlck1vdmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogXCJNU1BvaW50ZXJVcFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBcIm1vdXNldXAgdG91Y2hlbmRcIlxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kXHJcbiAgICAvLyBJc3N1ZSAjNzg1XHJcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1Bhc3NpdmUoKSB7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93LkNTUyAmJiBDU1Muc3VwcG9ydHMgJiYgQ1NTLnN1cHBvcnRzKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2VuZHJlZ2lvblxyXG5cclxuICAgIC8vcmVnaW9uIFJhbmdlIENhbGN1bGF0aW9uXHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIGEgc3ViLXJhbmdlIGluIHJlbGF0aW9uIHRvIGEgZnVsbCByYW5nZS5cclxuICAgIGZ1bmN0aW9uIHN1YlJhbmdlUmF0aW8ocGEsIHBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDEwMCAvIChwYiAtIHBhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAocGVyY2VudGFnZSkgSG93IG1hbnkgcGVyY2VudCBpcyB0aGlzIHZhbHVlIG9mIHRoaXMgcmFuZ2U/XHJcbiAgICBmdW5jdGlvbiBmcm9tUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICogMTAwKSAvIChyYW5nZVsxXSAtIHJhbmdlWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAocGVyY2VudGFnZSkgV2hlcmUgaXMgdGhpcyB2YWx1ZSBvbiB0aGlzIHJhbmdlP1xyXG4gICAgZnVuY3Rpb24gdG9QZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tUGVyY2VudGFnZShyYW5nZSwgcmFuZ2VbMF0gPCAwID8gdmFsdWUgKyBNYXRoLmFicyhyYW5nZVswXSkgOiB2YWx1ZSAtIHJhbmdlWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xyXG4gICAgZnVuY3Rpb24gaXNQZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkpIC8gMTAwICsgcmFuZ2VbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Sih2YWx1ZSwgYXJyKSB7XHJcbiAgICAgICAgdmFyIGogPSAxO1xyXG5cclxuICAgICAgICB3aGlsZSAodmFsdWUgPj0gYXJyW2pdKSB7XHJcbiAgICAgICAgICAgIGogKz0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIChwZXJjZW50YWdlKSBJbnB1dCBhIHZhbHVlLCBmaW5kIHdoZXJlLCBvbiBhIHNjYWxlIG9mIDAtMTAwLCBpdCBhcHBsaWVzLlxyXG4gICAgZnVuY3Rpb24gdG9TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4VmFsKTtcclxuICAgICAgICB2YXIgdmEgPSB4VmFsW2ogLSAxXTtcclxuICAgICAgICB2YXIgdmIgPSB4VmFsW2pdO1xyXG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xyXG4gICAgICAgIHZhciBwYiA9IHhQY3Rbal07XHJcblxyXG4gICAgICAgIHJldHVybiBwYSArIHRvUGVyY2VudGFnZShbdmEsIHZiXSwgdmFsdWUpIC8gc3ViUmFuZ2VSYXRpbyhwYSwgcGIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICh2YWx1ZSkgSW5wdXQgYSBwZXJjZW50YWdlLCBmaW5kIHdoZXJlIGl0IGlzIG9uIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXHJcbiAgICBmdW5jdGlvbiBmcm9tU3RlcHBpbmcoeFZhbCwgeFBjdCwgdmFsdWUpIHtcclxuICAgICAgICAvLyBUaGVyZSBpcyBubyByYW5nZSBncm91cCB0aGF0IGZpdHMgMTAwXHJcbiAgICAgICAgaWYgKHZhbHVlID49IDEwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4geFZhbC5zbGljZSgtMSlbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xyXG4gICAgICAgIHZhciB2YSA9IHhWYWxbaiAtIDFdO1xyXG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XHJcbiAgICAgICAgdmFyIHBhID0geFBjdFtqIC0gMV07XHJcbiAgICAgICAgdmFyIHBiID0geFBjdFtqXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZShbdmEsIHZiXSwgKHZhbHVlIC0gcGEpICogc3ViUmFuZ2VSYXRpbyhwYSwgcGIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAocGVyY2VudGFnZSkgR2V0IHRoZSBzdGVwIHRoYXQgYXBwbGllcyBhdCBhIGNlcnRhaW4gdmFsdWUuXHJcbiAgICBmdW5jdGlvbiBnZXRTdGVwKHhQY3QsIHhTdGVwcywgc25hcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IDEwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xyXG4gICAgICAgIHZhciBhID0geFBjdFtqIC0gMV07XHJcbiAgICAgICAgdmFyIGIgPSB4UGN0W2pdO1xyXG5cclxuICAgICAgICAvLyBJZiAnc25hcCcgaXMgc2V0LCBzdGVwcyBhcmUgdXNlZCBhcyBmaXhlZCBwb2ludHMgb24gdGhlIHNsaWRlci5cclxuICAgICAgICBpZiAoc25hcCkge1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHBvc2l0aW9uLCBhIG9yIGIuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF4U3RlcHNbaiAtIDFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4UGN0W2ogLSAxXSArIGNsb3Nlc3QodmFsdWUgLSB4UGN0W2ogLSAxXSwgeFN0ZXBzW2ogLSAxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRW50cnlQb2ludChpbmRleCwgdmFsdWUsIHRoYXQpIHtcclxuICAgICAgICB2YXIgcGVyY2VudGFnZTtcclxuXHJcbiAgICAgICAgLy8gV3JhcCBudW1lcmljYWwgaW5wdXQgaW4gYW4gYXJyYXkuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWplY3QgYW55IGludmFsaWQgaW5wdXQsIGJ5IHRlc3Rpbmcgd2hldGhlciB2YWx1ZSBpcyBhbiBhcnJheS5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyBjb250YWlucyBpbnZhbGlkIHZhbHVlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXHJcbiAgICAgICAgaWYgKGluZGV4ID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgcGVyY2VudGFnZSA9IDEwMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChpbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dC5cclxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhwZXJjZW50YWdlKSB8fCAhaXNOdW1lcmljKHZhbHVlWzBdKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgdmFsdWUgaXNuJ3QgbnVtZXJpYy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB2YWx1ZXMuXHJcbiAgICAgICAgdGhhdC54UGN0LnB1c2gocGVyY2VudGFnZSk7XHJcbiAgICAgICAgdGhhdC54VmFsLnB1c2godmFsdWVbMF0pO1xyXG5cclxuICAgICAgICAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXHJcbiAgICAgICAgLy8gbG9nZ2luZyBjbGVhciwgc2V0IHN0ZXAgZXhwbGljaXRseS4gTWFrZSBzdXJlXHJcbiAgICAgICAgLy8gbm90IHRvIG92ZXJyaWRlIHRoZSAnc3RlcCcgc2V0dGluZyB3aXRoIGZhbHNlLlxyXG4gICAgICAgIGlmICghcGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC54U3RlcHNbMF0gPSB2YWx1ZVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoYXQueFN0ZXBzLnB1c2goaXNOYU4odmFsdWVbMV0pID8gZmFsc2UgOiB2YWx1ZVsxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RlcFBvaW50KGksIG4sIHRoYXQpIHtcclxuICAgICAgICAvLyBJZ25vcmUgJ2ZhbHNlJyBzdGVwcGluZy5cclxuICAgICAgICBpZiAoIW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCBvdmVyIHplcm8tbGVuZ3RoIHJhbmdlcyAoIzk0OCk7XHJcbiAgICAgICAgaWYgKHRoYXQueFZhbFtpXSA9PT0gdGhhdC54VmFsW2kgKyAxXSkge1xyXG4gICAgICAgICAgICB0aGF0LnhTdGVwc1tpXSA9IHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSB0aGF0LnhWYWxbaV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGYWN0b3IgdG8gcmFuZ2UgcmF0aW9cclxuICAgICAgICB0aGF0LnhTdGVwc1tpXSA9XHJcbiAgICAgICAgICAgIGZyb21QZXJjZW50YWdlKFt0aGF0LnhWYWxbaV0sIHRoYXQueFZhbFtpICsgMV1dLCBuKSAvIHN1YlJhbmdlUmF0aW8odGhhdC54UGN0W2ldLCB0aGF0LnhQY3RbaSArIDFdKTtcclxuXHJcbiAgICAgICAgdmFyIHRvdGFsU3RlcHMgPSAodGhhdC54VmFsW2kgKyAxXSAtIHRoYXQueFZhbFtpXSkgLyB0aGF0LnhOdW1TdGVwc1tpXTtcclxuICAgICAgICB2YXIgaGlnaGVzdFN0ZXAgPSBNYXRoLmNlaWwoTnVtYmVyKHRvdGFsU3RlcHMudG9GaXhlZCgzKSkgLSAxKTtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoYXQueFZhbFtpXSArIHRoYXQueE51bVN0ZXBzW2ldICogaGlnaGVzdFN0ZXA7XHJcblxyXG4gICAgICAgIHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZW5kcmVnaW9uXHJcblxyXG4gICAgLy9yZWdpb24gU3BlY3RydW1cclxuXHJcbiAgICBmdW5jdGlvbiBTcGVjdHJ1bShlbnRyeSwgc25hcCwgc2luZ2xlU3RlcCkge1xyXG4gICAgICAgIHRoaXMueFBjdCA9IFtdO1xyXG4gICAgICAgIHRoaXMueFZhbCA9IFtdO1xyXG4gICAgICAgIHRoaXMueFN0ZXBzID0gW3NpbmdsZVN0ZXAgfHwgZmFsc2VdO1xyXG4gICAgICAgIHRoaXMueE51bVN0ZXBzID0gW2ZhbHNlXTtcclxuICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XHJcblxyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICB2YXIgb3JkZXJlZCA9IFtdOyAvLyBbMCwgJ21pbiddLCBbMSwgJzUwJSddLCBbMiwgJ21heCddXHJcblxyXG4gICAgICAgIC8vIE1hcCB0aGUgb2JqZWN0IGtleXMgdG8gYW4gYXJyYXkuXHJcbiAgICAgICAgZm9yIChpbmRleCBpbiBlbnRyeSkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnkuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goW2VudHJ5W2luZGV4XSwgaW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU29ydCBhbGwgZW50cmllcyBieSB2YWx1ZSAobnVtZXJpYyBzb3J0KS5cclxuICAgICAgICBpZiAob3JkZXJlZC5sZW5ndGggJiYgdHlwZW9mIG9yZGVyZWRbMF1bMF0gPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhWzBdWzBdIC0gYlswXVswXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBlbnRyaWVzIHRvIHN1YnJhbmdlcy5cclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBvcmRlcmVkLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBoYW5kbGVFbnRyeVBvaW50KG9yZGVyZWRbaW5kZXhdWzFdLCBvcmRlcmVkW2luZGV4XVswXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgYWN0dWFsIHN0ZXAgdmFsdWVzLlxyXG4gICAgICAgIC8vIHhTdGVwcyBpcyBzb3J0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgeFBjdCBhbmQgeFZhbC5cclxuICAgICAgICB0aGlzLnhOdW1TdGVwcyA9IHRoaXMueFN0ZXBzLnNsaWNlKDApO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBudW1lcmljIHN0ZXBzIHRvIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdWJyYW5nZSB0aGV5IHJlcHJlc2VudC5cclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgaGFuZGxlU3RlcFBvaW50KGluZGV4LCB0aGlzLnhOdW1TdGVwc1tpbmRleF0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0TWFyZ2luID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMueE51bVN0ZXBzWzBdO1xyXG5cclxuICAgICAgICBpZiAoc3RlcCAmJiAodmFsdWUgLyBzdGVwKSAlIDEgIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbGltaXQnLCAnbWFyZ2luJyBhbmQgJ3BhZGRpbmcnIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHN0ZXAuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMueFBjdC5sZW5ndGggPT09IDIgPyBmcm9tUGVyY2VudGFnZSh0aGlzLnhWYWwsIHZhbHVlKSA6IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUudG9TdGVwcGluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmZyb21TdGVwcGluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdGVwcGluZyh0aGlzLnhWYWwsIHRoaXMueFBjdCwgdmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBnZXRTdGVwKHRoaXMueFBjdCwgdGhpcy54U3RlcHMsIHRoaXMuc25hcCwgdmFsdWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXREZWZhdWx0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlLCBpc0Rvd24sIHNpemUpIHtcclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHRoaXMueFBjdCk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gYXQgdGhlIHRvcCBvciBzdGVwcGluZyBkb3duLCBsb29rIGF0IHRoZSBwcmV2aW91cyBzdWItcmFuZ2VcclxuICAgICAgICBpZiAodmFsdWUgPT09IDEwMCB8fCAoaXNEb3duICYmIHZhbHVlID09PSB0aGlzLnhQY3RbaiAtIDFdKSkge1xyXG4gICAgICAgICAgICBqID0gTWF0aC5tYXgoaiAtIDEsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnhWYWxbal0gLSB0aGlzLnhWYWxbaiAtIDFdKSAvIHNpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXROZWFyYnlTdGVwcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGVwQmVmb3JlOiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDJdLFxyXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDJdLFxyXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDJdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRoaXNTdGVwOiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDFdLFxyXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDFdLFxyXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDFdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0ZXBBZnRlcjoge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2pdLFxyXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbal0sXHJcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmNvdW50U3RlcERlY2ltYWxzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN0ZXBEZWNpbWFscyA9IHRoaXMueE51bVN0ZXBzLm1hcChjb3VudERlY2ltYWxzKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgc3RlcERlY2ltYWxzKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3V0c2lkZSB0ZXN0aW5nXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlcCh0aGlzLnRvU3RlcHBpbmcodmFsdWUpKTtcclxuICAgIH07XHJcblxyXG4gICAgLy9lbmRyZWdpb25cclxuXHJcbiAgICAvL3JlZ2lvbiBPcHRpb25zXHJcblxyXG4gICAgLypcdEV2ZXJ5IGlucHV0IG9wdGlvbiBpcyB0ZXN0ZWQgYW5kIHBhcnNlZC4gVGhpcydsbCBwcmV2ZW50XHJcbiAgICAgICAgZW5kbGVzcyB2YWxpZGF0aW9uIGluIGludGVybmFsIG1ldGhvZHMuIFRoZXNlIHRlc3RzIGFyZVxyXG4gICAgICAgIHN0cnVjdHVyZWQgd2l0aCBhbiBpdGVtIGZvciBldmVyeSBvcHRpb24gYXZhaWxhYmxlLiBBblxyXG4gICAgICAgIG9wdGlvbiBjYW4gYmUgbWFya2VkIGFzIHJlcXVpcmVkIGJ5IHNldHRpbmcgdGhlICdyJyBmbGFnLlxyXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxyXG4gICAgICAgICAgICAtIFRoZSBwcm92aWRlZCB2YWx1ZSBmb3IgdGhlIG9wdGlvbjtcclxuICAgICAgICAgICAgLSBBIHJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvYmplY3Q7XHJcbiAgICAgICAgICAgIC0gVGhlIG5hbWUgZm9yIHRoZSBvcHRpb247XHJcblxyXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIHJldHVybnMgZmFsc2Ugd2hlbiBhbiBlcnJvciBpcyBkZXRlY3RlZCxcclxuICAgICAgICBvciB0cnVlIHdoZW4gZXZlcnl0aGluZyBpcyBPSy4gSXQgY2FuIGFsc28gbW9kaWZ5IHRoZSBvcHRpb25cclxuICAgICAgICBvYmplY3QsIHRvIG1ha2Ugc3VyZSBhbGwgdmFsdWVzIGNhbiBiZSBjb3JyZWN0bHkgbG9vcGVkIGVsc2V3aGVyZS4gKi9cclxuXHJcbiAgICB2YXIgZGVmYXVsdEZvcm1hdHRlciA9IHtcclxuICAgICAgICB0bzogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudG9GaXhlZCgyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyb206IE51bWJlclxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChlbnRyeSkge1xyXG4gICAgICAgIC8vIEFueSBvYmplY3Qgd2l0aCBhIHRvIGFuZCBmcm9tIG1ldGhvZCBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgICAgaWYgKGlzVmFsaWRGb3JtYXR0ZXIoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZm9ybWF0JyByZXF1aXJlcyAndG8nIGFuZCAnZnJvbScgbWV0aG9kcy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdzdGVwJyBpcyBub3QgbnVtZXJpYy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgc3RlcCBvcHRpb24gY2FuIHN0aWxsIGJlIHVzZWQgdG8gc2V0IHN0ZXBwaW5nXHJcbiAgICAgICAgLy8gZm9yIGxpbmVhciBzbGlkZXJzLiBPdmVyd3JpdHRlbiBpZiBzZXQgaW4gJ3JhbmdlJy5cclxuICAgICAgICBwYXJzZWQuc2luZ2xlU3RlcCA9IGVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RSYW5nZShwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gRmlsdGVyIGluY29ycmVjdCBpbnB1dC5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyBpcyBub3QgYW4gb2JqZWN0LlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhdGNoIG1pc3Npbmcgc3RhcnQgb3IgZW5kLlxyXG4gICAgICAgIGlmIChlbnRyeS5taW4gPT09IHVuZGVmaW5lZCB8fCBlbnRyeS5tYXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IE1pc3NpbmcgJ21pbicgb3IgJ21heCcgaW4gJ3JhbmdlJy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYXRjaCBlcXVhbCBzdGFydCBvciBlbmQuXHJcbiAgICAgICAgaWYgKGVudHJ5Lm1pbiA9PT0gZW50cnkubWF4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyAnbWluJyBhbmQgJ21heCcgY2Fubm90IGJlIGVxdWFsLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5zcGVjdHJ1bSA9IG5ldyBTcGVjdHJ1bShlbnRyeSwgcGFyc2VkLnNuYXAsIHBhcnNlZC5zaW5nbGVTdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0U3RhcnQocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XHJcblxyXG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0LiBWYWx1ZXMgYXJlbid0IHRlc3RlZCwgYXMgdGhlIHB1YmxpYyAudmFsIG1ldGhvZFxyXG4gICAgICAgIC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8ICFlbnRyeS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RvcmUgdGhlIG51bWJlciBvZiBoYW5kbGVzLlxyXG4gICAgICAgIHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSBzbGlkZXIgaXMgaW5pdGlhbGl6ZWQsIHRoZSAudmFsIG1ldGhvZCB3aWxsXHJcbiAgICAgICAgLy8gYmUgY2FsbGVkIHdpdGggdGhlIHN0YXJ0IG9wdGlvbnMuXHJcbiAgICAgICAgcGFyc2VkLnN0YXJ0ID0gZW50cnk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdFNuYXAocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIC8vIEVuZm9yY2UgMTAwJSBzdGVwcGluZyB3aXRoaW4gc3VicmFuZ2VzLlxyXG4gICAgICAgIHBhcnNlZC5zbmFwID0gZW50cnk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRlKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cclxuICAgICAgICBwYXJzZWQuYW5pbWF0ZSA9IGVudHJ5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0QW5pbWF0aW9uRHVyYXRpb24ocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIHBhcnNlZC5hbmltYXRpb25EdXJhdGlvbiA9IGVudHJ5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2FuaW1hdGlvbkR1cmF0aW9uJyBvcHRpb24gbXVzdCBiZSBhIG51bWJlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RDb25uZWN0KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICB2YXIgY29ubmVjdCA9IFtmYWxzZV07XHJcbiAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgIC8vIE1hcCBsZWdhY3kgb3B0aW9uc1xyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gXCJsb3dlclwiKSB7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gW3RydWUsIGZhbHNlXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSBcInVwcGVyXCIpIHtcclxuICAgICAgICAgICAgZW50cnkgPSBbZmFsc2UsIHRydWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGJvb2xlYW4gb3B0aW9uc1xyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gdHJ1ZSB8fCBlbnRyeSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHBhcnNlZC5oYW5kbGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3QucHVzaChlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbm5lY3QucHVzaChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWplY3QgaW52YWxpZCBpbnB1dFxyXG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoIHx8IGVudHJ5Lmxlbmd0aCAhPT0gcGFyc2VkLmhhbmRsZXMgKyAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2Nvbm5lY3QnIG9wdGlvbiBkb2Vzbid0IG1hdGNoIGhhbmRsZSBjb3VudC5cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29ubmVjdCA9IGVudHJ5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkLmNvbm5lY3QgPSBjb25uZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbihwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gU2V0IG9yaWVudGF0aW9uIHRvIGFuIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5XHJcbiAgICAgICAgLy8gYXJyYXkgc2VsZWN0aW9uLlxyXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcclxuICAgICAgICAgICAgICAgIHBhcnNlZC5vcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ29yaWVudGF0aW9uJyBvcHRpb24gaXMgaW52YWxpZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RNYXJnaW4ocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdtYXJnaW4nIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSXNzdWUgIzU4MlxyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJzZWQubWFyZ2luID0gcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeSk7XHJcblxyXG4gICAgICAgIGlmICghcGFyc2VkLm1hcmdpbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdtYXJnaW4nIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RMaW1pdChwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2xpbWl0JyBvcHRpb24gbXVzdCBiZSBudW1lcmljLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5saW1pdCA9IHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnkpO1xyXG5cclxuICAgICAgICBpZiAoIXBhcnNlZC5saW1pdCB8fCBwYXJzZWQuaGFuZGxlcyA8IDIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgVkVSU0lPTiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIpOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RQYWRkaW5nKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkgJiYgIUFycmF5LmlzQXJyYXkoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpICYmICEoZW50cnkubGVuZ3RoID09PSAyIHx8IGlzTnVtZXJpYyhlbnRyeVswXSkgfHwgaXNOdW1lcmljKGVudHJ5WzFdKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW50cnkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSkge1xyXG4gICAgICAgICAgICBlbnRyeSA9IFtlbnRyeSwgZW50cnldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ2dldE1hcmdpbicgcmV0dXJucyBmYWxzZSBmb3IgaW52YWxpZCB2YWx1ZXMuXHJcbiAgICAgICAgcGFyc2VkLnBhZGRpbmcgPSBbcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeVswXSksIHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnlbMV0pXTtcclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdID09PSBmYWxzZSB8fCBwYXJzZWQucGFkZGluZ1sxXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWQucGFkZGluZ1swXSA8IDAgfHwgcGFyc2VkLnBhZGRpbmdbMV0gPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKHMpLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWQucGFkZGluZ1swXSArIHBhcnNlZC5wYWRkaW5nWzFdID49IDEwMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBub3QgZXhjZWVkIDEwMCUgb2YgdGhlIHJhbmdlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdERpcmVjdGlvbihwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gU2V0IGRpcmVjdGlvbiBhcyBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeSBwYXJzaW5nLlxyXG4gICAgICAgIC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXHJcbiAgICAgICAgLy8gaGFuZGxlcyBnZXQgdGhlIGNvbm5lY3QvYmFja2dyb3VuZCBjbGFzc2VzLlxyXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImx0clwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLmRpciA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJ0bFwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLmRpciA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2RpcmVjdGlvbicgb3B0aW9uIHdhcyBub3QgcmVjb2duaXplZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RCZWhhdmlvdXIocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgYSBzdHJpbmcuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgYW55IGtleXdvcmRzLlxyXG4gICAgICAgIC8vIE5vbmUgYXJlIHJlcXVpcmVkLlxyXG4gICAgICAgIHZhciB0YXAgPSBlbnRyeS5pbmRleE9mKFwidGFwXCIpID49IDA7XHJcbiAgICAgICAgdmFyIGRyYWcgPSBlbnRyeS5pbmRleE9mKFwiZHJhZ1wiKSA+PSAwO1xyXG4gICAgICAgIHZhciBmaXhlZCA9IGVudHJ5LmluZGV4T2YoXCJmaXhlZFwiKSA+PSAwO1xyXG4gICAgICAgIHZhciBzbmFwID0gZW50cnkuaW5kZXhPZihcInNuYXBcIikgPj0gMDtcclxuICAgICAgICB2YXIgaG92ZXIgPSBlbnRyeS5pbmRleE9mKFwiaG92ZXJcIikgPj0gMDtcclxuICAgICAgICB2YXIgdW5jb25zdHJhaW5lZCA9IGVudHJ5LmluZGV4T2YoXCJ1bmNvbnN0cmFpbmVkXCIpID49IDA7XHJcblxyXG4gICAgICAgIGlmIChmaXhlZCkge1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkLmhhbmRsZXMgIT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2ZpeGVkJyBiZWhhdmlvdXIgbXVzdCBiZSB1c2VkIHdpdGggMiBoYW5kbGVzXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgbWFyZ2luIHRvIGVuZm9yY2UgZml4ZWQgc3RhdGVcclxuICAgICAgICAgICAgdGVzdE1hcmdpbihwYXJzZWQsIHBhcnNlZC5zdGFydFsxXSAtIHBhcnNlZC5zdGFydFswXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodW5jb25zdHJhaW5lZCAmJiAocGFyc2VkLm1hcmdpbiB8fCBwYXJzZWQubGltaXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndW5jb25zdHJhaW5lZCcgYmVoYXZpb3VyIGNhbm5vdCBiZSB1c2VkIHdpdGggbWFyZ2luIG9yIGxpbWl0XCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgIHRhcDogdGFwIHx8IHNuYXAsXHJcbiAgICAgICAgICAgIGRyYWc6IGRyYWcsXHJcbiAgICAgICAgICAgIGZpeGVkOiBmaXhlZCxcclxuICAgICAgICAgICAgc25hcDogc25hcCxcclxuICAgICAgICAgICAgaG92ZXI6IGhvdmVyLFxyXG4gICAgICAgICAgICB1bmNvbnN0cmFpbmVkOiB1bmNvbnN0cmFpbmVkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0VG9vbHRpcHMocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMucHVzaCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IGFzQXJyYXkoZW50cnkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhcnNlZC50b29sdGlwcy5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IG11c3QgcGFzcyBhIGZvcm1hdHRlciBmb3IgYWxsIGhhbmRsZXMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbihmb3JtYXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZm9ybWF0dGVyICE9PSBcImJvb2xlYW5cIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZm9ybWF0dGVyICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmb3JtYXR0ZXIudG8gIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3Rvb2x0aXBzJyBtdXN0IGJlIHBhc3NlZCBhIGZvcm1hdHRlciBvciAnZmFsc2UnLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RBcmlhRm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBwYXJzZWQuYXJpYUZvcm1hdCA9IGVudHJ5O1xyXG4gICAgICAgIHZhbGlkYXRlRm9ybWF0KGVudHJ5KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0Rm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBwYXJzZWQuZm9ybWF0ID0gZW50cnk7XHJcbiAgICAgICAgdmFsaWRhdGVGb3JtYXQoZW50cnkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RLZXlib2FyZFN1cHBvcnQocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFN1cHBvcnQgPSBlbnRyeTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAna2V5Ym9hcmRTdXBwb3J0JyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0RG9jdW1lbnRFbGVtZW50KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGFuIGFkdmFuY2VkIG9wdGlvbi4gUGFzc2VkIHZhbHVlcyBhcmUgdXNlZCB3aXRob3V0IHZhbGlkYXRpb24uXHJcbiAgICAgICAgcGFyc2VkLmRvY3VtZW50RWxlbWVudCA9IGVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RDc3NQcmVmaXgocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwic3RyaW5nXCIgJiYgZW50cnkgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2Nzc1ByZWZpeCcgbXVzdCBiZSBhIHN0cmluZyBvciBgZmFsc2VgLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5jc3NQcmVmaXggPSBlbnRyeTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0Q3NzQ2xhc3NlcyhwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjc3NDbGFzc2VzJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZC5jc3NQcmVmaXggPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyeS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXNba2V5XSA9IHBhcnNlZC5jc3NQcmVmaXggKyBlbnRyeVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSBlbnRyeTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVzdCBhbGwgZGV2ZWxvcGVyIHNldHRpbmdzIGFuZCBwYXJzZSB0byBhc3N1bXB0aW9uLXNhZmUgdmFsdWVzLlxyXG4gICAgZnVuY3Rpb24gdGVzdE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIC8vIFRvIHByb3ZlIGEgZml4IGZvciAjNTM3LCBmcmVlemUgb3B0aW9ucyBoZXJlLlxyXG4gICAgICAgIC8vIElmIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gICAgICAgIC8vIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHZhciBwYXJzZWQgPSB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICAgICAgbGltaXQ6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgIGFuaW1hdGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAzMDAsXHJcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXHJcbiAgICAgICAgICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdHRlclxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFRlc3RzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcHJlc2VudGVkIGhlcmUuXHJcbiAgICAgICAgdmFyIHRlc3RzID0ge1xyXG4gICAgICAgICAgICBzdGVwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U3RlcCB9LFxyXG4gICAgICAgICAgICBzdGFydDogeyByOiB0cnVlLCB0OiB0ZXN0U3RhcnQgfSxcclxuICAgICAgICAgICAgY29ubmVjdDogeyByOiB0cnVlLCB0OiB0ZXN0Q29ubmVjdCB9LFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IHsgcjogdHJ1ZSwgdDogdGVzdERpcmVjdGlvbiB9LFxyXG4gICAgICAgICAgICBzbmFwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U25hcCB9LFxyXG4gICAgICAgICAgICBhbmltYXRlOiB7IHI6IGZhbHNlLCB0OiB0ZXN0QW5pbWF0ZSB9LFxyXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGlvbkR1cmF0aW9uIH0sXHJcbiAgICAgICAgICAgIHJhbmdlOiB7IHI6IHRydWUsIHQ6IHRlc3RSYW5nZSB9LFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogeyByOiBmYWxzZSwgdDogdGVzdE9yaWVudGF0aW9uIH0sXHJcbiAgICAgICAgICAgIG1hcmdpbjogeyByOiBmYWxzZSwgdDogdGVzdE1hcmdpbiB9LFxyXG4gICAgICAgICAgICBsaW1pdDogeyByOiBmYWxzZSwgdDogdGVzdExpbWl0IH0sXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IHsgcjogZmFsc2UsIHQ6IHRlc3RQYWRkaW5nIH0sXHJcbiAgICAgICAgICAgIGJlaGF2aW91cjogeyByOiB0cnVlLCB0OiB0ZXN0QmVoYXZpb3VyIH0sXHJcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RBcmlhRm9ybWF0IH0sXHJcbiAgICAgICAgICAgIGZvcm1hdDogeyByOiBmYWxzZSwgdDogdGVzdEZvcm1hdCB9LFxyXG4gICAgICAgICAgICB0b29sdGlwczogeyByOiBmYWxzZSwgdDogdGVzdFRvb2x0aXBzIH0sXHJcbiAgICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDogeyByOiB0cnVlLCB0OiB0ZXN0S2V5Ym9hcmRTdXBwb3J0IH0sXHJcbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudDogeyByOiBmYWxzZSwgdDogdGVzdERvY3VtZW50RWxlbWVudCB9LFxyXG4gICAgICAgICAgICBjc3NQcmVmaXg6IHsgcjogdHJ1ZSwgdDogdGVzdENzc1ByZWZpeCB9LFxyXG4gICAgICAgICAgICBjc3NDbGFzc2VzOiB7IHI6IHRydWUsIHQ6IHRlc3RDc3NDbGFzc2VzIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXHJcbiAgICAgICAgICAgIGJlaGF2aW91cjogXCJ0YXBcIixcclxuICAgICAgICAgICAgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGNzc1ByZWZpeDogXCJub1VpLVwiLFxyXG4gICAgICAgICAgICBjc3NDbGFzc2VzOiB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlOiBcImJhc2VcIixcclxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJvcmlnaW5cIixcclxuICAgICAgICAgICAgICAgIGhhbmRsZTogXCJoYW5kbGVcIixcclxuICAgICAgICAgICAgICAgIGhhbmRsZUxvd2VyOiBcImhhbmRsZS1sb3dlclwiLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlVXBwZXI6IFwiaGFuZGxlLXVwcGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0b3VjaEFyZWE6IFwidG91Y2gtYXJlYVwiLFxyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBjb25uZWN0OiBcImNvbm5lY3RcIixcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RzOiBcImNvbm5lY3RzXCIsXHJcbiAgICAgICAgICAgICAgICBsdHI6IFwibHRyXCIsXHJcbiAgICAgICAgICAgICAgICBydGw6IFwicnRsXCIsXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IFwiZHJhZ2dhYmxlXCIsXHJcbiAgICAgICAgICAgICAgICBkcmFnOiBcInN0YXRlLWRyYWdcIixcclxuICAgICAgICAgICAgICAgIHRhcDogXCJzdGF0ZS10YXBcIixcclxuICAgICAgICAgICAgICAgIGFjdGl2ZTogXCJhY3RpdmVcIixcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IFwidG9vbHRpcFwiLFxyXG4gICAgICAgICAgICAgICAgcGlwczogXCJwaXBzXCIsXHJcbiAgICAgICAgICAgICAgICBwaXBzSG9yaXpvbnRhbDogXCJwaXBzLWhvcml6b250YWxcIixcclxuICAgICAgICAgICAgICAgIHBpcHNWZXJ0aWNhbDogXCJwaXBzLXZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IFwibWFya2VyXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJIb3Jpem9udGFsOiBcIm1hcmtlci1ob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJWZXJ0aWNhbDogXCJtYXJrZXItdmVydGljYWxcIixcclxuICAgICAgICAgICAgICAgIG1hcmtlck5vcm1hbDogXCJtYXJrZXItbm9ybWFsXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJMYXJnZTogXCJtYXJrZXItbGFyZ2VcIixcclxuICAgICAgICAgICAgICAgIG1hcmtlclN1YjogXCJtYXJrZXItc3ViXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVIb3Jpem9udGFsOiBcInZhbHVlLWhvcml6b250YWxcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlVmVydGljYWw6IFwidmFsdWUtdmVydGljYWxcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlTm9ybWFsOiBcInZhbHVlLW5vcm1hbFwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVMYXJnZTogXCJ2YWx1ZS1sYXJnZVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVTdWI6IFwidmFsdWUtc3ViXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFyaWFGb3JtYXQgZGVmYXVsdHMgdG8gcmVndWxhciBmb3JtYXQsIGlmIGFueS5cclxuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgJiYgIW9wdGlvbnMuYXJpYUZvcm1hdCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmFyaWFGb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJ1biBhbGwgb3B0aW9ucyB0aHJvdWdoIGEgdGVzdGluZyBtZWNoYW5pc20gdG8gZW5zdXJlIGNvcnJlY3RcclxuICAgICAgICAvLyBpbnB1dC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgb3B0aW9ucyBtaWdodCBnZXQgbW9kaWZpZWQgdG9cclxuICAgICAgICAvLyBiZSBoYW5kbGVkIHByb3Blcmx5LiBFLmcuIHdyYXBwaW5nIGludGVnZXJzIGluIGFycmF5cy5cclxuICAgICAgICBPYmplY3Qua2V5cyh0ZXN0cykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXNuJ3Qgc2V0LCBidXQgaXQgaXMgcmVxdWlyZWQsIHRocm93IGFuIGVycm9yLlxyXG4gICAgICAgICAgICBpZiAoIWlzU2V0KG9wdGlvbnNbbmFtZV0pICYmIGRlZmF1bHRzW25hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0c1tuYW1lXS5yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGVzdHNbbmFtZV0udChwYXJzZWQsICFpc1NldChvcHRpb25zW25hbWVdKSA/IGRlZmF1bHRzW25hbWVdIDogb3B0aW9uc1tuYW1lXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEZvcndhcmQgcGlwcyBvcHRpb25zXHJcbiAgICAgICAgcGFyc2VkLnBpcHMgPSBvcHRpb25zLnBpcHM7XHJcblxyXG4gICAgICAgIC8vIEFsbCByZWNlbnQgYnJvd3NlcnMgYWNjZXB0IHVucHJlZml4ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgIC8vIFdlIG5lZWQgLW1zLSBmb3IgSUU5IGFuZCAtd2Via2l0LSBmb3Igb2xkZXIgQW5kcm9pZDtcclxuICAgICAgICAvLyBBc3N1bWUgdXNlIG9mIC13ZWJraXQtIGlmIHVucHJlZml4ZWQgYW5kIC1tcy0gYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD10cmFuc2Zvcm1zMmRcclxuICAgICAgICB2YXIgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdmFyIG1zUHJlZml4ID0gZC5zdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBub1ByZWZpeCA9IGQuc3R5bGUudHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHBhcnNlZC50cmFuc2Zvcm1SdWxlID0gbm9QcmVmaXggPyBcInRyYW5zZm9ybVwiIDogbXNQcmVmaXggPyBcIm1zVHJhbnNmb3JtXCIgOiBcIndlYmtpdFRyYW5zZm9ybVwiO1xyXG5cclxuICAgICAgICAvLyBQaXBzIGRvbid0IG1vdmUsIHNvIHdlIGNhbiBwbGFjZSB0aGVtIHVzaW5nIGxlZnQvdG9wLlxyXG4gICAgICAgIHZhciBzdHlsZXMgPSBbW1wibGVmdFwiLCBcInRvcFwiXSwgW1wicmlnaHRcIiwgXCJib3R0b21cIl1dO1xyXG5cclxuICAgICAgICBwYXJzZWQuc3R5bGUgPSBzdHlsZXNbcGFyc2VkLmRpcl1bcGFyc2VkLm9ydF07XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy9lbmRyZWdpb25cclxuXHJcbiAgICBmdW5jdGlvbiBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xyXG4gICAgICAgIHZhciBzdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSA9IGdldFN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lKCk7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IHN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lICYmIGdldFN1cHBvcnRzUGFzc2l2ZSgpO1xyXG5cclxuICAgICAgICAvLyBBbGwgdmFyaWFibGVzIGxvY2FsIHRvICdzY29wZScgYXJlIHByZWZpeGVkIHdpdGggJ3Njb3BlXydcclxuXHJcbiAgICAgICAgLy8gU2xpZGVyIERPTSBOb2Rlc1xyXG4gICAgICAgIHZhciBzY29wZV9UYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdmFyIHNjb3BlX0Jhc2U7XHJcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZXM7XHJcbiAgICAgICAgdmFyIHNjb3BlX0Nvbm5lY3RzO1xyXG4gICAgICAgIHZhciBzY29wZV9QaXBzO1xyXG4gICAgICAgIHZhciBzY29wZV9Ub29sdGlwcztcclxuXHJcbiAgICAgICAgLy8gU2xpZGVyIHN0YXRlIHZhbHVlc1xyXG4gICAgICAgIHZhciBzY29wZV9TcGVjdHJ1bSA9IG9wdGlvbnMuc3BlY3RydW07XHJcbiAgICAgICAgdmFyIHNjb3BlX1ZhbHVlcyA9IFtdO1xyXG4gICAgICAgIHZhciBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcclxuICAgICAgICB2YXIgc2NvcGVfSGFuZGxlTnVtYmVycyA9IFtdO1xyXG4gICAgICAgIHZhciBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBzY29wZV9FdmVudHMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gRXhwb3NlZCBBUElcclxuICAgICAgICB2YXIgc2NvcGVfU2VsZjtcclxuXHJcbiAgICAgICAgLy8gRG9jdW1lbnQgTm9kZXNcclxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcclxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5kb2N1bWVudEVsZW1lbnQgfHwgc2NvcGVfRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIHZhciBzY29wZV9Cb2R5ID0gc2NvcGVfRG9jdW1lbnQuYm9keTtcclxuXHJcbiAgICAgICAgLy8gUGlwcyBjb25zdGFudHNcclxuICAgICAgICB2YXIgUElQU19OT05FID0gLTE7XHJcbiAgICAgICAgdmFyIFBJUFNfTk9fVkFMVUUgPSAwO1xyXG4gICAgICAgIHZhciBQSVBTX0xBUkdFX1ZBTFVFID0gMTtcclxuICAgICAgICB2YXIgUElQU19TTUFMTF9WQUxVRSA9IDI7XHJcblxyXG4gICAgICAgIC8vIEZvciBob3Jpem9udGFsIHNsaWRlcnMgaW4gc3RhbmRhcmQgbHRyIGRvY3VtZW50cyxcclxuICAgICAgICAvLyBtYWtlIC5ub1VpLW9yaWdpbiBvdmVyZmxvdyB0byB0aGUgbGVmdCBzbyB0aGUgZG9jdW1lbnQgZG9lc24ndCBzY3JvbGwuXHJcbiAgICAgICAgdmFyIHNjb3BlX0Rpck9mZnNldCA9IHNjb3BlX0RvY3VtZW50LmRpciA9PT0gXCJydGxcIiB8fCBvcHRpb25zLm9ydCA9PT0gMSA/IDAgOiAxMDA7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBub2RlLCBhZGRzIGl0IHRvIHRhcmdldCwgcmV0dXJucyB0aGUgbmV3IG5vZGUuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkTm9kZVRvKGFkZFRhcmdldCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXYgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkaXY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgYSBvcmlnaW4gdG8gdGhlIGJhc2VcclxuICAgICAgICBmdW5jdGlvbiBhZGRPcmlnaW4oYmFzZSwgaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm9yaWdpbik7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGROb2RlVG8ob3JpZ2luLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlKTtcclxuXHJcbiAgICAgICAgICAgIGFkZE5vZGVUbyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50b3VjaEFyZWEpO1xyXG5cclxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImRhdGEtaGFuZGxlXCIsIGhhbmRsZU51bWJlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZFN1cHBvcnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcclxuICAgICAgICAgICAgICAgIC8vIDAgPSBmb2N1c2FibGUgYW5kIHJlYWNoYWJsZVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudEtleWRvd24oZXZlbnQsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzbGlkZXJcIik7XHJcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIG9wdGlvbnMub3J0ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlTG93ZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZU51bWJlciA9PT0gb3B0aW9ucy5oYW5kbGVzIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlVXBwZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0IG5vZGVzIGZvciBjb25uZWN0IGVsZW1lbnRzXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkQ29ubmVjdChiYXNlLCBhZGQpIHtcclxuICAgICAgICAgICAgaWYgKCFhZGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkRWxlbWVudHMoY29ubmVjdE9wdGlvbnMsIGJhc2UpIHtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RCYXNlID0gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0cyk7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzID0gW107XHJcbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzID0gW107XHJcblxyXG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cy5wdXNoKGFkZENvbm5lY3QoY29ubmVjdEJhc2UsIGNvbm5lY3RPcHRpb25zWzBdKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBbOjo6Ok89PT09Tz09PT1PPT09PV1cclxuICAgICAgICAgICAgLy8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5oYW5kbGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBhZGRlZCBoYW5kbGVzLlxyXG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5wdXNoKGFkZE9yaWdpbihiYXNlLCBpKSk7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzW2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbaSArIDFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYSBzaW5nbGUgc2xpZGVyLlxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFNsaWRlcihhZGRUYXJnZXQpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY2xhc3NlcyBhbmQgZGF0YSB0byB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5sdHIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMucnRsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3J0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5ob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZlcnRpY2FsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5iYXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvb2x0aXAoaGFuZGxlLCBoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhoYW5kbGUuZmlyc3RDaGlsZCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRvb2x0aXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNTbGlkZXJEaXNhYmxlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1RhcmdldC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERpc2FibGUgdGhlIHNsaWRlciBkcmFnZ2luZyBpZiBhbnkgaGFuZGxlIGlzIGRpc2FibGVkXHJcbiAgICAgICAgZnVuY3Rpb24gaXNIYW5kbGVEaXNhYmxlZChoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU9yaWdpbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvb2x0aXBzKCkge1xyXG4gICAgICAgICAgICBpZiAoc2NvcGVfVG9vbHRpcHMpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KFwidXBkYXRlLnRvb2x0aXBzXCIpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbih0b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0b29sdGlwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX1Rvb2x0aXBzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHRvb2x0aXBzIG9wdGlvbiBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxyXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBzKCkge1xyXG4gICAgICAgICAgICByZW1vdmVUb29sdGlwcygpO1xyXG5cclxuICAgICAgICAgICAgLy8gVG9vbHRpcHMgYXJlIGFkZGVkIHdpdGggb3B0aW9ucy50b29sdGlwcyBpbiBvcmlnaW5hbCBvcmRlci5cclxuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBzY29wZV9IYW5kbGVzLm1hcChhZGRUb29sdGlwKTtcclxuXHJcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZS50b29sdGlwc1wiLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlX1Rvb2x0aXBzW2hhbmRsZU51bWJlcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gdmFsdWVzW2hhbmRsZU51bWJlcl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdLnRvKHVuZW5jb2RlZFtoYW5kbGVOdW1iZXJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdLmlubmVySFRNTCA9IGZvcm1hdHRlZFZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFyaWEoKSB7XHJcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkLCB0YXAsIHBvc2l0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEFyaWEgVmFsdWVzIGZvciBhbGwgaGFuZGxlcywgYXMgYSBjaGFuZ2UgaW4gb25lIGNoYW5nZXMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgbmV4dC5cclxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbiA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBpbmRleCwgMCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBpbmRleCwgMTAwLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHBvc2l0aW9uc1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdHRlZCB2YWx1ZSBmb3IgZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gb3B0aW9ucy5hcmlhRm9ybWF0LnRvKHVuZW5jb2RlZFtpbmRleF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXAgdG8gc2xpZGVyIHJhbmdlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhtaW4pLnRvRml4ZWQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG1heCkudG9GaXhlZCgxKTtcclxuICAgICAgICAgICAgICAgICAgICBub3cgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobm93KS50b0ZpeGVkKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiLCBtaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWF4XCIsIG1heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIiwgbm93KTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgdGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cChtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQpIHtcclxuICAgICAgICAgICAgLy8gVXNlIHRoZSByYW5nZS5cclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwicmFuZ2VcIiB8fCBtb2RlID09PSBcInN0ZXBzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS54VmFsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJjb3VudFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzIDwgMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3ZhbHVlcycgKD49IDIpIHJlcXVpcmVkIGZvciBtb2RlICdjb3VudCcuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERpdmlkZSAwIC0gMTAwIGluICdjb3VudCcgcGFydHMuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB2YWx1ZXMgLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwcmVhZCA9IDEwMCAvIGludGVydmFsO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGludGVydmFsLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW50ZXJ2YWxdID0gaW50ZXJ2YWwgKiBzcHJlYWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goMTAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtb2RlID0gXCJwb3NpdGlvbnNcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwicG9zaXRpb25zXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hcCBhbGwgcGVyY2VudGFnZXMgdG8gb24tcmFuZ2UgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHN0ZXBwZWQgPyBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHZhbHVlKSA6IHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJ2YWx1ZXNcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIG11c3QgYmUgc3RlcHBlZCwgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgcGVyY2VudGFnZSBmaXJzdC5cclxuICAgICAgICAgICAgICAgIGlmIChzdGVwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoc2NvcGVfU3BlY3RydW0uZ2V0U3RlcChzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHZhbHVlKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIHNpbXBseSB1c2UgdGhlIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3ByZWFkKGRlbnNpdHksIG1vZGUsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNhZmVJbmNyZW1lbnQodmFsdWUsIGluY3JlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgZmxvYXRpbmcgcG9pbnQgdmFyaWFuY2UgYnkgZHJvcHBpbmcgdGhlIHNtYWxsZXN0IGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSArIGluY3JlbWVudCkudG9GaXhlZCg3KSAvIDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0ge307XHJcbiAgICAgICAgICAgIHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xyXG4gICAgICAgICAgICB2YXIgbGFzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsW3Njb3BlX1NwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBpZ25vcmVGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgaWdub3JlTGFzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgcHJldlBjdCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBncm91cCwgc29ydCBpdCBhbmQgZmlsdGVyIGF3YXkgYWxsIGR1cGxpY2F0ZXMuXHJcbiAgICAgICAgICAgIGdyb3VwID0gdW5pcXVlKFxyXG4gICAgICAgICAgICAgICAgZ3JvdXAuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByYW5nZSBzdGFydHMgd2l0aCB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcclxuICAgICAgICAgICAgICAgIGlnbm9yZUZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGlrZXdpc2UgZm9yIHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgaWYgKGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdICE9PSBsYXN0SW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAucHVzaChsYXN0SW5SYW5nZSk7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVMYXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihjdXJyZW50LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgYW5kIHRoZSBsb3dlciArIHVwcGVyIHBvc2l0aW9ucy5cclxuICAgICAgICAgICAgICAgIHZhciBzdGVwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcTtcclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBncm91cFtpbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1BjdDtcclxuICAgICAgICAgICAgICAgIHZhciBwY3REaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBjdFBvcztcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWxTdGVwcztcclxuICAgICAgICAgICAgICAgIHZhciBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBpc1N0ZXBzID0gbW9kZSA9PT0gXCJzdGVwc1wiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgJ3N0ZXBzJyBtb2RlLCB1c2UgdGhlIHByb3ZpZGVkIHN0ZXBzLlxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBzdGVwIG9uIHRvIHRoZSBuZXh0IHN1YnJhbmdlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RlcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwID0gc2NvcGVfU3BlY3RydW0ueE51bVN0ZXBzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGEgJ2Z1bGwnIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwID0gaGlnaCAtIGxvdztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb3cgY2FuIGJlIDAsIHNvIHRlc3QgZm9yIGZhbHNlLiBJZiBoaWdoIGlzIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBhdCB0aGUgbGFzdCBzdWJyYW5nZS4gSW5kZXggMCBpcyBhbHJlYWR5IGhhbmRsZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAobG93ID09PSBmYWxzZSB8fCBoaWdoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN0ZXAgaXNuJ3QgMCwgd2hpY2ggd291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCAoIzY1NClcclxuICAgICAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heChzdGVwLCAwLjAwMDAwMDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgYWxsIHN0ZXBzIGluIHRoZSBzdWJyYW5nZS5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBoaWdoOyBpID0gc2FmZUluY3JlbWVudChpLCBzdGVwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNpemUgZm9yIHRoZSBzdWJyYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICBuZXdQY3QgPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdGVwcyA9IHBjdERpZmZlcmVuY2UgLyBkZW5zaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWxTdGVwcyA9IE1hdGgucm91bmQoc3RlcHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJhdGlvIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBwZXJjZW50YWdlLXNwYWNlIGEgcG9pbnQgaW5kaWNhdGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIGRlbnNpdHkgMSB0aGUgcG9pbnRzL3BlcmNlbnRhZ2UgPSAxLiBGb3IgZGVuc2l0eSAyLCB0aGF0IHBlcmNlbnRhZ2UgbmVlZHMgdG8gYmUgcmUtZGl2aWRlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHNwcmVhZCB0aGUgb2Zmc2V0IG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gcGN0RGlmZmVyZW5jZSAvIHJlYWxTdGVwcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGl2aWRlIGFsbCBwb2ludHMgZXZlbmx5LCBhZGRpbmcgdGhlIGNvcnJlY3QgbnVtYmVyIHRvIHRoaXMgc3VicmFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHVwIHRvIDw9IHNvIHRoYXQgMTAwJSBnZXRzIGEgcG9pbnQsIGV2ZW50IGlmIGlnbm9yZUxhc3QgaXMgc2V0LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocSA9IDE7IHEgPD0gcmVhbFN0ZXBzOyBxICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhdGlvIGJldHdlZW4gdGhlIHJvdW5kZWQgdmFsdWUgYW5kIHRoZSBhY3R1YWwgc2l6ZSBtaWdodCBiZSB+MSUgb2ZmLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXIgc3VicmFuZ2UuIGRlbnNpdHkgPSAxIHdpbGwgcmVzdWx0IGluIDEwMCBwb2ludHMgb24gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bGwgcmFuZ2UsIDIgZm9yIDUwLCA0IGZvciAyNSwgZXRjLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwY3RQb3MgPSBwcmV2UGN0ICsgcSAqIHN0ZXBTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzW3BjdFBvcy50b0ZpeGVkKDUpXSA9IFtzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcocGN0UG9zKSwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGdyb3VwLmluZGV4T2YoaSkgPiAtMSA/IFBJUFNfTEFSR0VfVkFMVUUgOiBpc1N0ZXBzID8gUElQU19TTUFMTF9WQUxVRSA6IFBJUFNfTk9fVkFMVUU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZm9yY2UgdGhlICdpZ25vcmVGaXJzdCcgb3B0aW9uIGJ5IG92ZXJ3cml0aW5nIHRoZSB0eXBlIGZvciAwLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5kZXggJiYgaWdub3JlRmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpID09PSBoaWdoICYmIGlnbm9yZUxhc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlICd0eXBlJyBvZiB0aGlzIHBvaW50LiAwID0gcGxhaW4sIDEgPSByZWFsIHZhbHVlLCAyID0gc3RlcCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1tuZXdQY3QudG9GaXhlZCg1KV0gPSBbaSwgdHlwZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlcmNlbnRhZ2UgY291bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlBjdCA9IG5ld1BjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlU2l6ZUNsYXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFsdWVTaXplQ2xhc3Nlc1tQSVBTX05PX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZU5vcm1hbDtcclxuICAgICAgICAgICAgdmFsdWVTaXplQ2xhc3Nlc1tQSVBTX0xBUkdFX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlO1xyXG4gICAgICAgICAgICB2YWx1ZVNpemVDbGFzc2VzW1BJUFNfU01BTExfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlU3ViO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1hcmtlclNpemVDbGFzc2VzID0gW107XHJcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfTk9fVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlck5vcm1hbDtcclxuICAgICAgICAgICAgbWFya2VyU2l6ZUNsYXNzZXNbUElQU19MQVJHRV9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyTGFyZ2U7XHJcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfU01BTExfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclN1YjtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyA9IFtvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVIb3Jpem9udGFsLCBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVWZXJ0aWNhbF07XHJcbiAgICAgICAgICAgIHZhciBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckhvcml6b250YWwsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJWZXJ0aWNhbF07XHJcblxyXG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBvcHRpb25zLmNzc0NsYXNzZXMucGlwcyk7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMub3J0ID09PSAwID8gb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNIb3Jpem9udGFsIDogb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNWZXJ0aWNhbCk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDbGFzc2VzKHR5cGUsIHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBzb3VyY2UgPT09IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZUNsYXNzZXMgPSBhID8gdmFsdWVTaXplQ2xhc3NlcyA6IG1hcmtlclNpemVDbGFzc2VzO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UgKyBcIiBcIiArIG9yaWVudGF0aW9uQ2xhc3Nlc1tvcHRpb25zLm9ydF0gKyBcIiBcIiArIHNpemVDbGFzc2VzW3R5cGVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRTcHJlYWQob2Zmc2V0LCB2YWx1ZSwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGZpbHRlciBmdW5jdGlvbiwgaWYgaXQgaXMgc2V0LlxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IGZpbHRlckZ1bmMgPyBmaWx0ZXJGdW5jKHZhbHVlLCB0eXBlKSA6IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBJUFNfTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBtYXJrZXIgZm9yIGV2ZXJ5IHBvaW50XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFkZE5vZGVUbyhlbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlW29wdGlvbnMuc3R5bGVdID0gb2Zmc2V0ICsgXCIlXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVmFsdWVzIGFyZSBvbmx5IGFwcGVuZGVkIGZvciBwb2ludHMgbWFya2VkICcxJyBvciAnMicuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA+IFBJUFNfTk9fVkFMVUUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IGZvcm1hdHRlci50byh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBhbGwgcG9pbnRzLlxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzcHJlYWQpLmZvckVhY2goZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBhZGRTcHJlYWQob2Zmc2V0LCBzcHJlYWRbb2Zmc2V0XVswXSwgc3ByZWFkW29mZnNldF1bMV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUGlwcygpIHtcclxuICAgICAgICAgICAgaWYgKHNjb3BlX1BpcHMpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQoc2NvcGVfUGlwcyk7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9QaXBzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGlwcyhncmlkKSB7XHJcbiAgICAgICAgICAgIC8vIEZpeCAjNjY5XHJcbiAgICAgICAgICAgIHJlbW92ZVBpcHMoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtb2RlID0gZ3JpZC5tb2RlO1xyXG4gICAgICAgICAgICB2YXIgZGVuc2l0eSA9IGdyaWQuZGVuc2l0eSB8fCAxO1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gZ3JpZC5maWx0ZXIgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBncmlkLnZhbHVlcyB8fCBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHN0ZXBwZWQgPSBncmlkLnN0ZXBwZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdldEdyb3VwKG1vZGUsIHZhbHVlcywgc3RlcHBlZCk7XHJcbiAgICAgICAgICAgIHZhciBzcHJlYWQgPSBnZW5lcmF0ZVNwcmVhZChkZW5zaXR5LCBtb2RlLCBncm91cCk7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBncmlkLmZvcm1hdCB8fCB7XHJcbiAgICAgICAgICAgICAgICB0bzogTWF0aC5yb3VuZFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfUGlwcyA9IHNjb3BlX1RhcmdldC5hcHBlbmRDaGlsZChhZGRNYXJraW5nKHNwcmVhZCwgZmlsdGVyLCBmb3JtYXQpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9QaXBzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvcnRoYW5kIGZvciBiYXNlIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgZnVuY3Rpb24gYmFzZVNpemUoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2NvcGVfQmFzZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgdmFyIGFsdCA9IFwib2Zmc2V0XCIgKyBbXCJXaWR0aFwiLCBcIkhlaWdodFwiXVtvcHRpb25zLm9ydF07XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm9ydCA9PT0gMCA/IHJlY3Qud2lkdGggfHwgc2NvcGVfQmFzZVthbHRdIDogcmVjdC5oZWlnaHQgfHwgc2NvcGVfQmFzZVthbHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlciBmb3IgYXR0YWNoaW5nIGV2ZW50cyB0cm91Z2ggYSBwcm94eS5cclxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudChldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gJ2ZpbHRlcicgZXZlbnRzIHRvIHRoZSBzbGlkZXIuXHJcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYSBub2RlLCBub3QgYSBub2RlTGlzdFxyXG5cclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBmaXhFdmVudChlLCBkYXRhLnBhZ2VPZmZzZXQsIGRhdGEudGFyZ2V0IHx8IGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGZpeEV2ZW50IHJldHVybnMgZmFsc2UgaWYgdGhpcyBldmVudCBoYXMgYSBkaWZmZXJlbnQgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGhhbmRsaW5nIChtdWx0aS0pIHRvdWNoIGV2ZW50cztcclxuICAgICAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkb05vdFJlamVjdCBpcyBwYXNzZWQgYnkgYWxsIGVuZCBldmVudHMgdG8gbWFrZSBzdXJlIHJlbGVhc2VkIHRvdWNoZXNcclxuICAgICAgICAgICAgICAgIC8vIGFyZSBub3QgcmVqZWN0ZWQsIGxlYXZpbmcgdGhlIHNsaWRlciBcInN0dWNrXCIgdG8gdGhlIGN1cnNvcjtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBhbiBhY3RpdmUgJ3RhcCcgdHJhbnNpdGlvbiBpcyB0YWtpbmcgcGxhY2UuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwKSAmJiAhZGF0YS5kb05vdFJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHJpZ2h0IG9yIG1pZGRsZSBjbGlja3Mgb24gc3RhcnQgIzQ1NFxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vICdzdXBwb3J0c1Bhc3NpdmUnIGlzIG9ubHkgdHJ1ZSBpZiBhIGJyb3dzZXIgYWxzbyBzdXBwb3J0cyB0b3VjaC1hY3Rpb246IG5vbmUgaW4gQ1NTLlxyXG4gICAgICAgICAgICAgICAgLy8gaU9TIHNhZmFyaSBkb2VzIG5vdCwgc28gaXQgZG9lc24ndCBnZXQgdG8gYmVuZWZpdCBmcm9tIHBhc3NpdmUgc2Nyb2xsaW5nLiBpT1MgZG9lcyBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICAvLyB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbiwgYnV0IHRoYXQgYWxsb3dzIHBhbm5pbmcsIHdoaWNoIGJyZWFrc1xyXG4gICAgICAgICAgICAgICAgLy8gc2xpZGVycyBhZnRlciB6b29taW5nL29uIG5vbi1yZXNwb25zaXZlIHBhZ2VzLlxyXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMzMTEyXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlLmNhbGNQb2ludCA9IGUucG9pbnRzW29wdGlvbnMub3J0XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cclxuICAgICAgICAgICAgZXZlbnRzLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbWV0aG9kLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZXZlbnROYW1lLCBtZXRob2RdKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxyXG4gICAgICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGUsIHBhZ2VPZmZzZXQsIGV2ZW50VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIC8vIEZpbHRlciB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgdGhlIHR5cGUsIHdoaWNoIGNhbiBiZVxyXG4gICAgICAgICAgICAvLyB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlci4gT2Zmc2V0IGNoYW5nZXMgbmVlZCB0byBiZVxyXG4gICAgICAgICAgICAvLyBtYWRlIG9uIGFuIGV2ZW50IHNwZWNpZmljIGJhc2lzLlxyXG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBlLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID09PSAwO1xyXG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpID09PSAwO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IGUudHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA9PT0gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciB4O1xyXG4gICAgICAgICAgICB2YXIgeTtcclxuXHJcbiAgICAgICAgICAgIC8vIElFMTAgaW1wbGVtZW50ZWQgcG9pbnRlciBldmVudHMgd2l0aCBhIHByZWZpeDtcclxuICAgICAgICAgICAgaWYgKGUudHlwZS5pbmRleE9mKFwiTVNQb2ludGVyXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG9ubHkgdGhpbmcgb25lIGhhbmRsZSBzaG91bGQgYmUgY29uY2VybmVkIGFib3V0IGlzIHRoZSB0b3VjaGVzIHRoYXQgb3JpZ2luYXRlZCBvbiB0b3Agb2YgaXQuXHJcbiAgICAgICAgICAgIGlmICh0b3VjaCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGEgdG91Y2ggb3JpZ2luYXRlZCBvbiB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgdmFyIGlzVG91Y2hPblRhcmdldCA9IGZ1bmN0aW9uKGNoZWNrVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tUb3VjaC50YXJnZXQgPT09IGV2ZW50VGFyZ2V0IHx8IGV2ZW50VGFyZ2V0LmNvbnRhaW5zKGNoZWNrVG91Y2gudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdG91Y2hzdGFydCBldmVudHMsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIHN0aWxsIG5vIG1vcmUgdGhhbiBvbmVcclxuICAgICAgICAgICAgICAgIC8vIHRvdWNoIG9uIHRoZSB0YXJnZXQgc28gd2UgbG9vayBhbW9uZ3N0IGFsbCB0b3VjaGVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2hlcyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlLnRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiBvbmUgdG91Y2ggcGVyIGhhbmRsZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoZS5jaGFuZ2VkVG91Y2hlcywgaXNUb3VjaE9uVGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGlmIHRoZSB0YXJnZXQgdG91Y2ggaGFzIG5vdCBtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFRvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaC5wYWdlWDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0VG91Y2gucGFnZVk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0IHx8IGdldFBhZ2VPZmZzZXQoc2NvcGVfRG9jdW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1vdXNlIHx8IHBvaW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIHggPSBlLmNsaWVudFggKyBwYWdlT2Zmc2V0Lng7XHJcbiAgICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlLnBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0O1xyXG4gICAgICAgICAgICBlLnBvaW50cyA9IFt4LCB5XTtcclxuICAgICAgICAgICAgZS5jdXJzb3IgPSBtb3VzZSB8fCBwb2ludGVyOyAvLyBGaXggIzQzNVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUcmFuc2xhdGUgYSBjb29yZGluYXRlIGluIHRoZSBkb2N1bWVudCB0byBhIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxyXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNQb2ludFRvUGVyY2VudGFnZShjYWxjUG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY2FsY1BvaW50IC0gb2Zmc2V0KHNjb3BlX0Jhc2UsIG9wdGlvbnMub3J0KTtcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKGxvY2F0aW9uICogMTAwKSAvIGJhc2VTaXplKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGFtcCBwcm9wb3NhbCBiZXR3ZWVuIDAlIGFuZCAxMDAlXHJcbiAgICAgICAgICAgIC8vIE91dC1vZi1ib3VuZCBjb29yZGluYXRlcyBtYXkgb2NjdXIgd2hlbiAubm9VaS1iYXNlIHBzZXVkby1lbGVtZW50c1xyXG4gICAgICAgICAgICAvLyBhcmUgdXNlZCAoZS5nLiBjb250YWluZWQgaGFuZGxlcyBmZWF0dXJlKVxyXG4gICAgICAgICAgICBwcm9wb3NhbCA9IGxpbWl0KHByb3Bvc2FsKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRpciA/IDEwMCAtIHByb3Bvc2FsIDogcHJvcG9zYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaW5kIGhhbmRsZSBjbG9zZXN0IHRvIGEgY2VydGFpbiBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcclxuICAgICAgICBmdW5jdGlvbiBnZXRDbG9zZXN0SGFuZGxlKHByb3Bvc2FsKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0ID0gMTAwO1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZWQgaGFuZGxlcyBhcmUgaWdub3JlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSGFuZGxlRGlzYWJsZWQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBNYXRoLmFicyhzY29wZV9Mb2NhdGlvbnNbaW5kZXhdIC0gcHJvcG9zYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBjbG9zZXN0IHx8IChwb3MgPT09IDEwMCAmJiBjbG9zZXN0ID09PSAxMDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdCA9IHBvcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTnVtYmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyZSAnZW5kJyB3aGVuIGEgbW91c2Ugb3IgcGVuIGxlYXZlcyB0aGUgZG9jdW1lbnQuXHJcbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRMZWF2ZShldmVudCwgZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJtb3VzZW91dFwiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJIVE1MXCIgJiYgZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgbW92ZW1lbnQgb24gZG9jdW1lbnQgZm9yIGhhbmRsZSBhbmQgcmFuZ2UgZHJhZy5cclxuICAgICAgICBmdW5jdGlvbiBldmVudE1vdmUoZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gRml4ICM0OThcclxuICAgICAgICAgICAgLy8gQ2hlY2sgdmFsdWUgb2YgLmJ1dHRvbnMgaW4gJ3N0YXJ0JyB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpbiBJRTEwIG1vYmlsZSAoZGF0YS5idXR0b25zUHJvcGVydHkpLlxyXG4gICAgICAgICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzkyNzAwNS9tb2JpbGUtaWUxMC13aW5kb3dzLXBob25lLWJ1dHRvbnMtcHJvcGVydHktb2YtcG9pbnRlcm1vdmUtZXZlbnQtYWx3YXlzLXplcm9cclxuICAgICAgICAgICAgLy8gSUU5IGhhcyAuYnV0dG9ucyBhbmQgLndoaWNoIHplcm8gb24gbW91c2Vtb3ZlLlxyXG4gICAgICAgICAgICAvLyBGaXJlZm94IGJyZWFrcyB0aGUgc3BlYyBNRE4gZGVmaW5lcy5cclxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXCJNU0lFIDlcIikgPT09IC0xICYmIGV2ZW50LmJ1dHRvbnMgPT09IDAgJiYgZGF0YS5idXR0b25zUHJvcGVydHkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVuZChldmVudCwgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBtb3ZpbmcgdXAgb3IgZG93blxyXG4gICAgICAgICAgICB2YXIgbW92ZW1lbnQgPSAob3B0aW9ucy5kaXIgPyAtMSA6IDEpICogKGV2ZW50LmNhbGNQb2ludCAtIGRhdGEuc3RhcnRDYWxjUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbW92ZW1lbnQgaW50byBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciB3aWR0aC9oZWlnaHRcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKG1vdmVtZW50ICogMTAwKSAvIGRhdGEuYmFzZVNpemU7XHJcblxyXG4gICAgICAgICAgICBtb3ZlSGFuZGxlcyhtb3ZlbWVudCA+IDAsIHByb3Bvc2FsLCBkYXRhLmxvY2F0aW9ucywgZGF0YS5oYW5kbGVOdW1iZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVuYmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudCwgY2FsbCBjYWxsYmFja3MuXHJcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRFbmQoZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGhhbmRsZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyByZW1vdmUgdGhlIGNsYXNzLlxyXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGRhdGEuaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuYWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCAtPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxyXG4gICAgICAgICAgICBkYXRhLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0RvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNbMF0sIGNbMV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBkcmFnZ2luZyBjbGFzcy5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xyXG4gICAgICAgICAgICAgICAgc2V0WmluZGV4KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnNvciBzdHlsZXMgYW5kIHRleHQtc2VsZWN0aW9uIGV2ZW50cyBib3VuZCB0byB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5jdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgcHJldmVudERlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJlbmRcIiwgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxyXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50U3RhcnQoZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50IGlmIGFueSBoYW5kbGUgaXMgZGlzYWJsZWRcclxuICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlTnVtYmVycy5zb21lKGlzSGFuZGxlRGlzYWJsZWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBoYW5kbGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGVPcmlnaW4uY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgICAgICBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSBoYW5kbGUgYXMgJ2FjdGl2ZScgc28gaXQgY2FuIGJlIHN0eWxlZC5cclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBtb3ZlIGFuZCBlbmQgZXZlbnRzLlxyXG4gICAgICAgICAgICB2YXIgbW92ZUV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50TW92ZSwge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHRhcmdldCBoYXMgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgd2Uga2VlcFxyXG4gICAgICAgICAgICAgICAgLy8gcmVseWluZyBvbiBpdCB0byBleHRyYWN0IHRhcmdldCB0b3VjaGVzLlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDYWxjUG9pbnQ6IGV2ZW50LmNhbGNQb2ludCxcclxuICAgICAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSgpLFxyXG4gICAgICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcclxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVycyxcclxuICAgICAgICAgICAgICAgIGJ1dHRvbnNQcm9wZXJ0eTogZXZlbnQuYnV0dG9ucyxcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxyXG4gICAgICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgb3V0RXZlbnQgPSBhdHRhY2hFdmVudChcIm1vdXNlb3V0XCIsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZG9jdW1lbnRMZWF2ZSwge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxyXG4gICAgICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBwdXNoZWQgdGhlIGxpc3RlbmVycyBpbiB0aGUgbGlzdGVuZXIgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGluZ1xyXG4gICAgICAgICAgICAvLyBhIG5ldyBvbmUgYXMgaXQgaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJzLlxyXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIG1vdmVFdmVudC5jb25jYXQoZW5kRXZlbnQsIG91dEV2ZW50KSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBpc24ndCBhbiBpc3N1ZSBvbiB0b3VjaCBkZXZpY2VzLFxyXG4gICAgICAgICAgICAvLyBzbyBhZGRpbmcgY3Vyc29yIHN0eWxlcyBjYW4gYmUgc2tpcHBlZC5cclxuICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cclxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSB0YXJnZXQgd2l0aCBhIGRyYWdnaW5nIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdGV4dCBzZWxlY3Rpb24gd2hlbiBkcmFnZ2luZyB0aGUgaGFuZGxlcy5cclxuICAgICAgICAgICAgICAgIC8vIEluIG5vVWlTbGlkZXIgPD0gOS4yLjAsIHRoaXMgd2FzIGhhbmRsZWQgYnkgY2FsbGluZyBwcmV2ZW50RGVmYXVsdCBvbiBtb3VzZS90b3VjaCBzdGFydC9tb3ZlLFxyXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgc2Nyb2xsIGJsb2NraW5nLiBUaGUgc2VsZWN0c3RhcnQgZXZlbnQgaXMgc3VwcG9ydGVkIGJ5IEZpcmVGb3ggc3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDUyLFxyXG4gICAgICAgICAgICAgICAgLy8gbWVhbmluZyB0aGUgb25seSBob2xkb3V0IGlzIGlPUyBTYWZhcmkuIFRoaXMgZG9lc24ndCBtYXR0ZXI6IHRleHQgc2VsZWN0aW9uIGlzbid0IHRyaWdnZXJlZCB0aGVyZS5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSAnY3Vyc29yJyBmbGFnIGlzIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zZWxlY3RzdGFydFxyXG4gICAgICAgICAgICAgICAgc2NvcGVfQm9keS5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGF0YS5oYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzdGFydFwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxyXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50VGFwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSB0YXAgZXZlbnQgc2hvdWxkbid0IHByb3BhZ2F0ZSB1cFxyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZ2V0Q2xvc2VzdEhhbmRsZShwcm9wb3NhbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBUYWNrbGUgdGhlIGNhc2UgdGhhdCBhbGwgaGFuZGxlcyBhcmUgJ2Rpc2FibGVkJy5cclxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmxhZyB0aGUgc2xpZGVyIGFzIGl0IGlzIG5vdyBpbiBhIHRyYW5zaXRpb25hbCBzdGF0ZS5cclxuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0YWtlcyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgbXMgKGRlZmF1bHQgMzAwKS4gUmUtZW5hYmxlIHRoZSBzbGlkZXIgYWZ0ZXIgdGhhdC5cclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBwcm9wb3NhbCwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBzZXRaaW5kZXgoKTtcclxuXHJcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xyXG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudHMuc25hcCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRTdGFydChldmVudCwgeyBoYW5kbGVOdW1iZXJzOiBbaGFuZGxlTnVtYmVyXSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyZXMgYSAnaG92ZXInIGV2ZW50IGZvciBhIGhvdmVyZWQgbW91c2UvcGVuIHBvc2l0aW9uLlxyXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50SG92ZXIoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdG8gPSBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHByb3Bvc2FsKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHRvKTtcclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGVfU2VsZiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZXMga2V5ZG93biBvbiBmb2N1c2VkIGhhbmRsZXNcclxuICAgICAgICAvLyBEb24ndCBtb3ZlIHRoZSBkb2N1bWVudCB3aGVuIHByZXNzaW5nIGFycm93IGtleXMgb24gZm9jdXNlZCBoYW5kbGVzXHJcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRLZXlkb3duKGV2ZW50LCBoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKGlzU2xpZGVyRGlzYWJsZWQoKSB8fCBpc0hhbmRsZURpc2FibGVkKGhhbmRsZU51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xyXG4gICAgICAgICAgICB2YXIgdmVydGljYWxLZXlzID0gW1wiRG93blwiLCBcIlVwXCJdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyICYmICFvcHRpb25zLm9ydCkge1xyXG4gICAgICAgICAgICAgICAgLy8gT24gYW4gcmlnaHQtdG8tbGVmdCBzbGlkZXIsIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzIGFjdCBpbnZlcnRlZFxyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEtleXMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3J0ICYmICFvcHRpb25zLmRpcikge1xyXG4gICAgICAgICAgICAgICAgLy8gT24gYSB0b3AtdG8tYm90dG9tIHNsaWRlciwgdGhlIHVwIGFuZCBkb3duIGtleXMgYWN0IGludmVydGVkXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEtleXMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdHJpcCBcIkFycm93XCIgZm9yIElFIGNvbXBhdGliaWxpdHkuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxyXG4gICAgICAgICAgICB2YXIga2V5ID0gZXZlbnQua2V5LnJlcGxhY2UoXCJBcnJvd1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgdmFyIGlzRG93biA9IGtleSA9PT0gdmVydGljYWxLZXlzWzBdIHx8IGtleSA9PT0gaG9yaXpvbnRhbEtleXNbMF07XHJcbiAgICAgICAgICAgIHZhciBpc1VwID0ga2V5ID09PSB2ZXJ0aWNhbEtleXNbMV0gfHwga2V5ID09PSBob3Jpem9udGFsS2V5c1sxXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNEb3duICYmICFpc1VwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0Rvd24gPyAwIDogMTtcclxuICAgICAgICAgICAgdmFyIHN0ZXBzID0gZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgIHZhciBzdGVwID0gc3RlcHNbZGlyZWN0aW9uXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEF0IHRoZSBlZGdlIG9mIGEgc2xpZGVyLCBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vIHN0ZXAgc2V0LCB1c2UgdGhlIGRlZmF1bHQgb2YgMTAlIG9mIHRoZSBzdWItcmFuZ2VcclxuICAgICAgICAgICAgaWYgKHN0ZXAgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwID0gc2NvcGVfU3BlY3RydW0uZ2V0RGVmYXVsdFN0ZXAoc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0sIGlzRG93biwgMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcclxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZW1lbnQgZm9yIGRvd24gc3RlcHNcclxuICAgICAgICAgICAgc3RlcCA9IChpc0Rvd24gPyAtMSA6IDEpICogc3RlcDtcclxuXHJcbiAgICAgICAgICAgIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gKyBzdGVwLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCBldmVudHMgdG8gc2V2ZXJhbCBzbGlkZXIgcGFydHMuXHJcbiAgICAgICAgZnVuY3Rpb24gYmluZFNsaWRlckV2ZW50cyhiZWhhdmlvdXIpIHtcclxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBzdGFuZGFyZCBkcmFnIGV2ZW50IHRvIHRoZSBoYW5kbGVzLlxyXG4gICAgICAgICAgICBpZiAoIWJlaGF2aW91ci5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgYXJlIG9ubHkgYm91bmQgdG8gdGhlIHZpc3VhbCBoYW5kbGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50LCBub3QgdGhlICdyZWFsJyBvcmlnaW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBoYW5kbGUuY2hpbGRyZW5bMF0sIGV2ZW50U3RhcnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogW2luZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgdGFwIGV2ZW50IHRvIHRoZSBzbGlkZXIgYmFzZS5cclxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci50YXApIHtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMuc3RhcnQsIHNjb3BlX0Jhc2UsIGV2ZW50VGFwLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmUgaG92ZXIgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuaG92ZXIpIHtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMubW92ZSwgc2NvcGVfQmFzZSwgZXZlbnRIb3Zlciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdmVyOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcmFuZ2UgZHJhZ2dhYmxlLlxyXG4gICAgICAgICAgICBpZiAoYmVoYXZpb3VyLmRyYWcpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdCA9PT0gZmFsc2UgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUJlZm9yZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQWZ0ZXIgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRIb2xkZXJzID0gW2Nvbm5lY3RdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhjb25uZWN0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcmFuZ2UgaXMgZml4ZWQsIHRoZSBlbnRpcmUgcmFuZ2UgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgZHJhZ2dlZCBieSB0aGUgaGFuZGxlcy4gVGhlIGhhbmRsZSBpbiB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW4gd2lsbCBwcm9wYWdhdGUgdGhlIHN0YXJ0IGV2ZW50IHVwd2FyZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaXQgbmVlZHMgdG8gYmUgYm91bmQgbWFudWFsbHkgb24gdGhlIG90aGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQmVmb3JlLmNoaWxkcmVuWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQWZ0ZXIuY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLmZvckVhY2goZnVuY3Rpb24oZXZlbnRIb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgZXZlbnRIb2xkZXIsIGV2ZW50U3RhcnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXM6IFtoYW5kbGVCZWZvcmUsIGhhbmRsZUFmdGVyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IFtpbmRleCAtIDEsIGluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdHRhY2ggYW4gZXZlbnQgdG8gdGhpcyBzbGlkZXIsIHBvc3NpYmx5IGluY2x1ZGluZyBhIG5hbWVzcGFjZVxyXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudChuYW1lc3BhY2VkRXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdID0gc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0gfHwgW107XHJcbiAgICAgICAgICAgIHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdLnB1c2goY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGJvdW5kIGlzICd1cGRhdGUsJyBmaXJlIGl0IGltbWVkaWF0ZWx5IGZvciBhbGwgaGFuZGxlcy5cclxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF0gPT09IFwidXBkYXRlXCIpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVW5kbyBhdHRhY2htZW50IG9mIGV2ZW50XHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQobmFtZXNwYWNlZEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5hbWVzcGFjZWRFdmVudCAmJiBuYW1lc3BhY2VkRXZlbnQuc3BsaXQoXCIuXCIpWzBdO1xyXG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZXZlbnQgJiYgbmFtZXNwYWNlZEV2ZW50LnN1YnN0cmluZyhldmVudC5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGJpbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KFwiLlwiKVswXTtcclxuICAgICAgICAgICAgICAgIHZhciB0TmFtZXNwYWNlID0gYmluZC5zdWJzdHJpbmcodEV2ZW50Lmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCghZXZlbnQgfHwgZXZlbnQgPT09IHRFdmVudCkgJiYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSB0TmFtZXNwYWNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXh0ZXJuYWwgZXZlbnQgaGFuZGxpbmdcclxuICAgICAgICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnROYW1lLCBoYW5kbGVOdW1iZXIsIHRhcCkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0RXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNsaWRlciBwdWJsaWMgQVBJIGFzIHRoZSBzY29wZSAoJ3RoaXMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfU2VsZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB2YWx1ZXMgYXMgYXJyYXksIHNvIGFyZ18xW2FyZ18yXSBpcyBhbHdheXMgdmFsaWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpbmRleCwgMCBvciAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1mb3JtYXR0ZWQgc2xpZGVyIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVudCBpcyBmaXJlZCBieSB0YXAsIHRydWUgb3IgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgb2Zmc2V0IG9mIHRoZSBoYW5kbGUsIGluIHJlbGF0aW9uIHRvIHRoZSBzbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBoYW5kbGUgcG9zaXRpb25pbmcgbG9naWMgc28gdGhlIE1vdmUgZXZlbnQgY2FuIHVzZSBpdCwgdG9vXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tIYW5kbGVQb3NpdGlvbihyZWZlcmVuY2UsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGdldFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBzbGlkZXJzIHdpdGggbXVsdGlwbGUgaGFuZGxlcywgbGltaXQgbW92ZW1lbnQgdG8gdGhlIG90aGVyIGhhbmRsZS5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIG1hcmdpbiBvcHRpb24gYnkgYWRkaW5nIGl0IHRvIHRoZSBoYW5kbGUgcG9zaXRpb25zLlxyXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0gKyBvcHRpb25zLm1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxvb2tGb3J3YXJkICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSAtIG9wdGlvbnMubWFyZ2luKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGxpbWl0IG9wdGlvbiBoYXMgdGhlIG9wcG9zaXRlIGVmZmVjdCwgbGltaXRpbmcgaGFuZGxlcyB0byBhXHJcbiAgICAgICAgICAgIC8vIG1heGltdW0gZGlzdGFuY2UgZnJvbSBhbm90aGVyLiBMaW1pdCBtdXN0IGJlID4gMCwgYXMgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZXMgd291bGQgYmUgdW5tb3ZhYmxlLlxyXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSArIG9wdGlvbnMubGltaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0gLSBvcHRpb25zLmxpbWl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHBhZGRpbmcgb3B0aW9uIGtlZXBzIHRoZSBoYW5kbGVzIGEgY2VydGFpbiBkaXN0YW5jZSBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvLyBlZGdlcyBvZiB0aGUgc2xpZGVyLiBQYWRkaW5nIG11c3QgYmUgPiAwLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgb3B0aW9ucy5wYWRkaW5nWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCAxMDAgLSBvcHRpb25zLnBhZGRpbmdbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodG8pO1xyXG5cclxuICAgICAgICAgICAgLy8gTGltaXQgcGVyY2VudGFnZSB0byB0aGUgMCAtIDEwMCByYW5nZVxyXG4gICAgICAgICAgICB0byA9IGxpbWl0KHRvKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiBoYW5kbGUgY2FuJ3QgbW92ZVxyXG4gICAgICAgICAgICBpZiAodG8gPT09IHJlZmVyZW5jZVtoYW5kbGVOdW1iZXJdICYmICFnZXRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2VzIHNsaWRlciBvcmllbnRhdGlvbiB0byBjcmVhdGUgQ1NTIHJ1bGVzLiBhID0gYmFzZSB2YWx1ZTtcclxuICAgICAgICBmdW5jdGlvbiBpblJ1bGVPcmRlcih2LCBhKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XHJcbiAgICAgICAgICAgIHJldHVybiAobyA/IGEgOiB2KSArIFwiLCBcIiArIChvID8gdiA6IGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTW92ZXMgaGFuZGxlKHMpIGJ5IGEgcGVyY2VudGFnZVxyXG4gICAgICAgIC8vIChib29sLCAlIHRvIG1vdmUsIFslIHdoZXJlIGhhbmRsZSBzdGFydGVkLCAuLi5dLCBbaW5kZXggaW4gc2NvcGVfSGFuZGxlcywgLi4uXSlcclxuICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcyh1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FscyA9IGxvY2F0aW9ucy5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGIgPSBbIXVwd2FyZCwgdXB3YXJkXTtcclxuICAgICAgICAgICAgdmFyIGYgPSBbdXB3YXJkLCAhdXB3YXJkXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcclxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycyA9IGhhbmRsZU51bWJlcnMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSB3aGljaCBoYW5kbGUgaXMgJ2xlYWRpbmcnLlxyXG4gICAgICAgICAgICAvLyBJZiB0aGF0IG9uZSBjYW4ndCBtb3ZlIHRoZSBzZWNvbmQgY2FuJ3QgZWl0aGVyLlxyXG4gICAgICAgICAgICBpZiAodXB3YXJkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxyXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyLCBvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdICsgcHJvcG9zYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJbb10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZbb10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBvbmUgb2YgdGhlIGhhbmRsZXMgY2FuJ3QgbW92ZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbCA9IHRvIC0gcHJvcG9zYWxzW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdID0gdG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHVzaW5nIG9uZSBoYW5kbGUsIGNoZWNrIGJhY2t3YXJkIEFORCBmb3J3YXJkXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYiA9IGYgPSBbdHJ1ZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAyOiBUcnkgdG8gc2V0IHRoZSBoYW5kbGVzIHdpdGggdGhlIGZvdW5kIHBlcmNlbnRhZ2VcclxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlciwgbykge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBsb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dKSB8fCBzdGF0ZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIDM6IElmIGEgaGFuZGxlIG1vdmVkLCBmaXJlIGV2ZW50c1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzbGlkZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRha2VzIGEgYmFzZSB2YWx1ZSBhbmQgYW4gb2Zmc2V0LiBUaGlzIG9mZnNldCBpcyB1c2VkIGZvciB0aGUgY29ubmVjdCBiYXIgc2l6ZS5cclxuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBkZXNpZ24gZm9yIHRoaXMgZmVhdHVyZSwgdGhlIG9yaWdpbiBlbGVtZW50IHdhcyAxJSB3aWRlLlxyXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGEgcm91bmRpbmcgYnVnIGluIENocm9tZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGZlYXR1cmVcclxuICAgICAgICAvLyBpbiB0aGlzIG1hbm5lcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Nzk4MjIzXHJcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlyID8gMTAwIC0gYSAtIGIgOiBhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVIYW5kbGVQb3NpdGlvbihoYW5kbGVOdW1iZXIsIHRvKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsb2NhdGlvbnMuXHJcbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byB0aGUgc2xpZGVyIHN0ZXBwaW5nL3JhbmdlLlxyXG4gICAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodHJhbnNmb3JtRGlyZWN0aW9uKHRvLCAwKSAtIHNjb3BlX0Rpck9mZnNldCArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSBydWxlO1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdChoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0KGhhbmRsZU51bWJlciArIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlcyBiZWZvcmUgdGhlIHNsaWRlciBtaWRkbGUgYXJlIHN0YWNrZWQgbGF0ZXIgPSBoaWdoZXIsXHJcbiAgICAgICAgLy8gSGFuZGxlcyBhZnRlciB0aGUgbWlkZGxlIGxhdGVyIGlzIGxvd2VyXHJcbiAgICAgICAgLy8gW1s3XSBbOF0gLi4uLi4uLi4uLiB8IC4uLi4uLi4uLi4gWzVdIFs0XVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldFppbmRleCgpIHtcclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID4gNTAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgekluZGV4ID0gMyArIChzY29wZV9IYW5kbGVzLmxlbmd0aCArIGRpciAqIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGUuekluZGV4ID0gekluZGV4O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRlc3Qgc3VnZ2VzdGVkIHZhbHVlcyBhbmQgYXBwbHkgbWFyZ2luLCBzdGVwLlxyXG4gICAgICAgIGZ1bmN0aW9uIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkKSB7XHJcbiAgICAgICAgICAgIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZXMgc3R5bGUgYXR0cmlidXRlIGZvciBjb25uZWN0IG5vZGVzXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdChpbmRleCkge1xyXG4gICAgICAgICAgICAvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxyXG4gICAgICAgICAgICBpZiAoIXNjb3BlX0Nvbm5lY3RzW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBoID0gMTAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsID0gc2NvcGVfTG9jYXRpb25zW2luZGV4IC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gc2NvcGVfQ29ubmVjdHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgaCA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHVzZSB0d28gcnVsZXM6XHJcbiAgICAgICAgICAgIC8vICd0cmFuc2xhdGUnIHRvIGNoYW5nZSB0aGUgbGVmdC90b3Agb2Zmc2V0O1xyXG4gICAgICAgICAgICAvLyAnc2NhbGUnIHRvIGNoYW5nZSB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIC8vIEFzIHRoZSBlbGVtZW50IGhhcyBhIHdpZHRoIG9mIDEwMCUsIGEgdHJhbnNsYXRpb24gb2YgMTAwJSBpcyBlcXVhbCB0byAxMDAlIG9mIHRoZSBwYXJlbnQgKC5ub1VpLWJhc2UpXHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVJ1bGUgPSBcInRyYW5zbGF0ZShcIiArIGluUnVsZU9yZGVyKHRyYW5zZm9ybURpcmVjdGlvbihsLCBjb25uZWN0V2lkdGgpICsgXCIlXCIsIFwiMFwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSdWxlID0gXCJzY2FsZShcIiArIGluUnVsZU9yZGVyKGNvbm5lY3RXaWR0aCAvIDEwMCwgXCIxXCIpICsgXCIpXCI7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9Db25uZWN0c1tpbmRleF0uc3R5bGVbb3B0aW9ucy50cmFuc2Zvcm1SdWxlXSA9IHRyYW5zbGF0ZVJ1bGUgKyBcIiBcIiArIHNjYWxlUnVsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBhcnNlcyB2YWx1ZSBwYXNzZWQgdG8gLnNldCBtZXRob2QuIFJldHVybnMgY3VycmVudCB2YWx1ZSBpZiBub3QgcGFyc2UtYWJsZS5cclxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlVG9WYWx1ZSh0bywgaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIC8vIFNldHRpbmcgd2l0aCBudWxsIGluZGljYXRlcyBhbiAnaWdub3JlJy5cclxuICAgICAgICAgICAgLy8gSW5wdXR0aW5nICdmYWxzZScgaXMgaW52YWxpZC5cclxuICAgICAgICAgICAgaWYgKHRvID09PSBudWxsIHx8IHRvID09PSBmYWxzZSB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXB0IHRvIGRlY29kZSBpdC5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgdG8gPSBTdHJpbmcodG8pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0byA9IG9wdGlvbnMuZm9ybWF0LmZyb20odG8pO1xyXG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcGFyc2luZyB0aGUgbnVtYmVyIGZhaWxlZCwgdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxyXG4gICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzTmFOKHRvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHNsaWRlciB2YWx1ZS5cclxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldChpbnB1dCwgZmlyZVNldEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBhc0FycmF5KGlucHV0KTtcclxuICAgICAgICAgICAgdmFyIGlzSW5pdCA9IHNjb3BlX0xvY2F0aW9uc1swXSA9PT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgLy8gRXZlbnQgZmlyZXMgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBmaXJlU2V0RXZlbnQgPSBmaXJlU2V0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWZpcmVTZXRFdmVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBpcyBvcHRpb25hbC5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBpbml0aWFsIHZhbHVlcyB3ZXJlIHNldCBiZWZvcmUgdXNpbmcgYW5pbWF0ZWQgcGxhY2VtZW50LlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICYmICFpc0luaXQpIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpcnN0IHBhc3MsIHdpdGhvdXQgbG9va0FoZWFkIGJ1dCB3aXRoIGxvb2tCYWNrd2FyZC4gVmFsdWVzIGFyZSBzZXQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCByZXNvbHZlVG9WYWx1ZSh2YWx1ZXNbaGFuZGxlTnVtYmVyXSwgaGFuZGxlTnVtYmVyKSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlY29uZCBwYXNzLiBOb3cgdGhhdCBhbGwgYmFzZSB2YWx1ZXMgYXJlIHNldCwgYXBwbHkgY29uc3RyYWludHNcclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0sIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHNldFppbmRleCgpO1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgZXZlbnQgb25seSBmb3IgaGFuZGxlcyB0aGF0IHJlY2VpdmVkIGEgbmV3IHZhbHVlLCBhcyBwZXIgIzU3OVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1toYW5kbGVOdW1iZXJdICE9PSBudWxsICYmIGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHNsaWRlciB0byBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlUmVzZXQoZmlyZVNldEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhbHVlU2V0KG9wdGlvbnMuc3RhcnQsIGZpcmVTZXRFdmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdmFsdWUgZm9yIGEgc2luZ2xlIGhhbmRsZVxyXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdmFsdWUsIGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgbnVtZXJpYyBpbnB1dFxyXG4gICAgICAgICAgICBoYW5kbGVOdW1iZXIgPSBOdW1iZXIoaGFuZGxlTnVtYmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghKGhhbmRsZU51bWJlciA+PSAwICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBpbnZhbGlkIGhhbmRsZSBudW1iZXIsIGdvdDogXCIgKyBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMb29rIGJvdGggYmFja3dhcmQgYW5kIGZvcndhcmQsIHNpbmNlIHdlIGRvbid0IHdhbnQgdGhpcyBoYW5kbGUgdG8gXCJwdXNoXCIgb3RoZXIgaGFuZGxlcyAoIzk2MCk7XHJcbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgc2xpZGVyIHZhbHVlLlxyXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlR2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gc2NvcGVfVmFsdWVzLm1hcChvcHRpb25zLmZvcm1hdC50byk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxyXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZXMgY2xhc3NlcyBmcm9tIHRoZSByb290IGFuZCBlbXB0aWVzIGl0LlxyXG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNzc0NsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jc3NDbGFzc2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX1RhcmdldC5yZW1vdmVDaGlsZChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9UYXJnZXQubm9VaVNsaWRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRTdGVwc0ZvckhhbmRsZShoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgIHZhciBuZWFyYnlTdGVwcyA9IHNjb3BlX1NwZWN0cnVtLmdldE5lYXJieVN0ZXBzKGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGVwO1xyXG4gICAgICAgICAgICB2YXIgZGVjcmVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHNuYXBwZWQsIGRpcmVjdGx5IHVzZSBkZWZpbmVkIHN0ZXAgdmFsdWVcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc25hcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuc3RhcnRWYWx1ZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWUgfHwgbnVsbFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgdmFsdWUgaW4gdGhpcyBzdGVwIG1vdmVzIGludG8gdGhlIG5leHQgc3RlcCxcclxuICAgICAgICAgICAgLy8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgKyBpbmNyZW1lbnQgPiBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBiZXlvbmQgdGhlIHN0YXJ0aW5nIHBvaW50XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0YXJ0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5zdGVwID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgaGFuZGxlIGlzIGF0IHRoZSBzdGFydCBvZiBhIHN0ZXAsIGl0IGFsd2F5cyBzdGVwcyBiYWNrIGludG8gdGhlIHByZXZpb3VzIHN0ZXAgZmlyc3RcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuaGlnaGVzdFN0ZXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdywgaWYgYXQgdGhlIHNsaWRlciBlZGdlcywgdGhlcmUgaXMgbm8gaW4vZGVjcmVtZW50XHJcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcyBwZXIgIzM5MSwgdGhlIGNvbXBhcmlzb24gZm9yIHRoZSBkZWNyZW1lbnQgc3RlcCBjYW4gaGF2ZSBzb21lIHJvdW5kaW5nIGlzc3Vlcy5cclxuICAgICAgICAgICAgdmFyIHN0ZXBEZWNpbWFscyA9IHNjb3BlX1NwZWN0cnVtLmNvdW50U3RlcERlY2ltYWxzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZCBwZXIgIzM5MVxyXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ICE9PSBudWxsICYmIGluY3JlbWVudCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IE51bWJlcihpbmNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudCAhPT0gbnVsbCAmJiBkZWNyZW1lbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBOdW1iZXIoZGVjcmVtZW50LnRvRml4ZWQoc3RlcERlY2ltYWxzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbZGVjcmVtZW50LCBpbmNyZW1lbnRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgc2l6ZSBmb3IgdGhlIHNsaWRlci5cclxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9IYW5kbGVOdW1iZXJzLm1hcChnZXROZXh0U3RlcHNGb3JIYW5kbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlYWJsZTogbWFyZ2luLCBsaW1pdCwgcGFkZGluZywgc3RlcCwgcmFuZ2UsIGFuaW1hdGUsIHNuYXBcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9wdGlvbnNUb1VwZGF0ZSwgZmlyZVNldEV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFNwZWN0cnVtIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIHJhbmdlLCBzbmFwLCBkaXJlY3Rpb24gYW5kIHN0ZXAgb3B0aW9ucy5cclxuICAgICAgICAgICAgLy8gJ3NuYXAnIGFuZCAnc3RlcCcgY2FuIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgIC8vIElmICdzbmFwJyBhbmQgJ3N0ZXAnIGFyZSBub3QgcGFzc2VkLCB0aGV5IHNob3VsZCByZW1haW4gdW5jaGFuZ2VkLlxyXG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlR2V0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXBkYXRlQWJsZSA9IFtcclxuICAgICAgICAgICAgICAgIFwibWFyZ2luXCIsXHJcbiAgICAgICAgICAgICAgICBcImxpbWl0XCIsXHJcbiAgICAgICAgICAgICAgICBcInBhZGRpbmdcIixcclxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIixcclxuICAgICAgICAgICAgICAgIFwiYW5pbWF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJzbmFwXCIsXHJcbiAgICAgICAgICAgICAgICBcInN0ZXBcIixcclxuICAgICAgICAgICAgICAgIFwiZm9ybWF0XCIsXHJcbiAgICAgICAgICAgICAgICBcInBpcHNcIixcclxuICAgICAgICAgICAgICAgIFwidG9vbHRpcHNcIlxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBjaGFuZ2Ugb3B0aW9ucyB0aGF0IHdlJ3JlIGFjdHVhbGx5IHBhc3NlZCB0byB1cGRhdGUuXHJcbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdW5kZWZpbmVkLiBudWxsIHJlbW92ZXMgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdPcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgbmV3IG9wdGlvbnMgaW50byB0aGUgc2xpZGVyIHN0YXRlXHJcbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gbmV3T3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9TcGVjdHJ1bSA9IG5ld09wdGlvbnMuc3BlY3RydW07XHJcblxyXG4gICAgICAgICAgICAvLyBMaW1pdCwgbWFyZ2luIGFuZCBwYWRkaW5nIGRlcGVuZCBvbiB0aGUgc3BlY3RydW0gYnV0IGFyZSBzdG9yZWQgb3V0c2lkZSBvZiBpdC4gKCM2NzcpXHJcbiAgICAgICAgICAgIG9wdGlvbnMubWFyZ2luID0gbmV3T3B0aW9ucy5tYXJnaW47XHJcbiAgICAgICAgICAgIG9wdGlvbnMubGltaXQgPSBuZXdPcHRpb25zLmxpbWl0O1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBuZXdPcHRpb25zLnBhZGRpbmc7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGlwcywgcmVtb3ZlcyBleGlzdGluZy5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xyXG4gICAgICAgICAgICAgICAgcGlwcyhvcHRpb25zLnBpcHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlUGlwcygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwcygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBzbyB2YWx1ZVNldCBmb3JjZXMgYW4gdXBkYXRlLlxyXG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9uc1RvVXBkYXRlLnN0YXJ0IHx8IHYsIGZpcmVTZXRFdmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBzdGVwc1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwU2xpZGVyKCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGJhc2UgZWxlbWVudCwgaW5pdGlhbGl6ZSBIVE1MIGFuZCBzZXQgY2xhc3Nlcy5cclxuICAgICAgICAgICAgLy8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXHJcbiAgICAgICAgICAgIHNjb3BlX0Jhc2UgPSBhZGRTbGlkZXIoc2NvcGVfVGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgIGFkZEVsZW1lbnRzKG9wdGlvbnMuY29ubmVjdCwgc2NvcGVfQmFzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBdHRhY2ggdXNlciBldmVudHMuXHJcbiAgICAgICAgICAgIGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBwdWJsaWMgdmFsdWUgbWV0aG9kIHRvIHNldCB0aGUgc3RhcnQgdmFsdWVzLlxyXG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcclxuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHMpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFyaWEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHVwU2xpZGVyKCk7XHJcblxyXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuICAgICAgICBzY29wZV9TZWxmID0ge1xyXG4gICAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxyXG4gICAgICAgICAgICBzdGVwczogZ2V0TmV4dFN0ZXBzLFxyXG4gICAgICAgICAgICBvbjogYmluZEV2ZW50LFxyXG4gICAgICAgICAgICBvZmY6IHJlbW92ZUV2ZW50LFxyXG4gICAgICAgICAgICBnZXQ6IHZhbHVlR2V0LFxyXG4gICAgICAgICAgICBzZXQ6IHZhbHVlU2V0LFxyXG4gICAgICAgICAgICBzZXRIYW5kbGU6IHZhbHVlU2V0SGFuZGxlLFxyXG4gICAgICAgICAgICByZXNldDogdmFsdWVSZXNldCxcclxuICAgICAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAgICBfX21vdmVIYW5kbGVzOiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlSGFuZGxlcyhhLCBiLCBzY29wZV9Mb2NhdGlvbnMsIGMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcHRpb25zOiBvcmlnaW5hbE9wdGlvbnMsIC8vIElzc3VlICM2MDAsICM2NzhcclxuICAgICAgICAgICAgdXBkYXRlT3B0aW9uczogdXBkYXRlT3B0aW9ucyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBzY29wZV9UYXJnZXQsIC8vIElzc3VlICM1OTdcclxuICAgICAgICAgICAgcmVtb3ZlUGlwczogcmVtb3ZlUGlwcyxcclxuICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHM6IHJlbW92ZVRvb2x0aXBzLFxyXG4gICAgICAgICAgICBwaXBzOiBwaXBzIC8vIElzc3VlICM1OTRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gc2NvcGVfU2VsZjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSdW4gdGhlIHN0YW5kYXJkIGluaXRpYWxpemVyXHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplKHRhcmdldCwgb3JpZ2luYWxPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5ub2RlTmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IGNyZWF0ZSByZXF1aXJlcyBhIHNpbmdsZSBlbGVtZW50LCBnb3Q6IFwiICsgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBzbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgaWYgKHRhcmdldC5ub1VpU2xpZGVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogU2xpZGVyIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRlc3QgdGhlIG9wdGlvbnMgYW5kIGNyZWF0ZSB0aGUgc2xpZGVyIGVudmlyb25tZW50O1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zLCB0YXJnZXQpO1xyXG4gICAgICAgIHZhciBhcGkgPSBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xyXG5cclxuICAgICAgICByZXR1cm4gYXBpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIGZvciBmdXR1cmUgZXhwYW5kYWJpbGl0eTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgIF9fc3BlY3RydW06IFNwZWN0cnVtLFxyXG4gICAgICAgIHZlcnNpb246IFZFUlNJT04sXHJcbiAgICAgICAgY3JlYXRlOiBpbml0aWFsaXplXHJcbiAgICB9O1xyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n')},44:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=template&id=a95d0764&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.items.length > 0),expression:\"items.length > 0\"}],staticClass:\"catalog-control__menu catalog-control__menu_white\"},[_c('div',{staticClass:\"category-list-mob\"},[_c('div',{staticClass:\"category-list-mob__item\",class:{active: _vm.checkedItems.length === 0},on:{\"click\":_vm.onReset}},[_c('div',{staticClass:\"category-list-mob__label\"},[_vm._v(_vm._s(_vm.filter.name === 'Category' ? 'Все категории' : 'Все'))])]),_vm._v(\" \"),_vm._l((_vm.items),function(item){return _c('div',{staticClass:\"category-list-mob__item\",class:{active: item.checked, 'category-list-mob__item_parent': !_vm.filter.parent},on:{\"click\":function($event){return _vm.onClick(item)}}},[_c('div',{staticClass:\"category-list-mob__label\"},[_vm._v(_vm._s(item.label))])])})],2)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=template&id=a95d0764&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js\nvar vuex_esm = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var CatalogFilterMobileHorizontalvue_type_script_lang_js_ = ({\n  name: \"CatalogFilterMobileHorizontal\",\n  props: {\n    filter: {\n      type: Object\n    }\n  },\n  computed: {\n    items: function items() {\n      if (this.filter.parent) {\n        // TODO: Как-то поправить эту хуйню с обновлениием наследника при изменении родителя, см. Multifilter.vue\n        // const checkedParentItemIds = this.$store.getters['filters/checkedItemIdsByName'](this.filter.parent);\n        var parent = typeof this.filter.parent === 'string' ? this.$store.state.filters.filters[this.filter.parent] : this.filter.parent;\n        var checkedParentItemIds = parent.data.filter(function (item) {\n          return item.checked;\n        }).map(function (item) {\n          return item.value;\n        }); // TODO: Добавить полифилл для Array.prototype.includes()\n\n        return this.filter.data.filter(function (item) {\n          return checkedParentItemIds.includes(item.parent);\n        });\n      }\n\n      return this.filter.data;\n    },\n    checkedItems: function checkedItems() {\n      return this.items.filter(function (item) {\n        return item.checked;\n      });\n    }\n  },\n  methods: {\n    reset: function reset(filter) {\n      this.filter.data.forEach(function (item) {\n        item.checked = false;\n      }); // this.$store.dispatch('filters/filterReset', { container: 'filters', name: filter.name, type: filter.type });\n    },\n    onReset: function onReset() {\n      this.reset(this.filter);\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    },\n    onClick: function onClick(item) {\n      this.reset(this.filter);\n      item.checked = true;\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CatalogFilterMobileHorizontalvue_type_script_lang_js_ = (CatalogFilterMobileHorizontalvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  components_CatalogFilterMobileHorizontalvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"a95d0764\",\n  null\n  \n)\n\n/* harmony default export */ var CatalogFilterMobileHorizontal = __webpack_exports__[\"a\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9DYXRhbG9nRmlsdGVyTW9iaWxlSG9yaXpvbnRhbC52dWU/NWRmNSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlPzk1MTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP2JlNGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlPzYyOWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQixhQUFhLHdGQUF3RixrRUFBa0UsWUFBWSxnQ0FBZ0MsWUFBWSw2Q0FBNkMsc0NBQXNDLEtBQUsscUJBQXFCLFlBQVksdUNBQXVDLDZIQUE2SCxpQkFBaUIsNkNBQTZDLDJFQUEyRSxLQUFLLHlCQUF5QiwyQkFBMkIsWUFBWSx1Q0FBdUMsaUNBQWlDO0FBQzUzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDa0JBO0FBRUE7QUFDQSx1Q0FEQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBREEsR0FGQTtBQU9BO0FBQ0EsU0FEQSxtQkFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBLDhEQUNBLHFEQURBLEdBRUEsa0JBRkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBVEEsQ0FXQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBLEtBakJBO0FBa0JBLGdCQWxCQSwwQkFrQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQXBCQSxHQVBBO0FBNkJBO0FBQ0EsU0FEQSxpQkFDQSxNQURBLEVBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FGQSxFQURBLENBSUE7QUFDQSxLQU5BO0FBT0EsV0FQQSxxQkFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBLEtBWkE7QUFhQSxXQWJBLG1CQWFBLElBYkEsRUFhQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFuQkE7QUE3QkEsRzs7QUNyQjZNLENBQWdCLDBKQUFHLEVBQUMsQzs7Ozs7QUNBekc7QUFDdkM7QUFDTDs7O0FBRzVFO0FBQzZGO0FBQzdGLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLGdFQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLDhHIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLml0ZW1zLmxlbmd0aCA+IDApLGV4cHJlc3Npb246XCJpdGVtcy5sZW5ndGggPiAwXCJ9XSxzdGF0aWNDbGFzczpcImNhdGFsb2ctY29udHJvbF9fbWVudSBjYXRhbG9nLWNvbnRyb2xfX21lbnVfd2hpdGVcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGVnb3J5LWxpc3QtbW9iXCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRlZ29yeS1saXN0LW1vYl9faXRlbVwiLGNsYXNzOnthY3RpdmU6IF92bS5jaGVja2VkSXRlbXMubGVuZ3RoID09PSAwfSxvbjp7XCJjbGlja1wiOl92bS5vblJlc2V0fX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhfdm0uZmlsdGVyLm5hbWUgPT09ICdDYXRlZ29yeScgPyAn0JLRgdC1INC60LDRgtC10LPQvtGA0LjQuCcgOiAn0JLRgdC1JykpXSldKSxfdm0uX3YoXCIgXCIpLF92bS5fbCgoX3ZtLml0ZW1zKSxmdW5jdGlvbihpdGVtKXtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY2F0ZWdvcnktbGlzdC1tb2JfX2l0ZW1cIixjbGFzczp7YWN0aXZlOiBpdGVtLmNoZWNrZWQsICdjYXRlZ29yeS1saXN0LW1vYl9faXRlbV9wYXJlbnQnOiAhX3ZtLmZpbHRlci5wYXJlbnR9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLm9uQ2xpY2soaXRlbSl9fX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhpdGVtLmxhYmVsKSldKV0pfSldLDIpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImNhdGFsb2ctY29udHJvbF9fbWVudSBjYXRhbG9nLWNvbnRyb2xfX21lbnVfd2hpdGVcIiB2LXNob3c9XCJpdGVtcy5sZW5ndGggPiAwXCI+XG4gICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5LWxpc3QtbW9iXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnktbGlzdC1tb2JfX2l0ZW1cIlxuICAgICAgICAgICAgICA6Y2xhc3M9XCJ7YWN0aXZlOiBjaGVja2VkSXRlbXMubGVuZ3RoID09PSAwfVwiXG4gICAgICAgICAgICAgIEBjbGljaz1cIm9uUmVzZXRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwiPnt7ZmlsdGVyLm5hbWUgPT09ICdDYXRlZ29yeScgPyAn0JLRgdC1INC60LDRgtC10LPQvtGA0LjQuCcgOiAn0JLRgdC1J319PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjYXRlZ29yeS1saXN0LW1vYl9faXRlbVwiXG4gICAgICAgICAgICAgIHYtZm9yPVwiaXRlbSBpbiBpdGVtc1wiXG4gICAgICAgICAgICAgIDpjbGFzcz1cInthY3RpdmU6IGl0ZW0uY2hlY2tlZCwgJ2NhdGVnb3J5LWxpc3QtbW9iX19pdGVtX3BhcmVudCc6ICFmaWx0ZXIucGFyZW50fVwiXG4gICAgICAgICAgICAgIEBjbGljaz1cIm9uQ2xpY2soaXRlbSlcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwiPnt7aXRlbS5sYWJlbH19PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwQWN0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiBcIkNhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsXCIsXG4gICAgcHJvcHM6IHtcbiAgICAgIGZpbHRlcjoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB9LFxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGl0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXIucGFyZW50KSB7XG4gICAgICAgICAgLy8gVE9ETzog0JrQsNC6LdGC0L4g0L/QvtC/0YDQsNCy0LjRgtGMINGN0YLRgyDRhdGD0LnQvdGOINGBINC+0LHQvdC+0LLQu9C10L3QuNC40LXQvCDQvdCw0YHQu9C10LTQvdC40LrQsCDQv9GA0Lgg0LjQt9C80LXQvdC10L3QuNC4INGA0L7QtNC40YLQtdC70Y8sINGB0LwuIE11bHRpZmlsdGVyLnZ1ZVxuICAgICAgICAgIC8vIGNvbnN0IGNoZWNrZWRQYXJlbnRJdGVtSWRzID0gdGhpcy4kc3RvcmUuZ2V0dGVyc1snZmlsdGVycy9jaGVja2VkSXRlbUlkc0J5TmFtZSddKHRoaXMuZmlsdGVyLnBhcmVudCk7XG5cblxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9ICh0eXBlb2YgdGhpcy5maWx0ZXIucGFyZW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgID8gdGhpcy4kc3RvcmUuc3RhdGUuZmlsdGVycy5maWx0ZXJzW3RoaXMuZmlsdGVyLnBhcmVudF1cbiAgICAgICAgICAgIDogdGhpcy5maWx0ZXIucGFyZW50O1xuXG4gICAgICAgICAgY29uc3QgY2hlY2tlZFBhcmVudEl0ZW1JZHMgPSBwYXJlbnQuZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuXG4gICAgICAgICAgLy8gVE9ETzog0JTQvtCx0LDQstC40YLRjCDQv9C+0LvQuNGE0LjQu9C7INC00LvRjyBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMoKVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5kYXRhLmZpbHRlcihpdGVtID0+IGNoZWNrZWRQYXJlbnRJdGVtSWRzLmluY2x1ZGVzKGl0ZW0ucGFyZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyLmRhdGE7XG4gICAgICB9LFxuICAgICAgY2hlY2tlZEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlc2V0KGZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlci5kYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL2ZpbHRlclJlc2V0JywgeyBjb250YWluZXI6ICdmaWx0ZXJzJywgbmFtZTogZmlsdGVyLm5hbWUsIHR5cGU6IGZpbHRlci50eXBlIH0pO1xuICAgICAgfSxcbiAgICAgIG9uUmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXQodGhpcy5maWx0ZXIpO1xuXG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soaXRlbSkge1xuICAgICAgICB0aGlzLnJlc2V0KHRoaXMuZmlsdGVyKTtcbiAgICAgICAgaXRlbS5jaGVja2VkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICAgIH0sXG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblxuPC9zdHlsZT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0NhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWE5NWQwNzY0JnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0NhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCJhOTVkMDc2NFwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n")},58:function(module,exports){eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz80YTRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58\n")},59:function(module,exports,__webpack_require__){eval("var getPrototypeOf = __webpack_require__(11);\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzPzlmNzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsRUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59\n")},9:function(module,exports){eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/M2M5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")}},[[262,1,0]]]);