/*!
 * Front for marketdo4a.com 1.4.0-beta.1 
 * (c) 2020 Roman Meshcheryakov
 */
(window.webpackJsonp=window.webpackJsonp||[]).push([[10,12],{11:function(module,exports){eval("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcz8zNmM2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n")},14:function(module,exports){eval("module.exports = jQuery;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")},15:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Multifilter; });\n/* unused harmony export RadioFilter */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return PriceFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CheckboxFilter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return SelectFilter; });\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n/* harmony import */ var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);\n/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21);\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(8);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6);\n/* harmony import */ var _catalog_FilterCheckbox_vue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(22);\n/* harmony import */ var _catalog_FilterSelect_vue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(23);\n/* harmony import */ var _catalog_FilterPrice_vue__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(24);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(3);\n\n\n\n\n\n\n\n\n\n// import SimpleBar from 'simplebar';\n// import noUiSlider from 'nouislider';\n // import MultifilterRadio from './catalog/MultifilterRadio.vue';\n\n\n\n\n\n/*\n Прости меня господь за эту хуиту ((\n */\n\nvar Multifilter =\n/*#__PURE__*/\nfunction () {\n  function Multifilter(el, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, Multifilter);\n\n    if (!el) return;\n    this.el = el;\n    this.valueEl = this.el.querySelector('.multifilter__value');\n    this.contentEl = this.el.querySelector('.dropdown-menu');\n    this.menuButton = this.el.querySelector('button.multifilter__content');\n    this.inputList = _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_6___default()(this.el.querySelectorAll('input'));\n    this.callback = callback;\n    this.options = {\n      type: options.type || 'simple',\n      // 'checkbox', 'radio', 'price'\n      replaceTitle: options.replaceTitle || false\n    };\n\n    if (this.options.type === 'simple') {\n      // this.inputList.forEach(item => item.addEventListener('change', this.callback));\n      this.el.addEventListener('change', function (event) {\n        return _this.callback(event);\n      });\n    }\n  }\n  /**\n   * Инициализирует кастомную прокрутку\n   *\n   * @returns {SimpleBar|boolean}\n   */\n\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(Multifilter, [{\n    key: \"initScrollbar\",\n    value: function initScrollbar() {\n      if (!this.contentEl) return false; // const simpleBar = new SimpleBar(this.contentEl, { autoHide: false });\n      // this.contentEl = simpleBar.getContentElement();\n      // return simpleBar;\n    }\n    /**\n     * Обновляет заголовок\n     *\n     * @param {Array|String} [title=''] - Строка или массив вставляемых значений\n     * @returns {String} title\n     */\n\n  }, {\n    key: \"updateTitle\",\n    value: function updateTitle() {\n      var title = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      var newTitle = Array.isArray(title) ? title.join(', ') : title;\n\n      if (newTitle === '') {\n        newTitle = 'Не выбрано';\n      }\n\n      this.valueEl.innerHTML = newTitle;\n      return title;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.inputList.forEach(function (input) {\n        if (!(input.disabled || !input.type)) {\n          switch (input.type.toLowerCase()) {\n            case 'text':\n            case 'password':\n            case 'textarea':\n            case 'hidden':\n              input.value = '';\n              break;\n\n            case 'radio':\n              if (!input.hasAttribute('checked')) {\n                input.checked = false;\n              }\n\n              break;\n\n            case 'checkbox':\n              input.checked = false;\n              break;\n\n            case 'select-one':\n            case 'select-multi':\n              input.selectedIndex = -1;\n              break;\n\n            default:\n              break;\n          }\n        }\n      });\n      this.callback(this);\n    }\n  }]);\n\n  return Multifilter;\n}();\n/**\n * RadioFilter\n */\n\nvar RadioFilter =\n/*#__PURE__*/\nfunction (_Multifilter) {\n  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(RadioFilter, _Multifilter);\n\n  function RadioFilter(el, callback) {\n    var _this2;\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, RadioFilter);\n\n    _this2 = _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0___default()(this, _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter).call(this, el, callback, {\n      type: 'radio'\n    }));\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_5___default()(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2), \"onChange\", function (event) {\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"updateTitle\", _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2)).call(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2), event.target.nextElementSibling.textContent);\n\n      _this2.callback(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2));\n    });\n\n    _this2.el.addEventListener('change', _this2.onChange);\n\n    _this2.defaultInput = _this2.el.querySelector('input[checked]');\n\n    _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"updateTitle\", _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2)).call(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2), _this2.defaultInput.nextElementSibling.textContent);\n\n    if (_this2.inputList.length > 9) {\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"initScrollbar\", _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2)).call(_babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1___default()(_this2));\n    }\n\n    return _this2;\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(RadioFilter, [{\n    key: \"reset\",\n    value: function reset() {\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"reset\", this).call(this); // this.defaultInput.checked = true;\n\n\n      _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_4___default()(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3___default()(RadioFilter.prototype), \"updateTitle\", this).call(this, this.defaultInput.nextElementSibling.textContent); // this.callback(this);\n\n    }\n  }]);\n\n  return RadioFilter;\n}(Multifilter);\n/**\n * PriceFilter\n */\n\nvar PriceFilter =\n/*#__PURE__*/\nfunction () {\n  function PriceFilter(el) {\n    var _this3 = this;\n\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'filters';\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, PriceFilter);\n\n    this.el = el;\n    this.container = container;\n    this.filterSettings = PriceFilter.parseSettings(this.el);\n    _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].commit('filters/pushFilterToContainer', {\n      container: this.container,\n      filter: this.filterSettings\n    });\n    new vue__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]({\n      store: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"],\n      render: function render(h) {\n        return h(_catalog_FilterPrice_vue__WEBPACK_IMPORTED_MODULE_12__[/* default */ \"a\"], {\n          props: {\n            filter: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].state.filters[_this3.container][_this3.filterSettings.name]\n          }\n        });\n      }\n    }).$mount(this.el);\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(PriceFilter, null, [{\n    key: \"parseSettings\",\n    value: function parseSettings(multifilterEl) {\n      var container = multifilterEl.querySelector('.multifilter-price');\n      var option = {\n        label: multifilterEl.querySelector('.multifilter__value').textContent,\n        type: 'range',\n        name: 'price',\n        data: {\n          minRange: null,\n          maxRange: null,\n          priceFrom: 0,\n          priceTo: 0,\n          priceMin: 0,\n          priceMax: 10000\n        }\n      };\n\n      if (container.querySelector('input[name=\"price[from]\"]')) {\n        option.data.priceFrom = parseInt(container.querySelector('input[name=\"price[from]\"]').value, 10) || 0;\n      }\n\n      if (container.querySelector('input[name=\"price[to]\"]')) {\n        option.data.priceTo = parseInt(container.querySelector('input[name=\"price[to]\"]').value, 10) || 0;\n      }\n\n      if (container.querySelector('.multifilter-price__num .multifilter-price__start')) {\n        option.data.priceMin = parseInt(container.querySelector('.multifilter-price__num .multifilter-price__start').textContent.replace(/[^0-9]/g, ''), 10) || 0;\n      }\n\n      if (container.querySelector('.multifilter-price__num .multifilter-price__end')) {\n        option.data.priceMax = parseInt(container.querySelector('.multifilter-price__num .multifilter-price__end').textContent.replace(/[^0-9]/g, ''), 10) || 10000;\n      }\n\n      if (option.data.priceFrom < option.data.priceMin) {\n        option.data.priceFrom = option.data.priceMin;\n      }\n\n      if (option.data.priceTo > option.data.priceMax || option.data.priceTo === 0) {\n        option.data.priceTo = option.data.priceMax;\n      }\n\n      return option;\n    }\n  }]);\n\n  return PriceFilter;\n}();\n/**\n * CheckboxFilter\n */\n\nvar CheckboxFilter =\n/*#__PURE__*/\nfunction () {\n  function CheckboxFilter(el) {\n    var _this4 = this;\n\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'filters';\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, CheckboxFilter);\n\n    this.el = el;\n    this.container = container;\n    this.filterSettings = CheckboxFilter.parseSettings(this.el);\n    _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].commit('filters/pushFilterToContainer', {\n      container: this.container,\n      filter: this.filterSettings\n    });\n    new vue__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]({\n      store: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"],\n      render: function render(h) {\n        return h(_catalog_FilterCheckbox_vue__WEBPACK_IMPORTED_MODULE_10__[/* default */ \"a\"], {\n          props: {\n            filter: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].state.filters[_this4.container][_this4.filterSettings.name]\n          }\n        });\n      }\n    }).$mount(this.el);\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(CheckboxFilter, null, [{\n    key: \"parseSettings\",\n    value: function parseSettings(multifilterEl) {\n      var option = {\n        type: 'checkbox',\n        replaceTitle: false,\n        label: multifilterEl.querySelector('.multifilter__value').textContent,\n        labelDisabled: 'Выберите тип товара',\n        labelEmpty: 'Не выбрано',\n        disabled: multifilterEl.disabled,\n        name: multifilterEl.dataset.filterName || '',\n        parent: multifilterEl.dataset.filterParent || '',\n        selectedItems: [],\n        // Не используется, но пусть будет\n        data: []\n      };\n\n      if (multifilterEl.querySelector('.multifilter__label')) {\n        option.replaceTitle = true;\n        option.label = multifilterEl.querySelector('.multifilter__label').textContent;\n      }\n\n      [].forEach.call(multifilterEl.querySelectorAll('input[type=\"checkbox\"]'), function (input, i) {\n        if (!option.name) {\n          option.name = input.name.replace('[]', '');\n        }\n\n        if (input.checked) {\n          option.selectedItems.push(input.value);\n        }\n\n        option.data.push({\n          label: input.parentElement.querySelector('.multifilter-checkbox__label').textContent,\n          id: i,\n          name: input.name || '',\n          value: input.value,\n          checked: input.checked,\n          // true, если активен\n          available: !input.disabled,\n          // true, если в наличии\n          parent: input.dataset.parentId,\n          // Наследование значения (если есть)\n          hidden: input.parentElement.style.display === 'none' && !input.checked // Визуально скрыт, показать, если вдруг будет активен\n\n        });\n      });\n\n      if (!option.name) {\n        option.name = option.label;\n      } // store.commit('filters/setFilter', option);\n\n\n      return option;\n    }\n  }]);\n\n  return CheckboxFilter;\n}(); // export function getFilterCheckbox(el, container = 'filters') {\n//   const settings = CheckboxFilter.parseSettings(el);\n//   store.commit('filters/pushFilterToContainer', { container, filter: settings });\n//\n//   return new Vue({\n//     store,\n//     render: h => h(FilterCheckbox, {\n//       props: { filter: store.state.filters[container][settings.name] },\n//     }),\n//   }).$mount(el);\n// }\n\n/**\n * SelectFilter\n */\n\nvar SelectFilter =\n/*#__PURE__*/\nfunction () {\n  function SelectFilter(el) {\n    var _this5 = this;\n\n    var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'sort';\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_7___default()(this, SelectFilter);\n\n    this.el = el;\n    this.container = container;\n    this.filterSettings = SelectFilter.parseSettings(this.el);\n    _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].commit('filters/pushFilterToContainer', {\n      container: this.container,\n      filter: this.filterSettings\n    });\n    new vue__WEBPACK_IMPORTED_MODULE_9__[/* default */ \"a\"]({\n      store: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"],\n      render: function render(h) {\n        return h(_catalog_FilterSelect_vue__WEBPACK_IMPORTED_MODULE_11__[/* default */ \"a\"], {\n          props: {\n            filter: _store__WEBPACK_IMPORTED_MODULE_13__[/* default */ \"a\"].state.filters[_this5.container][_this5.filterSettings.name]\n          }\n        });\n      }\n    }).$mount(this.el);\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_8___default()(SelectFilter, null, [{\n    key: \"parseSettings\",\n    value: function parseSettings(multifilterEl) {\n      var option = {\n        type: 'radio',\n        label: 'Не выбрано',\n        selected: null,\n        name: multifilterEl.dataset.filterName || '',\n        data: []\n      };\n      [].forEach.call(multifilterEl.querySelectorAll('input[type=\"radio\"]'), function (input) {\n        if (!option.name) {\n          option.name = input.name;\n        }\n\n        if (input.checked) {\n          option.selected = input.value;\n          option.label = input.parentElement.querySelector('.multifilter-radio__label').textContent;\n        }\n\n        option.data.push({\n          label: input.parentElement.querySelector('.multifilter-radio__label').textContent,\n          name: input.name || '',\n          value: input.value,\n          checked: input.checked\n        });\n      });\n\n      if (!option.name) {\n        option.name = option.label;\n      }\n\n      return option;\n    }\n  }]);\n\n  return SelectFilter;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9NdWx0aWZpbHRlci5qcz85ODgxIl0sIm5hbWVzIjpbIk11bHRpZmlsdGVyIiwiZWwiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJ2YWx1ZUVsIiwicXVlcnlTZWxlY3RvciIsImNvbnRlbnRFbCIsIm1lbnVCdXR0b24iLCJpbnB1dExpc3QiLCJxdWVyeVNlbGVjdG9yQWxsIiwidHlwZSIsInJlcGxhY2VUaXRsZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInRpdGxlIiwibmV3VGl0bGUiLCJBcnJheSIsImlzQXJyYXkiLCJqb2luIiwiaW5uZXJIVE1MIiwiZm9yRWFjaCIsImlucHV0IiwiZGlzYWJsZWQiLCJ0b0xvd2VyQ2FzZSIsInZhbHVlIiwiaGFzQXR0cmlidXRlIiwiY2hlY2tlZCIsInNlbGVjdGVkSW5kZXgiLCJSYWRpb0ZpbHRlciIsInRhcmdldCIsIm5leHRFbGVtZW50U2libGluZyIsInRleHRDb250ZW50Iiwib25DaGFuZ2UiLCJkZWZhdWx0SW5wdXQiLCJsZW5ndGgiLCJQcmljZUZpbHRlciIsImNvbnRhaW5lciIsImZpbHRlclNldHRpbmdzIiwicGFyc2VTZXR0aW5ncyIsInN0b3JlIiwiY29tbWl0IiwiZmlsdGVyIiwiVnVlIiwicmVuZGVyIiwiaCIsIkZpbHRlclByaWNlIiwicHJvcHMiLCJzdGF0ZSIsImZpbHRlcnMiLCJuYW1lIiwiJG1vdW50IiwibXVsdGlmaWx0ZXJFbCIsIm9wdGlvbiIsImxhYmVsIiwiZGF0YSIsIm1pblJhbmdlIiwibWF4UmFuZ2UiLCJwcmljZUZyb20iLCJwcmljZVRvIiwicHJpY2VNaW4iLCJwcmljZU1heCIsInBhcnNlSW50IiwicmVwbGFjZSIsIkNoZWNrYm94RmlsdGVyIiwiRmlsdGVyQ2hlY2tib3giLCJsYWJlbERpc2FibGVkIiwibGFiZWxFbXB0eSIsImRhdGFzZXQiLCJmaWx0ZXJOYW1lIiwicGFyZW50IiwiZmlsdGVyUGFyZW50Iiwic2VsZWN0ZWRJdGVtcyIsImNhbGwiLCJpIiwicHVzaCIsInBhcmVudEVsZW1lbnQiLCJpZCIsImF2YWlsYWJsZSIsInBhcmVudElkIiwiaGlkZGVuIiwic3R5bGUiLCJkaXNwbGF5IiwiU2VsZWN0RmlsdGVyIiwiRmlsdGVyU2VsZWN0Iiwic2VsZWN0ZWQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0NBSUE7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFHQTs7OztBQUlPLElBQU1BLFdBQWI7QUFBQTtBQUFBO0FBQ0UsdUJBQVlDLEVBQVosRUFBZ0JDLFFBQWhCLEVBQXdDO0FBQUE7O0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJOztBQUFBOztBQUN0QyxRQUFJLENBQUNGLEVBQUwsRUFBUztBQUVULFNBQUtBLEVBQUwsR0FBVUEsRUFBVjtBQUNBLFNBQUtHLE9BQUwsR0FBZSxLQUFLSCxFQUFMLENBQVFJLGFBQVIsQ0FBc0IscUJBQXRCLENBQWY7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLEtBQUtMLEVBQUwsQ0FBUUksYUFBUixDQUFzQixnQkFBdEIsQ0FBakI7QUFDQSxTQUFLRSxVQUFMLEdBQWtCLEtBQUtOLEVBQUwsQ0FBUUksYUFBUixDQUFzQiw2QkFBdEIsQ0FBbEI7QUFFQSxTQUFLRyxTQUFMLG1GQUFxQixLQUFLUCxFQUFMLENBQVFRLGdCQUFSLENBQXlCLE9BQXpCLENBQXJCO0FBRUEsU0FBS1AsUUFBTCxHQUFnQkEsUUFBaEI7QUFFQSxTQUFLQyxPQUFMLEdBQWU7QUFDYk8sVUFBSSxFQUFFUCxPQUFPLENBQUNPLElBQVIsSUFBZ0IsUUFEVDtBQUNtQjtBQUNoQ0Msa0JBQVksRUFBRVIsT0FBTyxDQUFDUSxZQUFSLElBQXdCO0FBRnpCLEtBQWY7O0FBS0EsUUFBSSxLQUFLUixPQUFMLENBQWFPLElBQWIsS0FBc0IsUUFBMUIsRUFBb0M7QUFDbEM7QUFDQSxXQUFLVCxFQUFMLENBQVFXLGdCQUFSLENBQXlCLFFBQXpCLEVBQW1DLFVB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QytCLE1BQU0sQ0FBQ0gsSUFBWixFQUFrQjtBQUNoQkcsZ0JBQU0sQ0FBQ0gsSUFBUCxHQUFjNUIsS0FBSyxDQUFDNEIsSUFBcEI7QUFDRDs7QUFFRCxZQUFJNUIsS0FBSyxDQUFDSyxPQUFWLEVBQW1CO0FBQ2pCMEIsZ0JBQU0sQ0FBQ2dDLFFBQVAsR0FBa0IvRCxLQUFLLENBQUNHLEtBQXhCO0FBQ0E0QixnQkFBTSxDQUFDQyxLQUFQLEdBQWVoQyxLQUFLLENBQUNzRCxhQUFOLENBQW9CdEUsYUFBcEIsQ0FBa0MsMkJBQWxDLEVBQStEMEIsV0FBOUU7QUFDRDs7QUFFRHFCLGNBQU0sQ0FBQ0UsSUFBUCxDQUFZb0IsSUFBWixDQUFpQjtBQUNmckIsZUFBSyxFQUFFaEMsS0FBSyxDQUFDc0QsYUFBTixDQUFvQnRFLGFBQXBCLENBQWtDLDJCQUFsQyxFQUErRDBCLFdBRHZEO0FBRWZrQixjQUFJLEVBQUU1QixLQUFLLENBQUM0QixJQUFOLElBQWMsRUFGTDtBQUdmekIsZUFBSyxFQUFFSCxLQUFLLENBQUNHLEtBSEU7QUFJZkUsaUJBQU8sRUFBRUwsS0FBSyxDQUFDSztBQUpBLFNBQWpCO0FBTUQsT0FoQkQ7O0FBa0JBLFVBQUksQ0FBQzBCLE1BQU0sQ0FBQ0gsSUFBWixFQUFrQjtBQUNoQkcsY0FBTSxDQUFDSCxJQUFQLEdBQWNHLE1BQU0sQ0FBQ0MsS0FBckI7QUFDRDs7QUFFRCxhQUFPRCxNQUFQO0FBQ0Q7QUFsREg7O0FBQUE7QUFBQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydCBTaW1wbGVCYXIgZnJvbSAnc2ltcGxlYmFyJztcbi8vIGltcG9ydCBub1VpU2xpZGVyIGZyb20gJ25vdWlzbGlkZXInO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5cbi8vIGltcG9ydCBNdWx0aWZpbHRlclJhZGlvIGZyb20gJy4vY2F0YWxvZy9NdWx0aWZpbHRlclJhZGlvLnZ1ZSc7XG5pbXBvcnQgRmlsdGVyQ2hlY2tib3ggZnJvbSAnLi9jYXRhbG9nL0ZpbHRlckNoZWNrYm94LnZ1ZSc7XG5pbXBvcnQgRmlsdGVyU2VsZWN0IGZyb20gJy4vY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlJztcbmltcG9ydCBGaWx0ZXJQcmljZSBmcm9tICcuL2NhdGFsb2cvRmlsdGVyUHJpY2UudnVlJztcblxuaW1wb3J0IHN0b3JlIGZyb20gJy4uL3N0b3JlJztcblxuXG4vKlxuINCf0YDQvtGB0YLQuCDQvNC10L3RjyDQs9C+0YHQv9C+0LTRjCDQt9CwINGN0YLRgyDRhdGD0LjRgtGDICgoXG4gKi9cblxuZXhwb3J0IGNsYXNzIE11bHRpZmlsdGVyIHtcbiAgY29uc3RydWN0b3IoZWwsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWVsKSByZXR1cm47XG5cbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy52YWx1ZUVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXJfX3ZhbHVlJyk7XG4gICAgdGhpcy5jb250ZW50RWwgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJy5kcm9wZG93bi1tZW51Jyk7XG4gICAgdGhpcy5tZW51QnV0dG9uID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCdidXR0b24ubXVsdGlmaWx0ZXJfX2NvbnRlbnQnKTtcblxuICAgIHRoaXMuaW5wdXRMaXN0ID0gWy4uLnRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKV07XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiBvcHRpb25zLnR5cGUgfHwgJ3NpbXBsZScsIC8vICdjaGVja2JveCcsICdyYWRpbycsICdwcmljZSdcbiAgICAgIHJlcGxhY2VUaXRsZTogb3B0aW9ucy5yZXBsYWNlVGl0bGUgfHwgZmFsc2UsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gJ3NpbXBsZScpIHtcbiAgICAgIC8vIHRoaXMuaW5wdXRMaXN0LmZvckVhY2goaXRlbSA9PiBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuY2FsbGJhY2spKTtcbiAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZXZlbnQgPT4gdGhpcy5jYWxsYmFjayhldmVudCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDQmNC90LjRhtC40LDQu9C40LfQuNGA0YPQtdGCINC60LDRgdGC0L7QvNC90YPRjiDQv9GA0L7QutGA0YPRgtC60YNcbiAgICpcbiAgICogQHJldHVybnMge1NpbXBsZUJhcnxib29sZWFufVxuICAgKi9cbiAgaW5pdFNjcm9sbGJhcigpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudEVsKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gY29uc3Qgc2ltcGxlQmFyID0gbmV3IFNpbXBsZUJhcih0aGlzLmNvbnRlbnRFbCwgeyBhdXRvSGlkZTogZmFsc2UgfSk7XG4gICAgLy8gdGhpcy5jb250ZW50RWwgPSBzaW1wbGVCYXIuZ2V0Q29udGVudEVsZW1lbnQoKTtcbiAgICAvLyByZXR1cm4gc2ltcGxlQmFyO1xuICB9XG5cblxuICAvKipcbiAgICog0J7QsdC90L7QstC70Y/QtdGCINC30LDQs9C+0LvQvtCy0L7QulxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gW3RpdGxlPScnXSAtINCh0YLRgNC+0LrQsCDQuNC70Lgg0LzQsNGB0YHQuNCyINCy0YHRgtCw0LLQu9GP0LXQvNGL0YUg0LfQvdCw0YfQtdC90LjQuVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aXRsZVxuICAgKi9cbiAgdXBkYXRlVGl0bGUodGl0bGUgPSAnJykge1xuICAgIGxldCBuZXdUaXRsZSA9IEFycmF5LmlzQXJyYXkodGl0bGUpID8gdGl0bGUuam9pbignLCAnKSA6IHRpdGxlO1xuICAgIGlmIChuZXdUaXRsZSA9PT0gJycpIHtcbiAgICAgIG5ld1RpdGxlID0gJ9Cd0LUg0LLRi9Cx0YDQsNC90L4nO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlRWwuaW5uZXJIVE1MID0gbmV3VGl0bGU7XG5cbiAgICByZXR1cm4gdGl0bGU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLmlucHV0TGlzdC5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKCEoaW5wdXQuZGlzYWJsZWQgfHwgIWlucHV0LnR5cGUpKSB7XG4gICAgICAgIHN3aXRjaCAoaW5wdXQudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICBjYXNlICdoaWRkZW4nOlxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncmFkaW8nOlxuICAgICAgICAgICAgaWYgKCFpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgICAgICAgICBpbnB1dC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XG4gICAgICAgICAgY2FzZSAnc2VsZWN0LW11bHRpJzpcbiAgICAgICAgICAgIGlucHV0LnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5jYWxsYmFjayh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIFJhZGlvRmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBSYWRpb0ZpbHRlciBleHRlbmRzIE11bHRpZmlsdGVyIHtcbiAgY29uc3RydWN0b3IoZWwsIGNhbGxiYWNrKSB7XG4gICAgc3VwZXIoZWwsIGNhbGxiYWNrLCB7IHR5cGU6ICdyYWRpbycgfSk7XG5cbiAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xuXG4gICAgdGhpcy5kZWZhdWx0SW5wdXQgPSB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W2NoZWNrZWRdJyk7XG4gICAgc3VwZXIudXBkYXRlVGl0bGUodGhpcy5kZWZhdWx0SW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50KTtcblxuICAgIGlmICh0aGlzLmlucHV0TGlzdC5sZW5ndGggPiA5KSB7XG4gICAgICBzdXBlci5pbml0U2Nyb2xsYmFyKCk7XG4gICAgfVxuICB9XG5cbiAgb25DaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBzdXBlci51cGRhdGVUaXRsZShldmVudC50YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50KTtcbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMpO1xuICB9O1xuXG4gIHJlc2V0KCkge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgLy8gdGhpcy5kZWZhdWx0SW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgc3VwZXIudXBkYXRlVGl0bGUodGhpcy5kZWZhdWx0SW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50KTtcbiAgICAvLyB0aGlzLmNhbGxiYWNrKHRoaXMpO1xuICB9XG59XG5cblxuLyoqXG4gKiBQcmljZUZpbHRlclxuICovXG5leHBvcnQgY2xhc3MgUHJpY2VGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihlbCwgY29udGFpbmVyID0gJ2ZpbHRlcnMnKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuZmlsdGVyU2V0dGluZ3MgPSBQcmljZUZpbHRlci5wYXJzZVNldHRpbmdzKHRoaXMuZWwpO1xuXG4gICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciwgZmlsdGVyOiB0aGlzLmZpbHRlclNldHRpbmdzIH0pO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBzdG9yZSxcbiAgICAgIHJlbmRlcjogaCA9PiBoKEZpbHRlclByaWNlLCB7XG4gICAgICAgIHByb3BzOiB7IGZpbHRlcjogc3RvcmUuc3RhdGUuZmlsdGVyc1t0aGlzLmNvbnRhaW5lcl1bdGhpcy5maWx0ZXJTZXR0aW5ncy5uYW1lXSB9LFxuICAgICAgfSksXG4gICAgfSkuJG1vdW50KHRoaXMuZWwpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2V0dGluZ3MobXVsdGlmaWx0ZXJFbCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IG11bHRpZmlsdGVyRWwucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXByaWNlJyk7XG5cbiAgICBjb25zdCBvcHRpb24gPSB7XG4gICAgICBsYWJlbDogbXVsdGlmaWx0ZXJFbC5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXJfX3ZhbHVlJykudGV4dENvbnRlbnQsXG4gICAgICB0eXBlOiAncmFuZ2UnLFxuICAgICAgbmFtZTogJ3ByaWNlJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWluUmFuZ2U6IG51bGwsXG4gICAgICAgIG1heFJhbmdlOiBudWxsLFxuXG4gICAgICAgIHByaWNlRnJvbTogMCxcbiAgICAgICAgcHJpY2VUbzogMCxcbiAgICAgICAgcHJpY2VNaW46IDAsXG4gICAgICAgIHByaWNlTWF4OiAxMDAwMCxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGlmIChjb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cInByaWNlW2Zyb21dXCJdJykpIHtcbiAgICAgIG9wdGlvbi5kYXRhLnByaWNlRnJvbSA9IHBhcnNlSW50KGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwicHJpY2VbZnJvbV1cIl0nKS52YWx1ZSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdpbnB1dFtuYW1lPVwicHJpY2VbdG9dXCJdJykpIHtcbiAgICAgIG9wdGlvbi5kYXRhLnByaWNlVG8gPSBwYXJzZUludChjb250YWluZXIucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1cInByaWNlW3RvXVwiXScpLnZhbHVlLCAxMCkgfHwgMDtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlci1wcmljZV9fbnVtIC5tdWx0aWZpbHRlci1wcmljZV9fc3RhcnQnKSkge1xuICAgICAgb3B0aW9uLmRhdGEucHJpY2VNaW4gPSBwYXJzZUludChjb250YWluZXIucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXByaWNlX19udW0gLm11bHRpZmlsdGVyLXByaWNlX19zdGFydCcpXG4gICAgICAgIC50ZXh0Q29udGVudFxuICAgICAgICAucmVwbGFjZSgvW14wLTldL2csICcnKSwgMTApIHx8IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcHJpY2VfX251bSAubXVsdGlmaWx0ZXItcHJpY2VfX2VuZCcpKSB7XG4gICAgICBvcHRpb24uZGF0YS5wcmljZU1heCA9IHBhcnNlSW50KGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcHJpY2VfX251bSAubXVsdGlmaWx0ZXItcHJpY2VfX2VuZCcpXG4gICAgICAgIC50ZXh0Q29udGVudFxuICAgICAgICAucmVwbGFjZSgvW14wLTldL2csICcnKSwgMTApIHx8IDEwMDAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb24uZGF0YS5wcmljZUZyb20gPCBvcHRpb24uZGF0YS5wcmljZU1pbikge1xuICAgICAgb3B0aW9uLmRhdGEucHJpY2VGcm9tID0gb3B0aW9uLmRhdGEucHJpY2VNaW47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbi5kYXRhLnByaWNlVG8gPiBvcHRpb24uZGF0YS5wcmljZU1heCB8fCBvcHRpb24uZGF0YS5wcmljZVRvID09PSAwKSB7XG4gICAgICBvcHRpb24uZGF0YS5wcmljZVRvID0gb3B0aW9uLmRhdGEucHJpY2VNYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrYm94RmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGVja2JveEZpbHRlciB7XG4gIGNvbnN0cnVjdG9yKGVsLCBjb250YWluZXIgPSAnZmlsdGVycycpIHtcbiAgICB0aGlzLmVsID0gZWw7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5maWx0ZXJTZXR0aW5ncyA9IENoZWNrYm94RmlsdGVyLnBhcnNlU2V0dGluZ3ModGhpcy5lbCk7XG4gICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciwgZmlsdGVyOiB0aGlzLmZpbHRlclNldHRpbmdzIH0pO1xuXG4gICAgbmV3IFZ1ZSh7XG4gICAgICBzdG9yZSxcbiAgICAgIHJlbmRlcjogaCA9PiBoKEZpbHRlckNoZWNrYm94LCB7XG4gICAgICAgIHByb3BzOiB7IGZpbHRlcjogc3RvcmUuc3RhdGUuZmlsdGVyc1t0aGlzLmNvbnRhaW5lcl1bdGhpcy5maWx0ZXJTZXR0aW5ncy5uYW1lXSB9LFxuICAgICAgfSksXG4gICAgfSkuJG1vdW50KHRoaXMuZWwpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2V0dGluZ3MobXVsdGlmaWx0ZXJFbCkge1xuICAgIGNvbnN0IG9wdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdjaGVja2JveCcsXG4gICAgICByZXBsYWNlVGl0bGU6IGZhbHNlLFxuICAgICAgbGFiZWw6IG11bHRpZmlsdGVyRWwucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyX192YWx1ZScpLnRleHRDb250ZW50LFxuICAgICAgbGFiZWxEaXNhYmxlZDogJ9CS0YvQsdC10YDQuNGC0LUg0YLQuNC/INGC0L7QstCw0YDQsCcsXG4gICAgICBsYWJlbEVtcHR5OiAn0J3QtSDQstGL0LHRgNCw0L3QvicsXG4gICAgICBkaXNhYmxlZDogbXVsdGlmaWx0ZXJFbC5kaXNhYmxlZCxcbiAgICAgIG5hbWU6IG11bHRpZmlsdGVyRWwuZGF0YXNldC5maWx0ZXJOYW1lIHx8ICcnLFxuICAgICAgcGFyZW50OiBtdWx0aWZpbHRlckVsLmRhdGFzZXQuZmlsdGVyUGFyZW50IHx8ICcnLFxuICAgICAgc2VsZWN0ZWRJdGVtczogW10sIC8vINCd0LUg0LjRgdC/0L7Qu9GM0LfRg9C10YLRgdGPLCDQvdC+INC/0YPRgdGC0Ywg0LHRg9C00LXRglxuICAgICAgZGF0YTogW10sXG4gICAgfTtcblxuICAgIGlmIChtdWx0aWZpbHRlckVsLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlcl9fbGFiZWwnKSkge1xuICAgICAgb3B0aW9uLnJlcGxhY2VUaXRsZSA9IHRydWU7XG4gICAgICBvcHRpb24ubGFiZWwgPSBtdWx0aWZpbHRlckVsLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlcl9fbGFiZWwnKS50ZXh0Q29udGVudDtcbiAgICB9XG5cbiAgICBbXS5mb3JFYWNoLmNhbGwobXVsdGlmaWx0ZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKSwgKGlucHV0LCBpKSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbi5uYW1lKSB7XG4gICAgICAgIG9wdGlvbi5uYW1lID0gaW5wdXQubmFtZS5yZXBsYWNlKCdbXScsICcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkSXRlbXMucHVzaChpbnB1dC52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbi5kYXRhLnB1c2goe1xuICAgICAgICBsYWJlbDogaW5wdXQucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItY2hlY2tib3hfX2xhYmVsJykudGV4dENvbnRlbnQsXG4gICAgICAgIGlkOiBpLFxuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lIHx8ICcnLFxuICAgICAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IGlucHV0LmNoZWNrZWQsIC8vIHRydWUsINC10YHQu9C4INCw0LrRgtC40LLQtdC9XG4gICAgICAgIGF2YWlsYWJsZTogIWlucHV0LmRpc2FibGVkLCAvLyB0cnVlLCDQtdGB0LvQuCDQsiDQvdCw0LvQuNGH0LjQuFxuICAgICAgICBwYXJlbnQ6IGlucHV0LmRhdGFzZXQucGFyZW50SWQsIC8vINCd0LDRgdC70LXQtNC+0LLQsNC90LjQtSDQt9C90LDRh9C10L3QuNGPICjQtdGB0LvQuCDQtdGB0YLRjClcbiAgICAgICAgaGlkZGVuOiBpbnB1dC5wYXJlbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyAmJiAhaW5wdXQuY2hlY2tlZCwgLy8g0JLQuNC30YPQsNC70YzQvdC+INGB0LrRgNGL0YIsINC/0L7QutCw0LfQsNGC0YwsINC10YHQu9C4INCy0LTRgNGD0LMg0LHRg9C00LXRgiDQsNC60YLQuNCy0LXQvVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoIW9wdGlvbi5uYW1lKSB7XG4gICAgICBvcHRpb24ubmFtZSA9IG9wdGlvbi5sYWJlbDtcbiAgICB9XG5cbiAgICAvLyBzdG9yZS5jb21taXQoJ2ZpbHRlcnMvc2V0RmlsdGVyJywgb3B0aW9uKTtcblxuICAgIHJldHVybiBvcHRpb247XG4gIH1cbn1cblxuLy8gZXhwb3J0IGZ1bmN0aW9uIGdldEZpbHRlckNoZWNrYm94KGVsLCBjb250YWluZXIgPSAnZmlsdGVycycpIHtcbi8vICAgY29uc3Qgc2V0dGluZ3MgPSBDaGVja2JveEZpbHRlci5wYXJzZVNldHRpbmdzKGVsKTtcbi8vICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyLCBmaWx0ZXI6IHNldHRpbmdzIH0pO1xuLy9cbi8vICAgcmV0dXJuIG5ldyBWdWUoe1xuLy8gICAgIHN0b3JlLFxuLy8gICAgIHJlbmRlcjogaCA9PiBoKEZpbHRlckNoZWNrYm94LCB7XG4vLyAgICAgICBwcm9wczogeyBmaWx0ZXI6IHN0b3JlLnN0YXRlLmZpbHRlcnNbY29udGFpbmVyXVtzZXR0aW5ncy5uYW1lXSB9LFxuLy8gICAgIH0pLFxuLy8gICB9KS4kbW91bnQoZWwpO1xuLy8gfVxuXG5cbi8qKlxuICogU2VsZWN0RmlsdGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWxlY3RGaWx0ZXIge1xuICBjb25zdHJ1Y3RvcihlbCwgY29udGFpbmVyID0gJ3NvcnQnKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgdGhpcy5maWx0ZXJTZXR0aW5ncyA9IFNlbGVjdEZpbHRlci5wYXJzZVNldHRpbmdzKHRoaXMuZWwpO1xuXG4gICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHsgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lciwgZmlsdGVyOiB0aGlzLmZpbHRlclNldHRpbmdzIH0pO1xuXG5cbiAgICBuZXcgVnVlKHtcbiAgICAgIHN0b3JlLFxuICAgICAgcmVuZGVyOiBoID0+IGgoRmlsdGVyU2VsZWN0LCB7XG4gICAgICAgIHByb3BzOiB7IGZpbHRlcjogc3RvcmUuc3RhdGUuZmlsdGVyc1t0aGlzLmNvbnRhaW5lcl1bdGhpcy5maWx0ZXJTZXR0aW5ncy5uYW1lXSB9LFxuICAgICAgfSksXG4gICAgfSkuJG1vdW50KHRoaXMuZWwpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2V0dGluZ3MobXVsdGlmaWx0ZXJFbCkge1xuICAgIGNvbnN0IG9wdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdyYWRpbycsXG4gICAgICBsYWJlbDogJ9Cd0LUg0LLRi9Cx0YDQsNC90L4nLFxuICAgICAgc2VsZWN0ZWQ6IG51bGwsXG4gICAgICBuYW1lOiBtdWx0aWZpbHRlckVsLmRhdGFzZXQuZmlsdGVyTmFtZSB8fCAnJyxcbiAgICAgIGRhdGE6IFtdLFxuICAgIH07XG5cbiAgICBbXS5mb3JFYWNoLmNhbGwobXVsdGlmaWx0ZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKSwgKGlucHV0KSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbi5uYW1lKSB7XG4gICAgICAgIG9wdGlvbi5uYW1lID0gaW5wdXQubmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaW5wdXQudmFsdWU7XG4gICAgICAgIG9wdGlvbi5sYWJlbCA9IGlucHV0LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXJhZGlvX19sYWJlbCcpLnRleHRDb250ZW50O1xuICAgICAgfVxuXG4gICAgICBvcHRpb24uZGF0YS5wdXNoKHtcbiAgICAgICAgbGFiZWw6IGlucHV0LnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXJhZGlvX19sYWJlbCcpLnRleHRDb250ZW50LFxuICAgICAgICBuYW1lOiBpbnB1dC5uYW1lIHx8ICcnLFxuICAgICAgICB2YWx1ZTogaW5wdXQudmFsdWUsXG4gICAgICAgIGNoZWNrZWQ6IGlucHV0LmNoZWNrZWQsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmICghb3B0aW9uLm5hbWUpIHtcbiAgICAgIG9wdGlvbi5uYW1lID0gb3B0aW9uLmxhYmVsO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb247XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n")},17:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/Dropdown.vue?vue&type=template&id=f86c24e2&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'fieldset\',_vm._b({directives:[{name:"click-outside",rawName:"v-click-outside",value:(_vm.close),expression:"close"}],class:{ show: _vm.visible }},\'fieldset\',_vm.$attrs,false),[_c(\'button\',{staticClass:"multifilter__content multifilter__content_dropdown",attrs:{"type":"button"},on:{"click":function($event){$event.preventDefault();return _vm.toggle($event)}}},[_vm._t("btn")],2),_vm._v(" "),_vm._t("default"),_vm._v(" "),_c(\'div\',{ref:"menu",staticClass:"dropdown-menu",class:{ show: _vm.visible }},[_vm._t("body")],2)],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/Dropdown.vue?vue&type=template&id=f86c24e2&\n\n// EXTERNAL MODULE: ./node_modules/simplebar/dist/simplebar.esm.js\nvar simplebar_esm = __webpack_require__(36);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/Dropdown.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n // import simplebar from \'simplebar-vue\';\n// import \'simplebar/dist/simplebar.min.css\';\n\n/* harmony default export */ var Dropdownvue_type_script_lang_js_ = ({\n  name: \'MultifilterDropdown\',\n  // components: {\n  //   simplebar\n  // },\n  props: {\n    scrolled: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function data() {\n    return {\n      visible: false\n    };\n  },\n  mounted: function mounted() {\n    // $(this.$el).on(\'hidden.bs.dropdown\', () => {\n    //   this.visible = false;\n    // });\n    // $(this.$el).on(\'shown.bs.dropdown\', () => {\n    //   this.visible = true;\n    // });\n    if (this.scrolled) {\n      new simplebar_esm["a" /* default */](this.$refs.menu, {\n        autoHide: false\n      });\n    }\n  },\n  methods: {\n    open: function open() {\n      this.visible = true;\n    },\n    close: function close() {\n      this.visible = false;\n    },\n    toggle: function toggle() {\n      this.visible = !this.visible;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/Dropdown.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Dropdownvue_type_script_lang_js_ = (Dropdownvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/Dropdown.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  components_Dropdownvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Dropdown = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9Ecm9wZG93bi52dWU/MzRiMSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvRHJvcGRvd24udnVlP2U4N2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvRHJvcGRvd24udnVlPzhhOGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvRHJvcGRvd24udnVlP2FmZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLDZCQUE2QixhQUFhLG9GQUFvRixTQUFTLHFCQUFxQiw0Q0FBNEMsd0VBQXdFLGdCQUFnQixLQUFLLHlCQUF5Qix3QkFBd0IsNEJBQTRCLHdFQUF3RSw4Q0FBOEMscUJBQXFCO0FBQ3RsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NDK0JBO0FBQ0E7O0FBRUE7QUFDQSw2QkFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFEQTtBQUVBO0FBRkE7QUFEQSxHQUxBO0FBV0EsTUFYQSxrQkFXQTtBQUNBO0FBQ0E7QUFEQTtBQUdBLEdBZkE7QUFnQkEsU0FoQkEscUJBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBLEdBM0JBO0FBNEJBO0FBQ0EsUUFEQSxrQkFDQTtBQUNBO0FBQ0EsS0FIQTtBQUlBLFNBSkEsbUJBSUE7QUFDQTtBQUNBLEtBTkE7QUFPQSxVQVBBLG9CQU9BO0FBQ0E7QUFDQTtBQVRBO0FBNUJBLEc7O0FDbkN3TCxDQUFnQixnSEFBRyxFQUFDLEM7Ozs7O0FDQXJIO0FBQzNCO0FBQ0w7OztBQUd2RDtBQUM2RjtBQUM3RixnQkFBZ0IsOENBQVU7QUFDMUIsRUFBRSwyQ0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSx5RiIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdmaWVsZHNldCcsX3ZtLl9iKHtkaXJlY3RpdmVzOlt7bmFtZTpcImNsaWNrLW91dHNpZGVcIixyYXdOYW1lOlwidi1jbGljay1vdXRzaWRlXCIsdmFsdWU6KF92bS5jbG9zZSksZXhwcmVzc2lvbjpcImNsb3NlXCJ9XSxjbGFzczp7IHNob3c6IF92bS52aXNpYmxlIH19LCdmaWVsZHNldCcsX3ZtLiRhdHRycyxmYWxzZSksW19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19jb250ZW50IG11bHRpZmlsdGVyX19jb250ZW50X2Ryb3Bkb3duXCIsYXR0cnM6e1widHlwZVwiOlwiYnV0dG9uXCJ9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLnRvZ2dsZSgkZXZlbnQpfX19LFtfdm0uX3QoXCJidG5cIildLDIpLF92bS5fdihcIiBcIiksX3ZtLl90KFwiZGVmYXVsdFwiKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtyZWY6XCJtZW51XCIsc3RhdGljQ2xhc3M6XCJkcm9wZG93bi1tZW51XCIsY2xhc3M6eyBzaG93OiBfdm0udmlzaWJsZSB9fSxbX3ZtLl90KFwiYm9keVwiKV0sMildLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxmaWVsZHNldFxuICAgIHYtY2xpY2stb3V0c2lkZT1cImNsb3NlXCJcbiAgICA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiXG4gICAgdi1iaW5kPVwiJGF0dHJzXCJcbiAgPlxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2NvbnRlbnQgbXVsdGlmaWx0ZXJfX2NvbnRlbnRfZHJvcGRvd25cIlxuICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICBAY2xpY2sucHJldmVudD1cInRvZ2dsZVwiXG4gICAgPlxuICAgICAgPHNsb3QgbmFtZT1cImJ0blwiIC8+XG4gICAgPC9idXR0b24+XG5cbiAgICA8c2xvdCAvPlxuXG4gICAgPGRpdlxuICAgICAgcmVmPVwibWVudVwiXG4gICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIlxuICAgICAgOmNsYXNzPVwieyBzaG93OiB2aXNpYmxlIH1cIlxuICAgID5cbiAgICAgIDxzbG90IG5hbWU9XCJib2R5XCIgLz5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gICAgPHNpbXBsZWJhciBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIiA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiIGRhdGEtc2ltcGxlYmFyLWF1dG8taGlkZT1cImZhbHNlXCI+LS0+XG4gICAgPCEtLSAgICAgIDxzbG90IG5hbWU9XCJib2R5XCI+PC9zbG90Pi0tPlxuICAgIDwhLS0gICAgPC9zaW1wbGViYXI+LS0+XG4gIDwvZmllbGRzZXQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IFNpbXBsZUJhciBmcm9tICdzaW1wbGViYXInO1xuLy8gaW1wb3J0IHNpbXBsZWJhciBmcm9tICdzaW1wbGViYXItdnVlJztcbi8vIGltcG9ydCAnc2ltcGxlYmFyL2Rpc3Qvc2ltcGxlYmFyLm1pbi5jc3MnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdNdWx0aWZpbHRlckRyb3Bkb3duJyxcbiAgLy8gY29tcG9uZW50czoge1xuICAvLyAgIHNpbXBsZWJhclxuICAvLyB9LFxuICBwcm9wczoge1xuICAgIHNjcm9sbGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgfTtcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICAvLyAkKHRoaXMuJGVsKS5vbignaGlkZGVuLmJzLmRyb3Bkb3duJywgKCkgPT4ge1xuICAgIC8vICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgLy8gfSk7XG4gICAgLy8gJCh0aGlzLiRlbCkub24oJ3Nob3duLmJzLmRyb3Bkb3duJywgKCkgPT4ge1xuICAgIC8vICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAvLyB9KTtcblxuICAgIGlmICh0aGlzLnNjcm9sbGVkKSB7XG4gICAgICBuZXcgU2ltcGxlQmFyKHRoaXMuJHJlZnMubWVudSwgeyBhdXRvSGlkZTogZmFsc2UgfSk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb3BlbigpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgdG9nZ2xlKCkge1xuICAgICAgdGhpcy52aXNpYmxlID0gIXRoaXMudmlzaWJsZTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Ecm9wZG93bi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRHJvcGRvd24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Ecm9wZG93bi52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Zjg2YzI0ZTImXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRHJvcGRvd24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9Ecm9wZG93bi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},19:function(module,exports,__webpack_require__){eval('var superPropBase = __webpack_require__(59);\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== "undefined" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQuanM/ODk2MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IsbUJBQU8sQ0FBQyxFQUFpQjs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzdXBlclByb3BCYXNlID0gcmVxdWlyZShcIi4vc3VwZXJQcm9wQmFzZVwiKTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBSZWZsZWN0LmdldDtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IHN1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG5cbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n')},22:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterCheckbox.vue?vue&type=template&id=baf1eeb4&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('dropdown',{staticClass:\"multifilter\",class:{ active: _vm.checkedItems.length },attrs:{\"scrolled\":true,\"disabled\":_vm.items.length === 0}},[_c('template',{slot:\"btn\"},[(_vm.filter.replaceTitle)?_c('span',{staticClass:\"multifilter__label\"},[_vm._v(_vm._s(_vm.filter.label))]):_vm._e(),_vm._v(\" \"),(_vm.filter.replaceTitle)?_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(_vm.checkedTitle))]):_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(_vm.filter.label))]),_vm._v(\" \"),(_vm.checkedItems.length)?_c('span',{staticClass:\"multifilter__total\"},[_vm._v(_vm._s(_vm.checkedItems.length))]):_vm._e()]),_vm._v(\" \"),(_vm.checkedItems.length)?_c('button',{staticClass:\"multifilter__btn-clear\",attrs:{\"type\":\"reset\"},on:{\"click\":function($event){$event.preventDefault();return _vm.onReset(_vm.filter)}}},[_vm._v(\"\\n    Сбросить\\n  \")]):_vm._e(),_vm._v(\" \"),_c('template',{slot:\"body\"},[_c('MultifilterCheckboxList',{attrs:{\"items\":_vm.items},on:{\"change\":_vm.onChange}})],1)],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterCheckbox.vue?vue&type=template&id=baf1eeb4&\n\n// EXTERNAL MODULE: ./src/js/components/Dropdown.vue + 4 modules\nvar Dropdown = __webpack_require__(17);\n\n// EXTERNAL MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue + 9 modules\nvar MultifilterCheckboxList = __webpack_require__(25);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterCheckbox.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n// import { mapGetters, mapState, mapActions } from 'vuex'\n// import simplebar from 'simplebar-vue';\n// import 'simplebar/dist/simplebar.min.css';\n\n\n/* harmony default export */ var FilterCheckboxvue_type_script_lang_js_ = ({\n  name: 'Multifilter',\n  components: {\n    MultifilterCheckboxList: MultifilterCheckboxList[\"a\" /* default */],\n    Dropdown: Dropdown[\"a\" /* default */]\n  },\n  props: {\n    filter: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    items: function items() {\n      if (this.filter.parent) {\n        // TODO: Как-то поправить эту хуйню с обновлениием наследника при изменении родителя\n        var parent = typeof this.filter.parent === 'string' ? this.$store.state.filters.filters[this.filter.parent] : this.filter.parent;\n        var checkedParentItemIds = parent.data.filter(function (item) {\n          return item.checked;\n        }).map(function (item) {\n          return item.value;\n        }); // return this.filter.data.filter(item => checkedParentItemIds.includes(item.parent))\n\n        var t = this.filter.data.reduce(function (arr, item) {\n          if (checkedParentItemIds.includes(item.parent)) {\n            arr.push(item);\n          } else {\n            item.checked = false;\n          }\n\n          return arr;\n        }, []); // Срабатывает только тогда, когда изменился родитель\n        // Если меняется родитель, то действие вызывается до того, как обновился наследник и данные неверные.\n        // Поэтому вызываем еще раз\n        // Это все говна кусок, поэтому такой костыль\n        // this.$emit('change');\n\n        this.$store.dispatch('filters/onChange');\n        return t;\n      }\n\n      return this.filter.data;\n    },\n    checkedTitle: function checkedTitle() {\n      if (this.items.length === 0) {\n        return this.filter.labelDisabled;\n      }\n\n      if (this.checkedItems.length) {\n        return this.checkedItems.map(function (item) {\n          return item.label;\n        }).join(', ');\n      }\n\n      return this.filter.labelEmpty;\n    },\n    checkedItems: function checkedItems() {\n      return this.items.filter(function (item) {\n        return item.checked;\n      });\n    }\n  },\n  mounted: function mounted() {\n    this.$root.$on('filter:reset', this.reset);\n  },\n  methods: {\n    reset: function reset() {\n      this.filter.data.forEach(function (item) {\n        item.checked = false;\n      });\n    },\n    onReset: function onReset(filter) {\n      this.reset(); // this.$store.dispatch('filters/filterReset', { container: 'filters', name: filter.name, type: filter.type });\n\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    },\n    onChange: function onChange(e) {\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterCheckbox.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_FilterCheckboxvue_type_script_lang_js_ = (FilterCheckboxvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterCheckbox.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  catalog_FilterCheckboxvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var FilterCheckbox = __webpack_exports__[\"a\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlckNoZWNrYm94LnZ1ZT83NzU4Iiwid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlckNoZWNrYm94LnZ1ZT8zOTA5Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvRmlsdGVyQ2hlY2tib3gudnVlP2M3NDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJDaGVja2JveC52dWU/ZmIyZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBCQUEwQixhQUFhLDBCQUEwQix3QkFBd0Isc0JBQXNCLGlDQUFpQyxrQ0FBa0MsUUFBUSxtREFBbUQsaUJBQWlCLFdBQVcsdUNBQXVDLGlDQUFpQywrRkFBK0YsaUNBQWlDLGdEQUFnRCxpQ0FBaUMsc0ZBQXNGLGlDQUFpQywwR0FBMEcsNENBQTRDLGVBQWUsS0FBSyx5QkFBeUIsd0JBQXdCLGlDQUFpQyxxRUFBcUUsWUFBWSxnQ0FBZ0MsT0FBTyxrQkFBa0IsS0FBSyx1QkFBdUI7QUFDM2pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQSxxQkFEQTtBQUVBO0FBQ0EsdUVBREE7QUFFQTtBQUZBLEdBRkE7QUFNQTtBQUNBO0FBQ0Esa0JBREE7QUFFQTtBQUZBO0FBREEsR0FOQTtBQVlBO0FBQ0EsU0FEQSxtQkFDQTtBQUNBO0FBQ0E7QUFFQSw4REFDQSxxREFEQSxHQUVBLGtCQUZBO0FBSUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVBBLENBU0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FGQSxNQUVBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLFNBUEEsRUFPQSxFQVBBLEVBVkEsQ0FrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQSxLQTdCQTtBQThCQSxnQkE5QkEsMEJBOEJBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7O0FBQ0E7QUFDQSxLQXRDQTtBQXdDQSxnQkF4Q0EsMEJBd0NBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUExQ0EsR0FaQTtBQXdEQSxTQXhEQSxxQkF3REE7QUFDQTtBQUNBLEdBMURBO0FBMkRBO0FBQ0EsU0FEQSxtQkFDQTtBQUNBO0FBQ0E7QUFDQSxPQUZBO0FBR0EsS0FMQTtBQU1BLFdBTkEsbUJBTUEsTUFOQSxFQU1BO0FBQ0EsbUJBREEsQ0FFQTs7QUFDQTtBQUNBO0FBQ0EsS0FYQTtBQVlBLFlBWkEsb0JBWUEsQ0FaQSxFQVlBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUEzREEsRzs7QUNwRG9NLENBQWdCLHlIQUFHLEVBQUMsQzs7Ozs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBRzdEO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLDhDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLCtGIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Ryb3Bkb3duJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlclwiLGNsYXNzOnsgYWN0aXZlOiBfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCB9LGF0dHJzOntcInNjcm9sbGVkXCI6dHJ1ZSxcImRpc2FibGVkXCI6X3ZtLml0ZW1zLmxlbmd0aCA9PT0gMH19LFtfYygndGVtcGxhdGUnLHtzbG90OlwiYnRuXCJ9LFsoX3ZtLmZpbHRlci5yZXBsYWNlVGl0bGUpP19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fbGFiZWxcIn0sW192bS5fdihfdm0uX3MoX3ZtLmZpbHRlci5sYWJlbCkpXSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSwoX3ZtLmZpbHRlci5yZXBsYWNlVGl0bGUpP19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fdmFsdWVcIn0sW192bS5fdihfdm0uX3MoX3ZtLmNoZWNrZWRUaXRsZSkpXSk6X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX192YWx1ZVwifSxbX3ZtLl92KF92bS5fcyhfdm0uZmlsdGVyLmxhYmVsKSldKSxfdm0uX3YoXCIgXCIpLChfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCk/X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX190b3RhbFwifSxbX3ZtLl92KF92bS5fcyhfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCkpXSk6X3ZtLl9lKCldKSxfdm0uX3YoXCIgXCIpLChfdm0uY2hlY2tlZEl0ZW1zLmxlbmd0aCk/X2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX2J0bi1jbGVhclwiLGF0dHJzOntcInR5cGVcIjpcInJlc2V0XCJ9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLm9uUmVzZXQoX3ZtLmZpbHRlcil9fX0sW192bS5fdihcIlxcbiAgICDQodCx0YDQvtGB0LjRgtGMXFxuICBcIildKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLF9jKCd0ZW1wbGF0ZScse3Nsb3Q6XCJib2R5XCJ9LFtfYygnTXVsdGlmaWx0ZXJDaGVja2JveExpc3QnLHthdHRyczp7XCJpdGVtc1wiOl92bS5pdGVtc30sb246e1wiY2hhbmdlXCI6X3ZtLm9uQ2hhbmdlfX0pXSwxKV0sMil9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPGRyb3Bkb3duXG4gICAgY2xhc3M9XCJtdWx0aWZpbHRlclwiXG4gICAgOnNjcm9sbGVkPVwidHJ1ZVwiXG4gICAgOmNsYXNzPVwieyBhY3RpdmU6IGNoZWNrZWRJdGVtcy5sZW5ndGggfVwiXG4gICAgOmRpc2FibGVkPVwiaXRlbXMubGVuZ3RoID09PSAwXCJcbiAgPlxuICAgIDx0ZW1wbGF0ZSBzbG90PVwiYnRuXCI+XG4gICAgICA8c3BhblxuICAgICAgICB2LWlmPVwiZmlsdGVyLnJlcGxhY2VUaXRsZVwiXG4gICAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2xhYmVsXCJcbiAgICAgID57eyBmaWx0ZXIubGFiZWwgfX08L3NwYW4+XG4gICAgICA8c3BhblxuICAgICAgICB2LWlmPVwiZmlsdGVyLnJlcGxhY2VUaXRsZVwiXG4gICAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX3ZhbHVlXCJcbiAgICAgID57eyBjaGVja2VkVGl0bGUgfX08L3NwYW4+XG4gICAgICA8c3BhblxuICAgICAgICB2LWVsc2VcbiAgICAgICAgY2xhc3M9XCJtdWx0aWZpbHRlcl9fdmFsdWVcIlxuICAgICAgPnt7IGZpbHRlci5sYWJlbCB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuXG4gICAgICAgIHYtaWY9XCJjaGVja2VkSXRlbXMubGVuZ3RoXCJcbiAgICAgICAgY2xhc3M9XCJtdWx0aWZpbHRlcl9fdG90YWxcIlxuICAgICAgPnt7IGNoZWNrZWRJdGVtcy5sZW5ndGggfX08L3NwYW4+XG4gICAgPC90ZW1wbGF0ZT5cblxuICAgIDxidXR0b25cbiAgICAgIHYtaWY9XCJjaGVja2VkSXRlbXMubGVuZ3RoXCJcbiAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2J0bi1jbGVhclwiXG4gICAgICB0eXBlPVwicmVzZXRcIlxuICAgICAgQGNsaWNrLnByZXZlbnQ9XCJvblJlc2V0KGZpbHRlcilcIlxuICAgID5cbiAgICAgINCh0LHRgNC+0YHQuNGC0YxcbiAgICA8L2J1dHRvbj5cblxuICAgIDx0ZW1wbGF0ZSBzbG90PVwiYm9keVwiPlxuICAgICAgPE11bHRpZmlsdGVyQ2hlY2tib3hMaXN0XG4gICAgICAgIDppdGVtcz1cIml0ZW1zXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgICAgIC8+XG4gICAgPC90ZW1wbGF0ZT5cbiAgPC9kcm9wZG93bj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4vLyBpbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwQWN0aW9ucyB9IGZyb20gJ3Z1ZXgnXG4vLyBpbXBvcnQgc2ltcGxlYmFyIGZyb20gJ3NpbXBsZWJhci12dWUnO1xuLy8gaW1wb3J0ICdzaW1wbGViYXIvZGlzdC9zaW1wbGViYXIubWluLmNzcyc7XG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi4vRHJvcGRvd24udnVlJztcbmltcG9ydCBNdWx0aWZpbHRlckNoZWNrYm94TGlzdCBmcm9tICcuL011bHRpZmlsdGVyQ2hlY2tib3hMaXN0LnZ1ZSc7XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnTXVsdGlmaWx0ZXInLFxuICBjb21wb25lbnRzOiB7XG4gICAgTXVsdGlmaWx0ZXJDaGVja2JveExpc3QsXG4gICAgRHJvcGRvd24sXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgZmlsdGVyOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB9LFxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1zKCkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyLnBhcmVudCkge1xuICAgICAgICAvLyBUT0RPOiDQmtCw0Lot0YLQviDQv9C+0L/RgNCw0LLQuNGC0Ywg0Y3RgtGDINGF0YPQudC90Y4g0YEg0L7QsdC90L7QstC70LXQvdC40LjQtdC8INC90LDRgdC70LXQtNC90LjQutCwINC/0YDQuCDQuNC30LzQtdC90LXQvdC40Lgg0YDQvtC00LjRgtC10LvRj1xuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9ICh0eXBlb2YgdGhpcy5maWx0ZXIucGFyZW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgICA/IHRoaXMuJHN0b3JlLnN0YXRlLmZpbHRlcnMuZmlsdGVyc1t0aGlzLmZpbHRlci5wYXJlbnRdXG4gICAgICAgICAgOiB0aGlzLmZpbHRlci5wYXJlbnQ7XG5cbiAgICAgICAgY29uc3QgY2hlY2tlZFBhcmVudEl0ZW1JZHMgPSBwYXJlbnQuZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGlzLmZpbHRlci5kYXRhLmZpbHRlcihpdGVtID0+IGNoZWNrZWRQYXJlbnRJdGVtSWRzLmluY2x1ZGVzKGl0ZW0ucGFyZW50KSlcbiAgICAgICAgY29uc3QgdCA9IHRoaXMuZmlsdGVyLmRhdGEucmVkdWNlKChhcnIsIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoY2hlY2tlZFBhcmVudEl0ZW1JZHMuaW5jbHVkZXMoaXRlbS5wYXJlbnQpKSB7XG4gICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgLy8g0KHRgNCw0LHQsNGC0YvQstCw0LXRgiDRgtC+0LvRjNC60L4g0YLQvtCz0LTQsCwg0LrQvtCz0LTQsCDQuNC30LzQtdC90LjQu9GB0Y8g0YDQvtC00LjRgtC10LvRjFxuICAgICAgICAvLyDQldGB0LvQuCDQvNC10L3Rj9C10YLRgdGPINGA0L7QtNC40YLQtdC70YwsINGC0L4g0LTQtdC50YHRgtCy0LjQtSDQstGL0LfRi9Cy0LDQtdGC0YHRjyDQtNC+INGC0L7Qs9C+LCDQutCw0Log0L7QsdC90L7QstC40LvRgdGPINC90LDRgdC70LXQtNC90LjQuiDQuCDQtNCw0L3QvdGL0LUg0L3QtdCy0LXRgNC90YvQtS5cbiAgICAgICAgLy8g0J/QvtGN0YLQvtC80YMg0LLRi9C30YvQstCw0LXQvCDQtdGJ0LUg0YDQsNC3XG4gICAgICAgIC8vINCt0YLQviDQstGB0LUg0LPQvtCy0L3QsCDQutGD0YHQvtC6LCDQv9C+0Y3RgtC+0LzRgyDRgtCw0LrQvtC5INC60L7RgdGC0YvQu9GMXG4gICAgICAgIC8vIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScpO1xuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbHRlci5kYXRhO1xuICAgIH0sXG4gICAgY2hlY2tlZFRpdGxlKCkge1xuICAgICAgaWYgKHRoaXMuaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5sYWJlbERpc2FibGVkO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2hlY2tlZEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja2VkSXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5sYWJlbCkuam9pbignLCAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbHRlci5sYWJlbEVtcHR5O1xuICAgIH0sXG5cbiAgICBjaGVja2VkSXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpO1xuICAgIH0sXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy4kcm9vdC4kb24oJ2ZpbHRlcjpyZXNldCcsIHRoaXMucmVzZXQpO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcmVzZXQoKSB7XG4gICAgICB0aGlzLmZpbHRlci5kYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaXRlbS5jaGVja2VkID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uUmVzZXQoZmlsdGVyKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAvLyB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9maWx0ZXJSZXNldCcsIHsgY29udGFpbmVyOiAnZmlsdGVycycsIG5hbWU6IGZpbHRlci5uYW1lLCB0eXBlOiBmaWx0ZXIudHlwZSB9KTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICB9LFxuICAgIG9uQ2hhbmdlKGUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuXG48IS0tPHN0eWxlIHNjb3BlZD4tLT5cblxuPCEtLTwvc3R5bGU+LS0+XG4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0ZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9GaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0ZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1iYWYxZWViNCZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9GaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0ZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n")},23:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterSelect.vue?vue&type=template&id=b5db7e18&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'fieldset\',{directives:[{name:"click-outside",rawName:"v-click-outside",value:(_vm.close),expression:"close"}],staticClass:"multifilter",class:{ show: _vm.visible }},[_c(\'button\',{staticClass:"multifilter__content multifilter__content_dropdown",attrs:{"type":"button"},on:{"click":function($event){$event.preventDefault();return _vm.toggle($event)}}},[_c(\'span\',{staticClass:"multifilter__value"},[_vm._v(_vm._s(_vm.filter.label))])]),_vm._v(" "),_c(\'div\',{staticClass:"dropdown-menu",class:{ show: _vm.visible }},_vm._l((_vm.filter.data),function(item){return _c(\'label\',{staticClass:"multifilter-radio"},[_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.filter.selected),expression:"filter.selected"}],staticClass:"multifilter-radio__input",attrs:{"type":"radio","name":item.name},domProps:{"value":item.value,"checked":_vm._q(_vm.filter.selected,item.value)},on:{"change":[function($event){return _vm.$set(_vm.filter, "selected", item.value)},function($event){return _vm.onChange(item)}]}}),_vm._v(" "),_c(\'span\',{staticClass:"multifilter-radio__label"},[_vm._v(_vm._s(item.label))])])}),0)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterSelect.vue?vue&type=template&id=b5db7e18&scoped=true&\n\n// EXTERNAL MODULE: ./src/js/components/Dropdown.vue + 4 modules\nvar Dropdown = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterSelect.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var FilterSelectvue_type_script_lang_js_ = ({\n  name: "FilterSelect",\n  components: {\n    Dropdown: Dropdown["a" /* default */]\n  },\n  props: {\n    filter: Object\n  },\n  data: function data() {\n    return {\n      visible: false\n    };\n  },\n  methods: {\n    onChange: function onChange(item) {\n      this.filter.label = item.label;\n      this.$store.dispatch(\'filters/onChange\');\n      this.close();\n    },\n    open: function open() {\n      this.visible = true;\n    },\n    close: function close() {\n      this.visible = false;\n    },\n    toggle: function toggle() {\n      this.visible = !this.visible;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterSelect.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_FilterSelectvue_type_script_lang_js_ = (FilterSelectvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterSelect.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  catalog_FilterSelectvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "b5db7e18",\n  null\n  \n)\n\n/* harmony default export */ var FilterSelect = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlclNlbGVjdC52dWU/M2QyNSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlP2JjNjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlP2UxZmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJTZWxlY3QudnVlPzBhNmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLHNCQUFzQixhQUFhLG9GQUFvRixtQ0FBbUMscUJBQXFCLGVBQWUsd0VBQXdFLGdCQUFnQixLQUFLLHlCQUF5Qix3QkFBd0IsNEJBQTRCLGFBQWEsaUNBQWlDLDZEQUE2RCxtQ0FBbUMscUJBQXFCLHlDQUF5QyxtQkFBbUIsZ0NBQWdDLGNBQWMsYUFBYSx3RkFBd0YsZ0RBQWdELGdDQUFnQyxXQUFXLG9FQUFvRSxLQUFLLDJCQUEyQixvREFBb0Qsa0JBQWtCLDBCQUEwQixHQUFHLHlCQUF5Qix1Q0FBdUMsaUNBQWlDO0FBQ3RyQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3lCQTtBQUdBO0FBQ0Esc0JBREE7QUFFQTtBQUFBO0FBQUEsR0FGQTtBQUdBO0FBQ0E7QUFEQSxHQUhBO0FBTUEsTUFOQSxrQkFNQTtBQUNBO0FBQ0E7QUFEQTtBQUdBLEdBVkE7QUFXQTtBQUNBLFlBREEsb0JBQ0EsSUFEQSxFQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EsS0FOQTtBQVFBLFFBUkEsa0JBUUE7QUFDQTtBQUNBLEtBVkE7QUFXQSxTQVhBLG1CQVdBO0FBQ0E7QUFDQSxLQWJBO0FBY0EsVUFkQSxvQkFjQTtBQUNBO0FBQ0E7QUFoQkE7QUFYQSxHOztBQzdCa00sQ0FBZ0IscUhBQUcsRUFBQyxDOzs7OztBQ0EvRztBQUN2QztBQUNMOzs7QUFHM0Q7QUFDZ0c7QUFDaEcsZ0JBQWdCLDhDQUFVO0FBQzFCLEVBQUUsNENBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsNkYiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZmllbGRzZXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcImNsaWNrLW91dHNpZGVcIixyYXdOYW1lOlwidi1jbGljay1vdXRzaWRlXCIsdmFsdWU6KF92bS5jbG9zZSksZXhwcmVzc2lvbjpcImNsb3NlXCJ9XSxzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyXCIsY2xhc3M6eyBzaG93OiBfdm0udmlzaWJsZSB9fSxbX2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX2NvbnRlbnQgbXVsdGlmaWx0ZXJfX2NvbnRlbnRfZHJvcGRvd25cIixhdHRyczp7XCJ0eXBlXCI6XCJidXR0b25cIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpeyRldmVudC5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBfdm0udG9nZ2xlKCRldmVudCl9fX0sW19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fdmFsdWVcIn0sW192bS5fdihfdm0uX3MoX3ZtLmZpbHRlci5sYWJlbCkpXSldKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImRyb3Bkb3duLW1lbnVcIixjbGFzczp7IHNob3c6IF92bS52aXNpYmxlIH19LF92bS5fbCgoX3ZtLmZpbHRlci5kYXRhKSxmdW5jdGlvbihpdGVtKXtyZXR1cm4gX2MoJ2xhYmVsJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1yYWRpb1wifSxbX2MoJ2lucHV0Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5maWx0ZXIuc2VsZWN0ZWQpLGV4cHJlc3Npb246XCJmaWx0ZXIuc2VsZWN0ZWRcIn1dLHN0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcmFkaW9fX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwicmFkaW9cIixcIm5hbWVcIjppdGVtLm5hbWV9LGRvbVByb3BzOntcInZhbHVlXCI6aXRlbS52YWx1ZSxcImNoZWNrZWRcIjpfdm0uX3EoX3ZtLmZpbHRlci5zZWxlY3RlZCxpdGVtLnZhbHVlKX0sb246e1wiY2hhbmdlXCI6W2Z1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS4kc2V0KF92bS5maWx0ZXIsIFwic2VsZWN0ZWRcIiwgaXRlbS52YWx1ZSl9LGZ1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS5vbkNoYW5nZShpdGVtKX1dfX0pLF92bS5fdihcIiBcIiksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXJhZGlvX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhpdGVtLmxhYmVsKSldKV0pfSksMCldKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8ZmllbGRzZXQgY2xhc3M9XCJtdWx0aWZpbHRlclwiXG4gICAgICAgICAgICA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiXG4gICAgICAgICAgICB2LWNsaWNrLW91dHNpZGU9XCJjbG9zZVwiPlxuICAgIDxidXR0b24gY2xhc3M9XCJtdWx0aWZpbHRlcl9fY29udGVudCBtdWx0aWZpbHRlcl9fY29udGVudF9kcm9wZG93blwiXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIEBjbGljay5wcmV2ZW50PVwidG9nZ2xlXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm11bHRpZmlsdGVyX192YWx1ZVwiPnt7IGZpbHRlci5sYWJlbCB9fTwvc3Bhbj5cbiAgICA8L2J1dHRvbj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiXG4gICAgICAgICA6Y2xhc3M9XCJ7IHNob3c6IHZpc2libGUgfVwiPlxuICAgICAgPGxhYmVsIGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9cIiB2LWZvcj1cIml0ZW0gaW4gZmlsdGVyLmRhdGFcIj5cbiAgICAgICAgPGlucHV0IGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9fX2lucHV0XCJcbiAgICAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICA6bmFtZT1cIml0ZW0ubmFtZVwiXG4gICAgICAgICAgICAgICA6dmFsdWU9XCJpdGVtLnZhbHVlXCJcbiAgICAgICAgICAgICAgIHYtbW9kZWw9XCJmaWx0ZXIuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlKGl0ZW0pXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9fX2xhYmVsXCI+e3sgaXRlbS5sYWJlbCB9fTwvc3Bhbj5cbiAgICAgIDwvbGFiZWw+XG4gICAgPC9kaXY+XG4gIDwvZmllbGRzZXQ+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgRHJvcGRvd24gZnJvbSAnLi8uLi9Ecm9wZG93bi52dWUnO1xuXG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiRmlsdGVyU2VsZWN0XCIsXG4gICAgY29tcG9uZW50czogeyBEcm9wZG93biB9LFxuICAgIHByb3BzOiB7XG4gICAgICBmaWx0ZXI6IE9iamVjdCxcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIG9uQ2hhbmdlKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5maWx0ZXIubGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSxcblxuICAgICAgb3BlbigpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICAgICAgfVxuICAgIH0sXG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9GaWx0ZXJTZWxlY3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0ZpbHRlclNlbGVjdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0ZpbHRlclNlbGVjdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9YjVkYjdlMTgmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRmlsdGVyU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vRmlsdGVyU2VsZWN0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiYjVkYjdlMThcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')},24:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterPrice.vue?vue&type=template&id=17759026&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'dropdown\',{staticClass:"multifilter"},[_c(\'template\',{slot:"btn"},[_c(\'span\',{staticClass:"multifilter__value"},[_vm._v(_vm._s(_vm.filter.label))])]),_vm._v(" "),_c(\'template\',{slot:"body"},[_c(\'MultifilterPrice\',{attrs:{"slider":_vm.filter.data},on:{"change":_vm.onChange,"update":_vm.onUpdate}})],1)],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterPrice.vue?vue&type=template&id=17759026&scoped=true&\n\n// EXTERNAL MODULE: ./src/js/components/catalog/MultifilterPrice.vue + 4 modules\nvar MultifilterPrice = __webpack_require__(26);\n\n// EXTERNAL MODULE: ./src/js/components/Dropdown.vue + 4 modules\nvar Dropdown = __webpack_require__(17);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/FilterPrice.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ var FilterPricevue_type_script_lang_js_ = ({\n  name: \'FilterPrice\',\n  components: {\n    Dropdown: Dropdown["a" /* default */],\n    MultifilterPrice: MultifilterPrice["a" /* default */]\n  },\n  props: {\n    filter: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: {\n    onChange: function onChange() {\n      this.$store.dispatch(\'filters/onChange\');\n    },\n    onUpdate: function onUpdate(values) {\n      // console.log(e);\n      this.filter.data.minRange = values[0];\n      this.filter.data.maxRange = values[1];\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterPrice.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_FilterPricevue_type_script_lang_js_ = (FilterPricevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/FilterPrice.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  catalog_FilterPricevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "17759026",\n  null\n  \n)\n\n/* harmony default export */ var FilterPrice = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlclByaWNlLnZ1ZT81YmRiIiwid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL0ZpbHRlclByaWNlLnZ1ZT84NjM1Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvRmlsdGVyUHJpY2UudnVlP2Y4YWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9GaWx0ZXJQcmljZS52dWU/ZDVkYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBCQUEwQixhQUFhLDBCQUEwQix3QkFBd0Isc0JBQXNCLDBCQUEwQixpQkFBaUIsV0FBVyxhQUFhLGlDQUFpQyxrRUFBa0UsWUFBWSx5QkFBeUIsT0FBTyx5QkFBeUIsS0FBSyw2Q0FBNkM7QUFDNVk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNnQkE7QUFDQTtBQUdBO0FBQ0EscUJBREE7QUFFQTtBQUNBLHlDQURBO0FBRUE7QUFGQSxHQUZBO0FBTUE7QUFDQTtBQUNBLGtCQURBO0FBRUE7QUFGQTtBQURBLEdBTkE7QUFZQTtBQUNBLFlBREEsc0JBQ0E7QUFDQTtBQUNBLEtBSEE7QUFJQSxZQUpBLG9CQUlBLE1BSkEsRUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFaQSxHOztBQ3JCaU0sQ0FBZ0IsbUhBQUcsRUFBQyxDOzs7OztBQ0EvRztBQUN2QztBQUNMOzs7QUFHMUQ7QUFDZ0c7QUFDaEcsZ0JBQWdCLDhDQUFVO0FBQzFCLEVBQUUsMkNBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsNEYiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZHJvcGRvd24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyXCJ9LFtfYygndGVtcGxhdGUnLHtzbG90OlwiYnRuXCJ9LFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX3ZhbHVlXCJ9LFtfdm0uX3YoX3ZtLl9zKF92bS5maWx0ZXIubGFiZWwpKV0pXSksX3ZtLl92KFwiIFwiKSxfYygndGVtcGxhdGUnLHtzbG90OlwiYm9keVwifSxbX2MoJ011bHRpZmlsdGVyUHJpY2UnLHthdHRyczp7XCJzbGlkZXJcIjpfdm0uZmlsdGVyLmRhdGF9LG9uOntcImNoYW5nZVwiOl92bS5vbkNoYW5nZSxcInVwZGF0ZVwiOl92bS5vblVwZGF0ZX19KV0sMSldLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxkcm9wZG93biBjbGFzcz1cIm11bHRpZmlsdGVyXCI+XG4gICAgPHRlbXBsYXRlIHNsb3Q9XCJidG5cIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXJfX3ZhbHVlXCI+e3sgZmlsdGVyLmxhYmVsIH19PC9zcGFuPlxuICAgIDwvdGVtcGxhdGU+XG5cbiAgICA8dGVtcGxhdGUgc2xvdD1cImJvZHlcIj5cbiAgICAgIDxNdWx0aWZpbHRlclByaWNlXG4gICAgICAgIDpzbGlkZXI9XCJmaWx0ZXIuZGF0YVwiXG4gICAgICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXG4gICAgICAgIEB1cGRhdGU9XCJvblVwZGF0ZVwiXG4gICAgICAvPlxuICAgIDwvdGVtcGxhdGU+XG4gIDwvZHJvcGRvd24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE11bHRpZmlsdGVyUHJpY2UgZnJvbSAnLi9NdWx0aWZpbHRlclByaWNlLnZ1ZSc7XG5pbXBvcnQgRHJvcGRvd24gZnJvbSAnLi4vRHJvcGRvd24udnVlJztcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdGaWx0ZXJQcmljZScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBEcm9wZG93bixcbiAgICBNdWx0aWZpbHRlclByaWNlLFxuICB9LFxuICBwcm9wczoge1xuICAgIGZpbHRlcjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgfSxcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICB9LFxuICAgIG9uVXBkYXRlKHZhbHVlcykge1xuICAgICAgLy8gY29uc29sZS5sb2coZSk7XG4gICAgICB0aGlzLmZpbHRlci5kYXRhLm1pblJhbmdlID0gdmFsdWVzWzBdO1xuICAgICAgdGhpcy5maWx0ZXIuZGF0YS5tYXhSYW5nZSA9IHZhbHVlc1sxXTtcbiAgICB9LFxuICB9LFxufTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9GaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vRmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9GaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MTc3NTkwMjYmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9GaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjE3NzU5MDI2XCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n')},25:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=template&id=92617c6c&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"multifilter-checkbox-list"},[(_vm.search && _vm.items.length > 9)?_c(\'div\',{staticClass:"multifilter-search"},[_c(\'input\',{directives:[{name:"model",rawName:"v-model",value:(_vm.searchQuery),expression:"searchQuery"}],staticClass:"multifilter-search__input",attrs:{"type":"search","placeholder":"Поиск","autocomplete":"off"},domProps:{"value":(_vm.searchQuery)},on:{"input":function($event){if($event.target.composing){ return; }_vm.searchQuery=$event.target.value}}})]):_vm._e(),_vm._v(" "),_vm._l((_vm.availableItems),function(item){return _c(\'MultifilterCheckbox\',{directives:[{name:"show",rawName:"v-show",value:(!item.hidden),expression:"!item.hidden"}],key:item.input.id,attrs:{"name":item.input.name,"disabled":false,"value":item.input.value},on:{"change":function($event){return _vm.$emit(\'change\', item.input)}},model:{value:(item.input.checked),callback:function ($$v) {_vm.$set(item.input, "checked", $$v)},expression:"item.input.checked"}},[_vm._v(_vm._s(item.input.label)+"\\n  ")])}),_vm._v(" "),(_vm.visibleNotAvailableItems.length)?_c(\'div\',{staticClass:"multifilter-delimiter"},[_c(\'span\',{staticClass:"multifilter-delimiter__text"},[_vm._v("Нет в наличии")])]):_vm._e(),_vm._v(" "),_vm._l((_vm.notAvailableItems),function(item){return _c(\'MultifilterCheckbox\',{directives:[{name:"show",rawName:"v-show",value:(!item.hidden),expression:"!item.hidden"}],key:item.input.id,attrs:{"name":item.input.name,"disabled":!item.input.checked,"value":item.input.value},on:{"change":function($event){return _vm.$emit(\'change\', item.input)}},model:{value:(item.input.checked),callback:function ($$v) {_vm.$set(item.input, "checked", $$v)},expression:"item.input.checked"}},[_vm._v(_vm._s(item.input.label)+"\\n  ")])})],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=template&id=92617c6c&\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=template&id=2173bc26&\nvar MultifilterCheckboxvue_type_template_id_2173bc26_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'label\',{staticClass:"multifilter-checkbox"},[_c(\'input\',_vm._b({staticClass:"multifilter-checkbox__input",attrs:{"type":"checkbox"},domProps:{"checked":_vm.checked},on:{"change":function($event){return _vm.$emit(\'change\', $event.target.checked)}}},\'input\',_vm.$attrs,false)),_vm._v(" "),_c(\'span\',{staticClass:"multifilter-checkbox__label"},[_vm._t("default")],2)])}\nvar MultifilterCheckboxvue_type_template_id_2173bc26_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=template&id=2173bc26&\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var MultifilterCheckboxvue_type_script_lang_js_ = ({\n  name: "MultifilterCheckbox",\n  inheritAttrs: false,\n  model: {\n    prop: \'checked\',\n    event: \'change\'\n  },\n  props: {\n    checked: {\n      default: false,\n      type: Boolean\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckbox.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_MultifilterCheckboxvue_type_script_lang_js_ = (MultifilterCheckboxvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckbox.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  catalog_MultifilterCheckboxvue_type_script_lang_js_,\n  MultifilterCheckboxvue_type_template_id_2173bc26_render,\n  MultifilterCheckboxvue_type_template_id_2173bc26_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var MultifilterCheckbox = (component.exports);\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n// import { mapGetters, mapState, mapActions } from \'vuex\'\n\n/* harmony default export */ var MultifilterCheckboxListvue_type_script_lang_js_ = ({\n  name: "MultifilterCheckboxList",\n  props: {\n    items: {\n      type: Array,\n      required: true\n    },\n    search: {\n      type: Boolean,\n      default: true\n    }\n  },\n  components: {\n    MultifilterCheckbox: MultifilterCheckbox\n  },\n  data: function data() {\n    return {\n      searchQuery: \'\'\n    };\n  },\n  computed: {\n    filtredItems: function filtredItems() {\n      var _this = this;\n\n      return this.items.map(function (item) {\n        return {\n          // ...item,\n          input: item,\n          hidden: item.hidden || _this.searchQuery && item.label.toLowerCase().indexOf(_this.searchQuery.toLowerCase()) === -1\n        };\n      });\n    },\n    availableItems: function availableItems() {\n      return this.filtredItems.filter(function (item) {\n        return item.input.available;\n      });\n    },\n    notAvailableItems: function notAvailableItems() {\n      return this.filtredItems.filter(function (item) {\n        return !item.input.available;\n      });\n    },\n    visibleNotAvailableItems: function visibleNotAvailableItems() {\n      return this.notAvailableItems.filter(function (item) {\n        return !item.hidden;\n      });\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_MultifilterCheckboxListvue_type_script_lang_js_ = (MultifilterCheckboxListvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue\n\n\n\n\n\n/* normalize component */\n\nvar MultifilterCheckboxList_component = Object(componentNormalizer["a" /* default */])(\n  catalog_MultifilterCheckboxListvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var MultifilterCheckboxList = __webpack_exports__["a"] = (MultifilterCheckboxList_component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyQ2hlY2tib3hMaXN0LnZ1ZT8yNzI3Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/MWM2YyIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9NdWx0aWZpbHRlckNoZWNrYm94LnZ1ZT84MGMzIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/OWY5ZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyQ2hlY2tib3gudnVlPzYwOTkiLCJ3ZWJwYWNrOi8vL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJDaGVja2JveExpc3QudnVlP2FiZmMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/NjFlNyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyQ2hlY2tib3hMaXN0LnZ1ZT8zYmYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsd0NBQXdDLGlEQUFpRCxpQ0FBaUMsY0FBYyxhQUFhLGdGQUFnRixpREFBaUQsMkRBQTJELFdBQVcsMEJBQTBCLEtBQUsseUJBQXlCLDRCQUE0QixRQUFRLEVBQUUsc0NBQXNDLG9FQUFvRSxpQ0FBaUMsYUFBYSw0RUFBNEUsMkJBQTJCLGlFQUFpRSxLQUFLLDBCQUEwQix3Q0FBd0MsUUFBUSxvREFBb0QscUNBQXFDLGtDQUFrQyw0Q0FBNEMsOERBQThELG9DQUFvQyxhQUFhLDBDQUEwQyxpR0FBaUcsaUNBQWlDLGFBQWEsNEVBQTRFLDJCQUEyQiwrRUFBK0UsS0FBSywwQkFBMEIsd0NBQXdDLFFBQVEsb0RBQW9ELHFDQUFxQyxrQ0FBa0MsNENBQTRDO0FBQzl5RDs7Ozs7O0FDREEsSUFBSSx1REFBTSxnQkFBZ0IsYUFBYSwwQkFBMEIsd0JBQXdCLG1CQUFtQixtQ0FBbUMscUJBQXFCLGlEQUFpRCxrQkFBa0IsV0FBVyxzQkFBc0IsS0FBSywwQkFBMEIsb0RBQW9ELG1EQUFtRCwwQ0FBMEM7QUFDeGIsSUFBSSxnRUFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNXbkI7QUFDQSw2QkFEQTtBQUVBLHFCQUZBO0FBR0E7QUFDQSxtQkFEQTtBQUVBO0FBRkEsR0FIQTtBQU9BO0FBQ0E7QUFDQSxvQkFEQTtBQUVBO0FBRkE7QUFEQTtBQVBBLEc7O0FDWnlNLENBQWdCLG1JQUFHLEVBQUMsQzs7Ozs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBR2xFO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLG1EQUFNO0FBQ1IsRUFBRSx1REFBTTtBQUNSLEVBQUUsZ0VBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUseUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNrQmY7QUFDQTtBQUdBO0FBQ0EsaUNBREE7QUFFQTtBQUNBO0FBQ0EsaUJBREE7QUFFQTtBQUZBLEtBREE7QUFLQTtBQUNBLG1CQURBO0FBRUE7QUFGQTtBQUxBLEdBRkE7QUFZQTtBQUNBO0FBREEsR0FaQTtBQWVBLE1BZkEsa0JBZUE7QUFDQTtBQUNBO0FBREE7QUFHQSxHQW5CQTtBQW9CQTtBQUNBLGdCQURBLDBCQUNBO0FBQUE7O0FBQ0E7QUFBQTtBQUNBO0FBQ0EscUJBRkE7QUFHQSwrRUFDQSxPQURBLENBQ0EsK0JBREEsTUFDQTtBQUpBO0FBQUE7QUFNQSxLQVJBO0FBU0Esa0JBVEEsNEJBU0E7QUFDQTtBQUFBO0FBQUE7QUFDQSxLQVhBO0FBWUEscUJBWkEsK0JBWUE7QUFDQTtBQUFBO0FBQUE7QUFDQSxLQWRBO0FBZUEsNEJBZkEsc0NBZUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQWpCQTtBQXBCQSxHOztBQ3hDNk0sQ0FBZ0IsMklBQUcsRUFBQyxDOztBQ0EzSDtBQUMzQjtBQUNMOzs7QUFHdEU7QUFDZ0c7QUFDaEcsSUFBSSxpQ0FBUyxHQUFHLDhDQUFVO0FBQzFCLEVBQUUsdURBQU07QUFDUixFQUFFLE1BQU07QUFDUixFQUFFLGVBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsd0hBQVMsUSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLWNoZWNrYm94LWxpc3RcIn0sWyhfdm0uc2VhcmNoICYmIF92bS5pdGVtcy5sZW5ndGggPiA5KT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1zZWFyY2hcIn0sW19jKCdpbnB1dCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwibW9kZWxcIixyYXdOYW1lOlwidi1tb2RlbFwiLHZhbHVlOihfdm0uc2VhcmNoUXVlcnkpLGV4cHJlc3Npb246XCJzZWFyY2hRdWVyeVwifV0sc3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1zZWFyY2hfX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwic2VhcmNoXCIsXCJwbGFjZWhvbGRlclwiOlwi0J/QvtC40YHQulwiLFwiYXV0b2NvbXBsZXRlXCI6XCJvZmZcIn0sZG9tUHJvcHM6e1widmFsdWVcIjooX3ZtLnNlYXJjaFF1ZXJ5KX0sb246e1wiaW5wdXRcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXsgcmV0dXJuOyB9X3ZtLnNlYXJjaFF1ZXJ5PSRldmVudC50YXJnZXQudmFsdWV9fX0pXSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfdm0uX2woKF92bS5hdmFpbGFibGVJdGVtcyksZnVuY3Rpb24oaXRlbSl7cmV0dXJuIF9jKCdNdWx0aWZpbHRlckNoZWNrYm94Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOighaXRlbS5oaWRkZW4pLGV4cHJlc3Npb246XCIhaXRlbS5oaWRkZW5cIn1dLGtleTppdGVtLmlucHV0LmlkLGF0dHJzOntcIm5hbWVcIjppdGVtLmlucHV0Lm5hbWUsXCJkaXNhYmxlZFwiOmZhbHNlLFwidmFsdWVcIjppdGVtLmlucHV0LnZhbHVlfSxvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uJGVtaXQoJ2NoYW5nZScsIGl0ZW0uaW5wdXQpfX0sbW9kZWw6e3ZhbHVlOihpdGVtLmlucHV0LmNoZWNrZWQpLGNhbGxiYWNrOmZ1bmN0aW9uICgkJHYpIHtfdm0uJHNldChpdGVtLmlucHV0LCBcImNoZWNrZWRcIiwgJCR2KX0sZXhwcmVzc2lvbjpcIml0ZW0uaW5wdXQuY2hlY2tlZFwifX0sW192bS5fdihfdm0uX3MoaXRlbS5pbnB1dC5sYWJlbCkrXCJcXG4gIFwiKV0pfSksX3ZtLl92KFwiIFwiKSwoX3ZtLnZpc2libGVOb3RBdmFpbGFibGVJdGVtcy5sZW5ndGgpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLWRlbGltaXRlclwifSxbX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLWRlbGltaXRlcl9fdGV4dFwifSxbX3ZtLl92KFwi0J3QtdGCINCyINC90LDQu9C40YfQuNC4XCIpXSldKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLF92bS5fbCgoX3ZtLm5vdEF2YWlsYWJsZUl0ZW1zKSxmdW5jdGlvbihpdGVtKXtyZXR1cm4gX2MoJ011bHRpZmlsdGVyQ2hlY2tib3gnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KCFpdGVtLmhpZGRlbiksZXhwcmVzc2lvbjpcIiFpdGVtLmhpZGRlblwifV0sa2V5Oml0ZW0uaW5wdXQuaWQsYXR0cnM6e1wibmFtZVwiOml0ZW0uaW5wdXQubmFtZSxcImRpc2FibGVkXCI6IWl0ZW0uaW5wdXQuY2hlY2tlZCxcInZhbHVlXCI6aXRlbS5pbnB1dC52YWx1ZX0sb246e1wiY2hhbmdlXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLiRlbWl0KCdjaGFuZ2UnLCBpdGVtLmlucHV0KX19LG1vZGVsOnt2YWx1ZTooaXRlbS5pbnB1dC5jaGVja2VkKSxjYWxsYmFjazpmdW5jdGlvbiAoJCR2KSB7X3ZtLiRzZXQoaXRlbS5pbnB1dCwgXCJjaGVja2VkXCIsICQkdil9LGV4cHJlc3Npb246XCJpdGVtLmlucHV0LmNoZWNrZWRcIn19LFtfdm0uX3YoX3ZtLl9zKGl0ZW0uaW5wdXQubGFiZWwpK1wiXFxuICBcIildKX0pXSwyKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2xhYmVsJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1jaGVja2JveFwifSxbX2MoJ2lucHV0Jyxfdm0uX2Ioe3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwiY2hlY2tib3hcIn0sZG9tUHJvcHM6e1wiY2hlY2tlZFwiOl92bS5jaGVja2VkfSxvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uJGVtaXQoJ2NoYW5nZScsICRldmVudC50YXJnZXQuY2hlY2tlZCl9fX0sJ2lucHV0Jyxfdm0uJGF0dHJzLGZhbHNlKSksX3ZtLl92KFwiIFwiKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2xhYmVsXCJ9LFtfdm0uX3QoXCJkZWZhdWx0XCIpXSwyKV0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxsYWJlbCBjbGFzcz1cIm11bHRpZmlsdGVyLWNoZWNrYm94XCI+XG4gICAgPGlucHV0IGNsYXNzPVwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2lucHV0XCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICB2LWJpbmQ9XCIkYXR0cnNcIlxuICAgICAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkXCJcbiAgICAgICAgICAgIEBjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgJGV2ZW50LnRhcmdldC5jaGVja2VkKVwiPlxuICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXItY2hlY2tib3hfX2xhYmVsXCI+PHNsb3Q+PC9zbG90Pjwvc3Bhbj5cbiAgPC9sYWJlbD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiBcIk11bHRpZmlsdGVyQ2hlY2tib3hcIixcbiAgICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICAgIG1vZGVsOiB7XG4gICAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgICBldmVudDogJ2NoYW5nZSdcbiAgICB9LFxuICAgIHByb3BzOiB7XG4gICAgICBjaGVja2VkOiB7XG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgfSxcbiAgICB9LFxuICB9XG48L3NjcmlwdD5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJDaGVja2JveC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL011bHRpZmlsdGVyQ2hlY2tib3gudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIxNzNiYzI2JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL011bHRpZmlsdGVyQ2hlY2tib3gudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NdWx0aWZpbHRlckNoZWNrYm94LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItY2hlY2tib3gtbGlzdFwiPlxuICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1zZWFyY2hcIiB2LWlmPVwic2VhcmNoICYmIGl0ZW1zLmxlbmd0aCA+IDlcIj5cbiAgICAgIDxpbnB1dCBjbGFzcz1cIm11bHRpZmlsdGVyLXNlYXJjaF9faW5wdXRcIiB0eXBlPVwic2VhcmNoXCIgcGxhY2Vob2xkZXI9XCLQn9C+0LjRgdC6XCIgYXV0b2NvbXBsZXRlPVwib2ZmXCIgdi1tb2RlbD1cInNlYXJjaFF1ZXJ5XCI+XG4gICAgPC9kaXY+XG4gICAgPE11bHRpZmlsdGVyQ2hlY2tib3hcbiAgICAgIHYtZm9yPVwiaXRlbSBpbiBhdmFpbGFibGVJdGVtc1wiXG4gICAgICA6a2V5PVwiaXRlbS5pbnB1dC5pZFwiXG4gICAgICB2LXNob3c9XCIhaXRlbS5oaWRkZW5cIlxuICAgICAgdi1tb2RlbD1cIml0ZW0uaW5wdXQuY2hlY2tlZFwiXG4gICAgICA6bmFtZT1cIml0ZW0uaW5wdXQubmFtZVwiXG4gICAgICA6ZGlzYWJsZWQ9XCJmYWxzZVwiXG4gICAgICA6dmFsdWU9XCJpdGVtLmlucHV0LnZhbHVlXCJcbiAgICAgIEBjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgaXRlbS5pbnB1dClcIlxuICAgID57e2l0ZW0uaW5wdXQubGFiZWx9fVxuICAgIDwvTXVsdGlmaWx0ZXJDaGVja2JveD5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItZGVsaW1pdGVyXCIgdi1pZj1cInZpc2libGVOb3RBdmFpbGFibGVJdGVtcy5sZW5ndGhcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXItZGVsaW1pdGVyX190ZXh0XCI+0J3QtdGCINCyINC90LDQu9C40YfQuNC4PC9zcGFuPlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxNdWx0aWZpbHRlckNoZWNrYm94XG4gICAgICB2LWZvcj1cIml0ZW0gaW4gbm90QXZhaWxhYmxlSXRlbXNcIlxuICAgICAgOmtleT1cIml0ZW0uaW5wdXQuaWRcIlxuICAgICAgdi1zaG93PVwiIWl0ZW0uaGlkZGVuXCJcbiAgICAgIHYtbW9kZWw9XCJpdGVtLmlucHV0LmNoZWNrZWRcIlxuICAgICAgOm5hbWU9XCJpdGVtLmlucHV0Lm5hbWVcIlxuICAgICAgOmRpc2FibGVkPVwiIWl0ZW0uaW5wdXQuY2hlY2tlZFwiXG4gICAgICA6dmFsdWU9XCJpdGVtLmlucHV0LnZhbHVlXCJcbiAgICAgIEBjaGFuZ2U9XCIkZW1pdCgnY2hhbmdlJywgaXRlbS5pbnB1dClcIlxuICAgID57e2l0ZW0uaW5wdXQubGFiZWx9fVxuICAgIDwvTXVsdGlmaWx0ZXJDaGVja2JveD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAvLyBpbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwQWN0aW9ucyB9IGZyb20gJ3Z1ZXgnXG4gIGltcG9ydCBNdWx0aWZpbHRlckNoZWNrYm94IGZyb20gJy4vTXVsdGlmaWx0ZXJDaGVja2JveC52dWUnO1xuXG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiTXVsdGlmaWx0ZXJDaGVja2JveExpc3RcIixcbiAgICBwcm9wczoge1xuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXksXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgfSxcbiAgICAgIHNlYXJjaDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgTXVsdGlmaWx0ZXJDaGVja2JveCxcbiAgICB9LFxuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWFyY2hRdWVyeTogJycsXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZmlsdHJlZEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5tYXAoaXRlbSA9PiAoe1xuICAgICAgICAgIC8vIC4uLml0ZW0sXG4gICAgICAgICAgaW5wdXQ6IGl0ZW0sXG4gICAgICAgICAgaGlkZGVuOiBpdGVtLmhpZGRlbiB8fCAodGhpcy5zZWFyY2hRdWVyeSAmJiBpdGVtLmxhYmVsLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIC5pbmRleE9mKHRoaXMuc2VhcmNoUXVlcnkudG9Mb3dlckNhc2UoKSkgPT09IC0xKSxcbiAgICAgICAgfSkpXG4gICAgICB9LFxuICAgICAgYXZhaWxhYmxlSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRyZWRJdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmlucHV0LmF2YWlsYWJsZSlcbiAgICAgIH0sXG4gICAgICBub3RBdmFpbGFibGVJdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdHJlZEl0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmlucHV0LmF2YWlsYWJsZSlcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlTm90QXZhaWxhYmxlSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vdEF2YWlsYWJsZUl0ZW1zLmZpbHRlcihpdGVtID0+ICFpdGVtLmhpZGRlbilcbiAgICAgIH0sXG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPCEtLTxzdHlsZSBzY29wZWQ+LS0+XG5cbjwhLS08L3N0eWxlPi0tPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJDaGVja2JveExpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OTI2MTdjNmMmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vTXVsdGlmaWx0ZXJDaGVja2JveExpc3QudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NdWx0aWZpbHRlckNoZWNrYm94TGlzdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n')},26:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterPrice.vue?vue&type=template&id=730447f8&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"multifilter-price\"},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.minRange),expression:\"minRange\"}],attrs:{\"type\":\"hidden\",\"name\":\"price[from]\"},domProps:{\"value\":(_vm.minRange)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.minRange=$event.target.value}}}),_vm._v(\" \"),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.maxRange),expression:\"maxRange\"}],attrs:{\"type\":\"hidden\",\"name\":\"price[to]\"},domProps:{\"value\":(_vm.maxRange)},on:{\"input\":function($event){if($event.target.composing){ return; }_vm.maxRange=$event.target.value}}}),_vm._v(\" \"),_vm._m(0),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__range\"},[_c('div',{ref:\"slider\",staticClass:\"input-range\"})]),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__num\"},[_c('div',{staticClass:\"multifilter-price__start\"},[_vm._v(_vm._s(_vm.slider.priceMin)+\" ₽\")]),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__end\"},[_vm._v(_vm._s(_vm.slider.priceMax)+\" ₽\")])])])}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"multifilter-price__title\"},[_c('div',{staticClass:\"multifilter-price__start\"},[_vm._v(\"От\")]),_vm._v(\" \"),_c('div',{staticClass:\"multifilter-price__end\"},[_vm._v(\"До\")])])}]\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterPrice.vue?vue&type=template&id=730447f8&\n\n// EXTERNAL MODULE: ./node_modules/nouislider/distribute/nouislider.js\nvar nouislider = __webpack_require__(43);\nvar nouislider_default = /*#__PURE__*/__webpack_require__.n(nouislider);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterPrice.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n // import Dropdown from './Dropdown.vue';\n\n/* harmony default export */ var MultifilterPricevue_type_script_lang_js_ = ({\n  name: 'MultifilterPrice',\n  // components: {\n  //   Dropdown,\n  // },\n  props: {\n    slider: {\n      type: Object,\n      default: null\n    }\n  },\n  data: function data() {\n    return {\n      callback: true,\n      minRange: null,\n      maxRange: null // slider: {\n      //   priceFrom: 0,\n      //   priceTo: 2740,\n      //   priceMin: 0,\n      //   priceMax: 2740,\n      // }\n\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    nouislider_default.a.create(this.$refs.slider, {\n      start: [this.slider.priceFrom, this.slider.priceTo],\n      // start: [this.slider.priceMin, this.slider.priceMax],\n      step: 1,\n      connect: true,\n      tooltips: true,\n      range: {\n        min: this.slider.priceMin,\n        max: this.slider.priceMax\n      },\n      format: {\n        to: function to(value) {\n          return \"\".concat(Math.floor(value), \" \\u20BD\");\n        },\n        from: function from(value) {\n          return value.replace(/[^0-9]/g, '');\n        }\n      },\n      cssPrefix: 'input-range',\n      cssClasses: {\n        target: '',\n        base: '__base',\n        origin: '__origin',\n        handle: '__handle',\n        handleLower: '__handle-lower',\n        handleUpper: '__handle-upper',\n        touchArea: '__touch-area',\n        horizontal: '_horizontal',\n        vertical: '_vertical',\n        background: '__background',\n        connect: '__connect',\n        connects: '__connects',\n        ltr: '_ltr',\n        rtl: '_rtl',\n        draggable: '_draggable',\n        drag: '_state-drag',\n        tap: '_state-tap',\n        active: '__active',\n        tooltip: '__tooltip',\n        // Шкала\n        pips: '__pips',\n        pipsHorizontal: '__pips_horizontal',\n        pipsVertical: '__pips_vertical',\n        // Деления на шкале\n        marker: '__marker',\n        markerHorizontal: '__marker_horizontal',\n        markerVertical: '__marker_vertical',\n        markerNormal: '__marker_normal',\n        markerLarge: '__marker_large',\n        markerSub: '__marker_sub',\n        // Значения на шкале\n        value: '__value',\n        valueHorizontal: '__value_horizontal',\n        valueVertical: '__value_vertical',\n        valueNormal: '__value_normal',\n        valueLarge: '__value_large',\n        valueSub: '__value_sub'\n      }\n    }); // this.$refs.slider.noUiSlider.set([this.slider.priceFrom, this.slider.priceTo]);\n\n    this.$refs.slider.noUiSlider.on('update', function (values, handle) {\n      var t = parseInt(values[handle]);\n      _this[handle ? 'maxRange' : 'minRange'] = t !== _this.slider[handle ? 'priceMax' : 'priceMin'] ? t : '';\n\n      _this.$emit('update', [_this.minRange, _this.maxRange]); // console.log([this.minRange, this.maxRange], handle);\n\n    });\n    this.$refs.slider.noUiSlider.on('set', function () {\n      if (_this.callback) {\n        // this.$root.$emit('filter:change');\n        _this.$emit('change'); // this.$store.dispatch('filters/filterChange');\n\n      }\n    }, 100); // this.$store.subscribeAction((action, state) => {\n    //   console.log(action.type);\n    //   console.log(action.payload);\n    // });\n\n    this.$root.$on('filter:reset', function () {\n      _this.callback = false; // this.$refs.slider.noUiSlider.reset();\n\n      _this.$refs.slider.noUiSlider.set([_this.slider.priceMin, _this.slider.priceMax]);\n\n      _this.callback = true;\n    }); // this.rangeEl.noUiSlider.on('set', this.onChange, 100);\n  },\n  methods: {}\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterPrice.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_MultifilterPricevue_type_script_lang_js_ = (MultifilterPricevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterPrice.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  catalog_MultifilterPricevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var MultifilterPrice = __webpack_exports__[\"a\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyUHJpY2UudnVlPzg2OGQiLCJ3ZWJwYWNrOi8vL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJQcmljZS52dWU/YTI5MSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyUHJpY2UudnVlP2Y3ODEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9NdWx0aWZpbHRlclByaWNlLnZ1ZT83MmNiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsZ0NBQWdDLGNBQWMsYUFBYSwwRUFBMEUsU0FBUyxxQ0FBcUMsV0FBVyx1QkFBdUIsS0FBSyx5QkFBeUIsNEJBQTRCLFFBQVEsRUFBRSxtQ0FBbUMsMEJBQTBCLGFBQWEsMEVBQTBFLFNBQVMsbUNBQW1DLFdBQVcsdUJBQXVCLEtBQUsseUJBQXlCLDRCQUE0QixRQUFRLEVBQUUsbUNBQW1DLDhDQUE4Qyx1Q0FBdUMsWUFBWSx1Q0FBdUMsMEJBQTBCLHFDQUFxQyxZQUFZLHVDQUF1QyxtRUFBbUUscUNBQXFDO0FBQzlpQyxvQ0FBb0MsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQix1Q0FBdUMsWUFBWSx1Q0FBdUMsdUNBQXVDLHFDQUFxQyxtQkFBbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0NtQjdTOztBQUVBO0FBQ0EsMEJBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBREE7QUFFQTtBQUZBO0FBREEsR0FMQTtBQVdBLE1BWEEsa0JBV0E7QUFDQTtBQUNBLG9CQURBO0FBRUEsb0JBRkE7QUFHQSxvQkFIQSxDQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFUQTtBQVdBLEdBdkJBO0FBd0JBLFNBeEJBLHFCQXdCQTtBQUFBOztBQUNBO0FBQ0EseURBREE7QUFFQTtBQUNBLGFBSEE7QUFJQSxtQkFKQTtBQUtBLG9CQUxBO0FBTUE7QUFDQSxpQ0FEQTtBQUVBO0FBRkEsT0FOQTtBQVVBO0FBQ0EsVUFEQSxjQUNBLEtBREEsRUFDQTtBQUNBO0FBQ0EsU0FIQTtBQUlBLFlBSkEsZ0JBSUEsS0FKQSxFQUlBO0FBQ0E7QUFDQTtBQU5BLE9BVkE7QUFrQkEsOEJBbEJBO0FBbUJBO0FBQ0Esa0JBREE7QUFFQSxzQkFGQTtBQUdBLDBCQUhBO0FBSUEsMEJBSkE7QUFLQSxxQ0FMQTtBQU1BLHFDQU5BO0FBT0EsaUNBUEE7QUFRQSxpQ0FSQTtBQVNBLDZCQVRBO0FBVUEsa0NBVkE7QUFXQSw0QkFYQTtBQVlBLDhCQVpBO0FBYUEsbUJBYkE7QUFjQSxtQkFkQTtBQWVBLCtCQWZBO0FBZ0JBLDJCQWhCQTtBQWlCQSx5QkFqQkE7QUFrQkEsMEJBbEJBO0FBbUJBLDRCQW5CQTtBQXFCQTtBQUNBLHNCQXRCQTtBQXVCQSwyQ0F2QkE7QUF3QkEsdUNBeEJBO0FBMEJBO0FBQ0EsMEJBM0JBO0FBNEJBLCtDQTVCQTtBQTZCQSwyQ0E3QkE7QUE4QkEsdUNBOUJBO0FBK0JBLHFDQS9CQTtBQWdDQSxpQ0FoQ0E7QUFrQ0E7QUFDQSx3QkFuQ0E7QUFvQ0EsNkNBcENBO0FBcUNBLHlDQXJDQTtBQXNDQSxxQ0F0Q0E7QUF1Q0EsbUNBdkNBO0FBd0NBO0FBeENBO0FBbkJBLE9BREEsQ0FnRUE7O0FBR0E7QUFDQTtBQUNBLGdEQUNBLDZEQURBOztBQUdBLDhEQUxBLENBTUE7O0FBQ0EsS0FQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBLDhCQUZBLENBR0E7O0FBQ0E7QUFDQSxLQU5BLEVBTUEsR0FOQSxFQTVFQSxDQW9GQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQURBLENBRUE7O0FBQ0E7O0FBQ0E7QUFDQSxLQUxBLEVBekZBLENBZ0dBO0FBQ0EsR0F6SEE7QUEwSEE7QUExSEEsRzs7QUN0QnNNLENBQWdCLDZIQUFHLEVBQUMsQzs7Ozs7QUNBM0g7QUFDM0I7QUFDTDs7O0FBRy9EO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLGdEQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLGlHIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcHJpY2VcIn0sW19jKCdpbnB1dCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwibW9kZWxcIixyYXdOYW1lOlwidi1tb2RlbFwiLHZhbHVlOihfdm0ubWluUmFuZ2UpLGV4cHJlc3Npb246XCJtaW5SYW5nZVwifV0sYXR0cnM6e1widHlwZVwiOlwiaGlkZGVuXCIsXCJuYW1lXCI6XCJwcmljZVtmcm9tXVwifSxkb21Qcm9wczp7XCJ2YWx1ZVwiOihfdm0ubWluUmFuZ2UpfSxvbjp7XCJpbnB1dFwiOmZ1bmN0aW9uKCRldmVudCl7aWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpeyByZXR1cm47IH1fdm0ubWluUmFuZ2U9JGV2ZW50LnRhcmdldC52YWx1ZX19fSksX3ZtLl92KFwiIFwiKSxfYygnaW5wdXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLm1heFJhbmdlKSxleHByZXNzaW9uOlwibWF4UmFuZ2VcIn1dLGF0dHJzOntcInR5cGVcIjpcImhpZGRlblwiLFwibmFtZVwiOlwicHJpY2VbdG9dXCJ9LGRvbVByb3BzOntcInZhbHVlXCI6KF92bS5tYXhSYW5nZSl9LG9uOntcImlucHV0XCI6ZnVuY3Rpb24oJGV2ZW50KXtpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZyl7IHJldHVybjsgfV92bS5tYXhSYW5nZT0kZXZlbnQudGFyZ2V0LnZhbHVlfX19KSxfdm0uX3YoXCIgXCIpLF92bS5fbSgwKSxfdm0uX3YoXCIgXCIpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXByaWNlX19yYW5nZVwifSxbX2MoJ2Rpdicse3JlZjpcInNsaWRlclwiLHN0YXRpY0NsYXNzOlwiaW5wdXQtcmFuZ2VcIn0pXSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fbnVtXCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fc3RhcnRcIn0sW192bS5fdihfdm0uX3MoX3ZtLnNsaWRlci5wcmljZU1pbikrXCIg4oK9XCIpXSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fZW5kXCJ9LFtfdm0uX3YoX3ZtLl9zKF92bS5zbGlkZXIucHJpY2VNYXgpK1wiIOKCvVwiKV0pXSldKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1wcmljZV9fdGl0bGVcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXByaWNlX19zdGFydFwifSxbX3ZtLl92KFwi0J7RglwiKV0pLF92bS5fdihcIiBcIiksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcHJpY2VfX2VuZFwifSxbX3ZtLl92KFwi0JTQvlwiKV0pXSl9XVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VcIj5cbiAgICA8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCJwcmljZVtmcm9tXVwiIHYtbW9kZWw9XCJtaW5SYW5nZVwiPlxuICAgIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCIgbmFtZT1cInByaWNlW3RvXVwiIHYtbW9kZWw9XCJtYXhSYW5nZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1wcmljZV9fdGl0bGVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1wcmljZV9fc3RhcnRcIj7QntGCPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VfX2VuZFwiPtCU0L48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VfX3JhbmdlXCI+XG4gICAgICA8ZGl2IHJlZj1cInNsaWRlclwiIGNsYXNzPVwiaW5wdXQtcmFuZ2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXItcHJpY2VfX251bVwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm11bHRpZmlsdGVyLXByaWNlX19zdGFydFwiPnt7IHNsaWRlci5wcmljZU1pbiB9fSDigr08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtdWx0aWZpbHRlci1wcmljZV9fZW5kXCI+e3sgc2xpZGVyLnByaWNlTWF4IH19IOKCvTwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgbm9VaVNsaWRlciBmcm9tICdub3Vpc2xpZGVyJztcbi8vIGltcG9ydCBEcm9wZG93biBmcm9tICcuL0Ryb3Bkb3duLnZ1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ011bHRpZmlsdGVyUHJpY2UnLFxuICAvLyBjb21wb25lbnRzOiB7XG4gIC8vICAgRHJvcGRvd24sXG4gIC8vIH0sXG4gIHByb3BzOiB7XG4gICAgc2xpZGVyOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgIH0sXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGxiYWNrOiB0cnVlLFxuICAgICAgbWluUmFuZ2U6IG51bGwsXG4gICAgICBtYXhSYW5nZTogbnVsbCxcbiAgICAgIC8vIHNsaWRlcjoge1xuICAgICAgLy8gICBwcmljZUZyb206IDAsXG4gICAgICAvLyAgIHByaWNlVG86IDI3NDAsXG4gICAgICAvLyAgIHByaWNlTWluOiAwLFxuICAgICAgLy8gICBwcmljZU1heDogMjc0MCxcbiAgICAgIC8vIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgbm9VaVNsaWRlci5jcmVhdGUodGhpcy4kcmVmcy5zbGlkZXIsIHtcbiAgICAgIHN0YXJ0OiBbdGhpcy5zbGlkZXIucHJpY2VGcm9tLCB0aGlzLnNsaWRlci5wcmljZVRvXSxcbiAgICAgIC8vIHN0YXJ0OiBbdGhpcy5zbGlkZXIucHJpY2VNaW4sIHRoaXMuc2xpZGVyLnByaWNlTWF4XSxcbiAgICAgIHN0ZXA6IDEsXG4gICAgICBjb25uZWN0OiB0cnVlLFxuICAgICAgdG9vbHRpcHM6IHRydWUsXG4gICAgICByYW5nZToge1xuICAgICAgICBtaW46IHRoaXMuc2xpZGVyLnByaWNlTWluLFxuICAgICAgICBtYXg6IHRoaXMuc2xpZGVyLnByaWNlTWF4LFxuICAgICAgfSxcbiAgICAgIGZvcm1hdDoge1xuICAgICAgICB0byh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBgJHtNYXRoLmZsb29yKHZhbHVlKX0g4oK9YDtcbiAgICAgICAgfSxcbiAgICAgICAgZnJvbSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXjAtOV0vZywgJycpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGNzc1ByZWZpeDogJ2lucHV0LXJhbmdlJyxcbiAgICAgIGNzc0NsYXNzZXM6IHtcbiAgICAgICAgdGFyZ2V0OiAnJyxcbiAgICAgICAgYmFzZTogJ19fYmFzZScsXG4gICAgICAgIG9yaWdpbjogJ19fb3JpZ2luJyxcbiAgICAgICAgaGFuZGxlOiAnX19oYW5kbGUnLFxuICAgICAgICBoYW5kbGVMb3dlcjogJ19faGFuZGxlLWxvd2VyJyxcbiAgICAgICAgaGFuZGxlVXBwZXI6ICdfX2hhbmRsZS11cHBlcicsXG4gICAgICAgIHRvdWNoQXJlYTogJ19fdG91Y2gtYXJlYScsXG4gICAgICAgIGhvcml6b250YWw6ICdfaG9yaXpvbnRhbCcsXG4gICAgICAgIHZlcnRpY2FsOiAnX3ZlcnRpY2FsJyxcbiAgICAgICAgYmFja2dyb3VuZDogJ19fYmFja2dyb3VuZCcsXG4gICAgICAgIGNvbm5lY3Q6ICdfX2Nvbm5lY3QnLFxuICAgICAgICBjb25uZWN0czogJ19fY29ubmVjdHMnLFxuICAgICAgICBsdHI6ICdfbHRyJyxcbiAgICAgICAgcnRsOiAnX3J0bCcsXG4gICAgICAgIGRyYWdnYWJsZTogJ19kcmFnZ2FibGUnLFxuICAgICAgICBkcmFnOiAnX3N0YXRlLWRyYWcnLFxuICAgICAgICB0YXA6ICdfc3RhdGUtdGFwJyxcbiAgICAgICAgYWN0aXZlOiAnX19hY3RpdmUnLFxuICAgICAgICB0b29sdGlwOiAnX190b29sdGlwJyxcblxuICAgICAgICAvLyDQqNC60LDQu9CwXG4gICAgICAgIHBpcHM6ICdfX3BpcHMnLFxuICAgICAgICBwaXBzSG9yaXpvbnRhbDogJ19fcGlwc19ob3Jpem9udGFsJyxcbiAgICAgICAgcGlwc1ZlcnRpY2FsOiAnX19waXBzX3ZlcnRpY2FsJyxcblxuICAgICAgICAvLyDQlNC10LvQtdC90LjRjyDQvdCwINGI0LrQsNC70LVcbiAgICAgICAgbWFya2VyOiAnX19tYXJrZXInLFxuICAgICAgICBtYXJrZXJIb3Jpem9udGFsOiAnX19tYXJrZXJfaG9yaXpvbnRhbCcsXG4gICAgICAgIG1hcmtlclZlcnRpY2FsOiAnX19tYXJrZXJfdmVydGljYWwnLFxuICAgICAgICBtYXJrZXJOb3JtYWw6ICdfX21hcmtlcl9ub3JtYWwnLFxuICAgICAgICBtYXJrZXJMYXJnZTogJ19fbWFya2VyX2xhcmdlJyxcbiAgICAgICAgbWFya2VyU3ViOiAnX19tYXJrZXJfc3ViJyxcblxuICAgICAgICAvLyDQl9C90LDRh9C10L3QuNGPINC90LAg0YjQutCw0LvQtVxuICAgICAgICB2YWx1ZTogJ19fdmFsdWUnLFxuICAgICAgICB2YWx1ZUhvcml6b250YWw6ICdfX3ZhbHVlX2hvcml6b250YWwnLFxuICAgICAgICB2YWx1ZVZlcnRpY2FsOiAnX192YWx1ZV92ZXJ0aWNhbCcsXG4gICAgICAgIHZhbHVlTm9ybWFsOiAnX192YWx1ZV9ub3JtYWwnLFxuICAgICAgICB2YWx1ZUxhcmdlOiAnX192YWx1ZV9sYXJnZScsXG4gICAgICAgIHZhbHVlU3ViOiAnX192YWx1ZV9zdWInLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIHRoaXMuJHJlZnMuc2xpZGVyLm5vVWlTbGlkZXIuc2V0KFt0aGlzLnNsaWRlci5wcmljZUZyb20sIHRoaXMuc2xpZGVyLnByaWNlVG9dKTtcblxuXG4gICAgdGhpcy4kcmVmcy5zbGlkZXIubm9VaVNsaWRlci5vbigndXBkYXRlJywgKHZhbHVlcywgaGFuZGxlKSA9PiB7XG4gICAgICBjb25zdCB0ID0gcGFyc2VJbnQodmFsdWVzW2hhbmRsZV0pO1xuICAgICAgdGhpc1toYW5kbGUgPyAnbWF4UmFuZ2UnIDogJ21pblJhbmdlJ11cbiAgICAgICAgPSAodCAhPT0gdGhpcy5zbGlkZXJbaGFuZGxlID8gJ3ByaWNlTWF4JyA6ICdwcmljZU1pbiddKSA/IHQgOiAnJztcblxuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlJywgW3RoaXMubWluUmFuZ2UsIHRoaXMubWF4UmFuZ2VdKTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKFt0aGlzLm1pblJhbmdlLCB0aGlzLm1heFJhbmdlXSwgaGFuZGxlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuJHJlZnMuc2xpZGVyLm5vVWlTbGlkZXIub24oJ3NldCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHRoaXMuJHJvb3QuJGVtaXQoJ2ZpbHRlcjpjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJyk7XG4gICAgICAgIC8vIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL2ZpbHRlckNoYW5nZScpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG5cbiAgICAvLyB0aGlzLiRzdG9yZS5zdWJzY3JpYmVBY3Rpb24oKGFjdGlvbiwgc3RhdGUpID0+IHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGFjdGlvbi50eXBlKTtcbiAgICAvLyAgIGNvbnNvbGUubG9nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICAvLyB9KTtcblxuICAgIHRoaXMuJHJvb3QuJG9uKCdmaWx0ZXI6cmVzZXQnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gZmFsc2U7XG4gICAgICAvLyB0aGlzLiRyZWZzLnNsaWRlci5ub1VpU2xpZGVyLnJlc2V0KCk7XG4gICAgICB0aGlzLiRyZWZzLnNsaWRlci5ub1VpU2xpZGVyLnNldChbdGhpcy5zbGlkZXIucHJpY2VNaW4sIHRoaXMuc2xpZGVyLnByaWNlTWF4XSk7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMucmFuZ2VFbC5ub1VpU2xpZGVyLm9uKCdzZXQnLCB0aGlzLm9uQ2hhbmdlLCAxMDApO1xuICB9LFxuICBtZXRob2RzOiB7fVxufVxuPC9zY3JpcHQ+XG5cbjwhLS08c3R5bGUgc2NvcGVkPi0tPlxuXG48IS0tPC9zdHlsZT4tLT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJQcmljZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL011bHRpZmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTczMDQ0N2Y4JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL011bHRpZmlsdGVyUHJpY2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NdWx0aWZpbHRlclByaWNlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n")},274:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var domready__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);\n/* harmony import */ var domready__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(domready__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var swiper_js_swiper_esm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);\n/* harmony import */ var _simple__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47);\n/* harmony import */ var _page_catalog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);\n\n\n\n\ndomready__WEBPACK_IMPORTED_MODULE_0___default()(function () {\n  global.PageCatalog = new _page_catalog__WEBPACK_IMPORTED_MODULE_3__[/* default */ \"a\"]({\n    filter: document.querySelector('.filter'),\n    sorting: document.querySelector('.sorting'),\n    quantity: document.querySelector('[data-total-find]'),\n    form: document.getElementById('catalog-filter')\n  }, {\n    ajax: true\n  });\n\n  if (document.documentElement.clientWidth >= 1240) {\n    swiper_js_swiper_esm__WEBPACK_IMPORTED_MODULE_1__[/* Swiper */ \"f\"].use([swiper_js_swiper_esm__WEBPACK_IMPORTED_MODULE_1__[/* Navigation */ \"c\"], swiper_js_swiper_esm__WEBPACK_IMPORTED_MODULE_1__[/* A11y */ \"a\"], swiper_js_swiper_esm__WEBPACK_IMPORTED_MODULE_1__[/* Mousewheel */ \"b\"]]);\n    new swiper_js_swiper_esm__WEBPACK_IMPORTED_MODULE_1__[/* Swiper */ \"f\"]('.search-page-slider', {\n      touchEventsTarget: 'wrapper',\n      wrapperClass: 'slider__wrapper',\n      containerModifierClass: 'slider_',\n      slideClass: 'slider__slide',\n      slideBlankClass: 'slider__slide_invisible-blank',\n      slideActiveClass: 'slider__slide_active',\n      slideDuplicateActiveClass: 'slider__slide_duplicate-active',\n      slideVisibleClass: 'slider__slide_visible',\n      slideDuplicateClass: 'slider__slide_duplicate',\n      slideNextClass: 'slider__slide_next',\n      slideDuplicateNextClass: 'slider__slide_duplicate-next',\n      slidePrevClass: 'slider__slide_prev',\n      slideDuplicatePrevClass: 'slider__slide_duplicate-prev',\n      slidesPerView: 'auto',\n      watchSlidesVisibility: true,\n      freeMode: true,\n      freeModeSticky: true,\n      freeModeMomentumRatio: 0.4,\n      freeModeMomentumVelocityRatio: 0.5,\n      mousewheel: {\n        // enabled: true,\n        forceToAxis: true,\n        invert: true // releaseOnEdges: false,\n\n      },\n      navigation: {\n        nextEl: '.slider-button_next',\n        prevEl: '.slider-button_prev',\n        disabledClass: 'slider-button_disabled',\n        hiddenClass: 'slider-button_hidden'\n      },\n      a11y: {\n        prevSlideMessage: 'Предыдущий слайд',\n        nextSlideMessage: 'Следующий слайд'\n      }\n    });\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2VhcmNoLmpzPzMyNTUiXSwibmFtZXMiOlsicmVhZHkiLCJnbG9iYWwiLCJQYWdlQ2F0YWxvZyIsIkNhdGFsb2dDb250cm9sIiwiZmlsdGVyIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic29ydGluZyIsInF1YW50aXR5IiwiZm9ybSIsImdldEVsZW1lbnRCeUlkIiwiYWpheCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiU3dpcGVyIiwidXNlIiwiTmF2aWdhdGlvbiIsIkExMXkiLCJNb3VzZXdoZWVsIiwidG91Y2hFdmVudHNUYXJnZXQiLCJ3cmFwcGVyQ2xhc3MiLCJjb250YWluZXJNb2RpZmllckNsYXNzIiwic2xpZGVDbGFzcyIsInNsaWRlQmxhbmtDbGFzcyIsInNsaWRlQWN0aXZlQ2xhc3MiLCJzbGlkZUR1cGxpY2F0ZUFjdGl2ZUNsYXNzIiwic2xpZGVWaXNpYmxlQ2xhc3MiLCJzbGlkZUR1cGxpY2F0ZUNsYXNzIiwic2xpZGVOZXh0Q2xhc3MiLCJzbGlkZUR1cGxpY2F0ZU5leHRDbGFzcyIsInNsaWRlUHJldkNsYXNzIiwic2xpZGVEdXBsaWNhdGVQcmV2Q2xhc3MiLCJzbGlkZXNQZXJWaWV3Iiwid2F0Y2hTbGlkZXNWaXNpYmlsaXR5IiwiZnJlZU1vZGUiLCJmcmVlTW9kZVN0aWNreSIsImZyZWVNb2RlTW9tZW50dW1SYXRpbyIsImZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvIiwibW91c2V3aGVlbCIsImZvcmNlVG9BeGlzIiwiaW52ZXJ0IiwibmF2aWdhdGlvbiIsIm5leHRFbCIsInByZXZFbCIsImRpc2FibGVkQ2xhc3MiLCJoaWRkZW5DbGFzcyIsImExMXkiLCJwcmV2U2xpZGVNZXNzYWdlIiwibmV4dFNsaWRlTWVzc2FnZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQU9BO0FBQ0E7QUFHQUEsK0NBQUssQ0FBQyxZQUFNO0FBQ1ZDLFFBQU0sQ0FBQ0MsV0FBUCxHQUFxQixJQUFJQyw2REFBSixDQUFtQjtBQUN0Q0MsVUFBTSxFQUFFQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsU0FBdkIsQ0FEOEI7QUFFdENDLFdBQU8sRUFBRUYsUUFBUSxDQUFDQyxhQUFULENBQXVCLFVBQXZCLENBRjZCO0FBR3RDRSxZQUFRLEVBQUVILFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixtQkFBdkIsQ0FINEI7QUFJdENHLFFBQUksRUFBRUosUUFBUSxDQUFDSyxjQUFULENBQXdCLGdCQUF4QjtBQUpnQyxHQUFuQixFQUtsQjtBQUNEQyxRQUFJLEVBQUU7QUFETCxHQUxrQixDQUFyQjs7QUFTQSxNQUFJTixRQUFRLENBQUNPLGVBQVQsQ0FBeUJDLFdBQXpCLElBQXdDLElBQTVDLEVBQWtEO0FBQ2hEQyx1RUFBTSxDQUFDQyxHQUFQLENBQVcsQ0FBQ0MsdUVBQUQsRUFBYUMsaUVBQWIsRUFBbUJDLHVFQUFuQixDQUFYO0FBRUEsUUFBSUosbUVBQUosQ0FBVyxxQkFBWCxFQUFrQztBQUNoQ0ssdUJBQWlCLEVBQUUsU0FEYTtBQUdoQ0Msa0JBQVksRUFBRSxpQkFIa0I7QUFJaENDLDRCQUFzQixFQUFFLFNBSlE7QUFLaENDLGdCQUFVLEVBQUUsZUFMb0I7QUFNaENDLHFCQUFlLEVBQUUsK0JBTmU7QUFPaENDLHNCQUFnQixFQUFFLHNCQVBjO0FBUWhDQywrQkFBeUIsRUFBRSxnQ0FSSztBQVNoQ0MsdUJBQWlCLEVBQUUsdUJBVGE7QUFVaENDLHlCQUFtQixFQUFFLHlCQVZXO0FBV2hDQyxvQkFBYyxFQUFFLG9CQVhnQjtBQVloQ0MsNkJBQXVCLEVBQUUsOEJBWk87QUFhaENDLG9CQUFjLEVBQUUsb0JBYmdCO0FBY2hDQyw2QkFBdUIsRUFBRSw4QkFkTztBQWdCaENDLG1CQUFhLEVBQUUsTUFoQmlCO0FBaUJoQ0MsMkJBQXFCLEVBQUUsSUFqQlM7QUFtQmhDQyxjQUFRLEVBQUUsSUFuQnNCO0FBb0JoQ0Msb0JBQWMsRUFBRSxJQXBCZ0I7QUFxQmhDQywyQkFBcUIsRUFBRSxHQXJCUztBQXNCaENDLG1DQUE2QixFQUFFLEdBdEJDO0FBdUJoQ0MsZ0JBQVUsRUFBRTtBQUNWO0FBQ0FDLG1CQUFXLEVBQUUsSUFGSDtBQUdWQyxjQUFNLEVBQUUsSUFIRSxDQUlWOztBQUpVLE9BdkJvQjtBQTZCaENDLGdCQUFVLEVBQUU7QUFDVkMsY0FBTSxFQUFFLHFCQURFO0FBRVZDLGNBQU0sRUFBRSxxQkFGRTtBQUdWQyxxQkFBYSxFQUFFLHdCQUhMO0FBSVZDLG1CQUFXLEVBQUU7QUFKSCxPQTdCb0I7QUFtQ2hDQyxVQUFJLEVBQUU7QUFDSkMsd0JBQWdCLEVBQUUsa0JBRGQ7QUFFSkMsd0JBQWdCLEVBQUU7QUFGZDtBQW5DMEIsS0FBbEM7QUF3Q0Q7QUFDRixDQXRESSxDQUFMLEMiLCJmaWxlIjoiMjc0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlYWR5IGZyb20gJ2RvbXJlYWR5JztcblxuaW1wb3J0IHtcbiAgU3dpcGVyLFxuICBBMTF5LFxuICBNb3VzZXdoZWVsLFxuICBOYXZpZ2F0aW9uLFxufSBmcm9tICdzd2lwZXIvanMvc3dpcGVyLmVzbSc7XG5cbmltcG9ydCAnLi9zaW1wbGUnO1xuaW1wb3J0IENhdGFsb2dDb250cm9sIGZyb20gJ0AvcGFnZS9jYXRhbG9nJztcblxuXG5yZWFkeSgoKSA9PiB7XG4gIGdsb2JhbC5QYWdlQ2F0YWxvZyA9IG5ldyBDYXRhbG9nQ29udHJvbCh7XG4gICAgZmlsdGVyOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyJyksXG4gICAgc29ydGluZzogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNvcnRpbmcnKSxcbiAgICBxdWFudGl0eTogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtdG90YWwtZmluZF0nKSxcbiAgICBmb3JtOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2F0YWxvZy1maWx0ZXInKSxcbiAgfSwge1xuICAgIGFqYXg6IHRydWUsXG4gIH0pO1xuXG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPj0gMTI0MCkge1xuICAgIFN3aXBlci51c2UoW05hdmlnYXRpb24sIEExMXksIE1vdXNld2hlZWxdKTtcblxuICAgIG5ldyBTd2lwZXIoJy5zZWFyY2gtcGFnZS1zbGlkZXInLCB7XG4gICAgICB0b3VjaEV2ZW50c1RhcmdldDogJ3dyYXBwZXInLFxuXG4gICAgICB3cmFwcGVyQ2xhc3M6ICdzbGlkZXJfX3dyYXBwZXInLFxuICAgICAgY29udGFpbmVyTW9kaWZpZXJDbGFzczogJ3NsaWRlcl8nLFxuICAgICAgc2xpZGVDbGFzczogJ3NsaWRlcl9fc2xpZGUnLFxuICAgICAgc2xpZGVCbGFua0NsYXNzOiAnc2xpZGVyX19zbGlkZV9pbnZpc2libGUtYmxhbmsnLFxuICAgICAgc2xpZGVBY3RpdmVDbGFzczogJ3NsaWRlcl9fc2xpZGVfYWN0aXZlJyxcbiAgICAgIHNsaWRlRHVwbGljYXRlQWN0aXZlQ2xhc3M6ICdzbGlkZXJfX3NsaWRlX2R1cGxpY2F0ZS1hY3RpdmUnLFxuICAgICAgc2xpZGVWaXNpYmxlQ2xhc3M6ICdzbGlkZXJfX3NsaWRlX3Zpc2libGUnLFxuICAgICAgc2xpZGVEdXBsaWNhdGVDbGFzczogJ3NsaWRlcl9fc2xpZGVfZHVwbGljYXRlJyxcbiAgICAgIHNsaWRlTmV4dENsYXNzOiAnc2xpZGVyX19zbGlkZV9uZXh0JyxcbiAgICAgIHNsaWRlRHVwbGljYXRlTmV4dENsYXNzOiAnc2xpZGVyX19zbGlkZV9kdXBsaWNhdGUtbmV4dCcsXG4gICAgICBzbGlkZVByZXZDbGFzczogJ3NsaWRlcl9fc2xpZGVfcHJldicsXG4gICAgICBzbGlkZUR1cGxpY2F0ZVByZXZDbGFzczogJ3NsaWRlcl9fc2xpZGVfZHVwbGljYXRlLXByZXYnLFxuXG4gICAgICBzbGlkZXNQZXJWaWV3OiAnYXV0bycsXG4gICAgICB3YXRjaFNsaWRlc1Zpc2liaWxpdHk6IHRydWUsXG5cbiAgICAgIGZyZWVNb2RlOiB0cnVlLFxuICAgICAgZnJlZU1vZGVTdGlja3k6IHRydWUsXG4gICAgICBmcmVlTW9kZU1vbWVudHVtUmF0aW86IDAuNCxcbiAgICAgIGZyZWVNb2RlTW9tZW50dW1WZWxvY2l0eVJhdGlvOiAwLjUsXG4gICAgICBtb3VzZXdoZWVsOiB7XG4gICAgICAgIC8vIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIGZvcmNlVG9BeGlzOiB0cnVlLFxuICAgICAgICBpbnZlcnQ6IHRydWUsXG4gICAgICAgIC8vIHJlbGVhc2VPbkVkZ2VzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICAgIG5leHRFbDogJy5zbGlkZXItYnV0dG9uX25leHQnLFxuICAgICAgICBwcmV2RWw6ICcuc2xpZGVyLWJ1dHRvbl9wcmV2JyxcbiAgICAgICAgZGlzYWJsZWRDbGFzczogJ3NsaWRlci1idXR0b25fZGlzYWJsZWQnLFxuICAgICAgICBoaWRkZW5DbGFzczogJ3NsaWRlci1idXR0b25faGlkZGVuJyxcbiAgICAgIH0sXG4gICAgICBhMTF5OiB7XG4gICAgICAgIHByZXZTbGlkZU1lc3NhZ2U6ICfQn9GA0LXQtNGL0LTRg9GJ0LjQuSDRgdC70LDQudC0JyxcbiAgICAgICAgbmV4dFNsaWRlTWVzc2FnZTogJ9Ch0LvQtdC00YPRjtGJ0LjQuSDRgdC70LDQudC0JyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///274\n")},41:function(module,exports,__webpack_require__){eval('var _typeof = __webpack_require__(63);\n\nvar assertThisInitialized = __webpack_require__(9);\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === "object" || typeof call === "function")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzPzZiNTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLEVBQW1COztBQUV6Qyw0QkFBNEIsbUJBQU8sQ0FBQyxDQUF5Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI0MS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n')},42:function(module,exports,__webpack_require__){eval('var setPrototypeOf = __webpack_require__(58);\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz9lZDZkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQixtQkFBTyxDQUFDLEVBQWtCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSIsImZpbGUiOiI0Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n')},43:function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 13.1.4 - 3/20/2019 */\n(function(factory) {\r\n    if (true) {\r\n        // AMD. Register as an anonymous module.\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else {}\r\n})(function() {\r\n    "use strict";\r\n\r\n    var VERSION = "13.1.4";\r\n\r\n    //region Helper Methods\r\n\r\n    function isValidFormatter(entry) {\r\n        return typeof entry === "object" && typeof entry.to === "function" && typeof entry.from === "function";\r\n    }\r\n\r\n    function removeElement(el) {\r\n        el.parentElement.removeChild(el);\r\n    }\r\n\r\n    function isSet(value) {\r\n        return value !== null && value !== undefined;\r\n    }\r\n\r\n    // Bindable version\r\n    function preventDefault(e) {\r\n        e.preventDefault();\r\n    }\r\n\r\n    // Removes duplicates from an array.\r\n    function unique(array) {\r\n        return array.filter(function(a) {\r\n            return !this[a] ? (this[a] = true) : false;\r\n        }, {});\r\n    }\r\n\r\n    // Round a value to the closest \'to\'.\r\n    function closest(value, to) {\r\n        return Math.round(value / to) * to;\r\n    }\r\n\r\n    // Current position of an element relative to the document.\r\n    function offset(elem, orientation) {\r\n        var rect = elem.getBoundingClientRect();\r\n        var doc = elem.ownerDocument;\r\n        var docElem = doc.documentElement;\r\n        var pageOffset = getPageOffset(doc);\r\n\r\n        // getBoundingClientRect contains left scroll in Chrome on Android.\r\n        // I haven\'t found a feature detection that proves this. Worst case\r\n        // scenario on mis-match: the \'tap\' feature on horizontal sliders breaks.\r\n        if (/webkit.*Chrome.*Mobile/i.test(navigator.userAgent)) {\r\n            pageOffset.x = 0;\r\n        }\r\n\r\n        return orientation\r\n            ? rect.top + pageOffset.y - docElem.clientTop\r\n            : rect.left + pageOffset.x - docElem.clientLeft;\r\n    }\r\n\r\n    // Checks whether a value is numerical.\r\n    function isNumeric(a) {\r\n        return typeof a === "number" && !isNaN(a) && isFinite(a);\r\n    }\r\n\r\n    // Sets a class and removes it after [duration] ms.\r\n    function addClassFor(element, className, duration) {\r\n        if (duration > 0) {\r\n            addClass(element, className);\r\n            setTimeout(function() {\r\n                removeClass(element, className);\r\n            }, duration);\r\n        }\r\n    }\r\n\r\n    // Limits a value to 0 - 100\r\n    function limit(a) {\r\n        return Math.max(Math.min(a, 100), 0);\r\n    }\r\n\r\n    // Wraps a variable as an array, if it isn\'t one yet.\r\n    // Note that an input array is returned by reference!\r\n    function asArray(a) {\r\n        return Array.isArray(a) ? a : [a];\r\n    }\r\n\r\n    // Counts decimals\r\n    function countDecimals(numStr) {\r\n        numStr = String(numStr);\r\n        var pieces = numStr.split(".");\r\n        return pieces.length > 1 ? pieces[1].length : 0;\r\n    }\r\n\r\n    // http://youmightnotneedjquery.com/#add_class\r\n    function addClass(el, className) {\r\n        if (el.classList) {\r\n            el.classList.add(className);\r\n        } else {\r\n            el.className += " " + className;\r\n        }\r\n    }\r\n\r\n    // http://youmightnotneedjquery.com/#remove_class\r\n    function removeClass(el, className) {\r\n        if (el.classList) {\r\n            el.classList.remove(className);\r\n        } else {\r\n            el.className = el.className.replace(\r\n                new RegExp("(^|\\\\b)" + className.split(" ").join("|") + "(\\\\b|$)", "gi"),\r\n                " "\r\n            );\r\n        }\r\n    }\r\n\r\n    // https://plainjs.com/javascript/attributes/adding-removing-and-testing-for-classes-9/\r\n    function hasClass(el, className) {\r\n        return el.classList\r\n            ? el.classList.contains(className)\r\n            : new RegExp("\\\\b" + className + "\\\\b").test(el.className);\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\r\n    function getPageOffset(doc) {\r\n        var supportPageOffset = window.pageXOffset !== undefined;\r\n        var isCSS1Compat = (doc.compatMode || "") === "CSS1Compat";\r\n        var x = supportPageOffset\r\n            ? window.pageXOffset\r\n            : isCSS1Compat\r\n                ? doc.documentElement.scrollLeft\r\n                : doc.body.scrollLeft;\r\n        var y = supportPageOffset\r\n            ? window.pageYOffset\r\n            : isCSS1Compat\r\n                ? doc.documentElement.scrollTop\r\n                : doc.body.scrollTop;\r\n\r\n        return {\r\n            x: x,\r\n            y: y\r\n        };\r\n    }\r\n\r\n    // we provide a function to compute constants instead\r\n    // of accessing window.* as soon as the module needs it\r\n    // so that we do not compute anything if not needed\r\n    function getActions() {\r\n        // Determine the events to bind. IE11 implements pointerEvents without\r\n        // a prefix, which breaks compatibility with the IE10 implementation.\r\n        return window.navigator.pointerEnabled\r\n            ? {\r\n                  start: "pointerdown",\r\n                  move: "pointermove",\r\n                  end: "pointerup"\r\n              }\r\n            : window.navigator.msPointerEnabled\r\n                ? {\r\n                      start: "MSPointerDown",\r\n                      move: "MSPointerMove",\r\n                      end: "MSPointerUp"\r\n                  }\r\n                : {\r\n                      start: "mousedown touchstart",\r\n                      move: "mousemove touchmove",\r\n                      end: "mouseup touchend"\r\n                  };\r\n    }\r\n\r\n    // https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\r\n    // Issue #785\r\n    function getSupportsPassive() {\r\n        var supportsPassive = false;\r\n\r\n        /* eslint-disable */\r\n        try {\r\n            var opts = Object.defineProperty({}, "passive", {\r\n                get: function() {\r\n                    supportsPassive = true;\r\n                }\r\n            });\r\n\r\n            window.addEventListener("test", null, opts);\r\n        } catch (e) {}\r\n        /* eslint-enable */\r\n\r\n        return supportsPassive;\r\n    }\r\n\r\n    function getSupportsTouchActionNone() {\r\n        return window.CSS && CSS.supports && CSS.supports("touch-action", "none");\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region Range Calculation\r\n\r\n    // Determine the size of a sub-range in relation to a full range.\r\n    function subRangeRatio(pa, pb) {\r\n        return 100 / (pb - pa);\r\n    }\r\n\r\n    // (percentage) How many percent is this value of this range?\r\n    function fromPercentage(range, value) {\r\n        return (value * 100) / (range[1] - range[0]);\r\n    }\r\n\r\n    // (percentage) Where is this value on this range?\r\n    function toPercentage(range, value) {\r\n        return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0]);\r\n    }\r\n\r\n    // (value) How much is this percentage on this range?\r\n    function isPercentage(range, value) {\r\n        return (value * (range[1] - range[0])) / 100 + range[0];\r\n    }\r\n\r\n    function getJ(value, arr) {\r\n        var j = 1;\r\n\r\n        while (value >= arr[j]) {\r\n            j += 1;\r\n        }\r\n\r\n        return j;\r\n    }\r\n\r\n    // (percentage) Input a value, find where, on a scale of 0-100, it applies.\r\n    function toStepping(xVal, xPct, value) {\r\n        if (value >= xVal.slice(-1)[0]) {\r\n            return 100;\r\n        }\r\n\r\n        var j = getJ(value, xVal);\r\n        var va = xVal[j - 1];\r\n        var vb = xVal[j];\r\n        var pa = xPct[j - 1];\r\n        var pb = xPct[j];\r\n\r\n        return pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb);\r\n    }\r\n\r\n    // (value) Input a percentage, find where it is on the specified range.\r\n    function fromStepping(xVal, xPct, value) {\r\n        // There is no range group that fits 100\r\n        if (value >= 100) {\r\n            return xVal.slice(-1)[0];\r\n        }\r\n\r\n        var j = getJ(value, xPct);\r\n        var va = xVal[j - 1];\r\n        var vb = xVal[j];\r\n        var pa = xPct[j - 1];\r\n        var pb = xPct[j];\r\n\r\n        return isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb));\r\n    }\r\n\r\n    // (percentage) Get the step that applies at a certain value.\r\n    function getStep(xPct, xSteps, snap, value) {\r\n        if (value === 100) {\r\n            return value;\r\n        }\r\n\r\n        var j = getJ(value, xPct);\r\n        var a = xPct[j - 1];\r\n        var b = xPct[j];\r\n\r\n        // If \'snap\' is set, steps are used as fixed points on the slider.\r\n        if (snap) {\r\n            // Find the closest position, a or b.\r\n            if (value - a > (b - a) / 2) {\r\n                return b;\r\n            }\r\n\r\n            return a;\r\n        }\r\n\r\n        if (!xSteps[j - 1]) {\r\n            return value;\r\n        }\r\n\r\n        return xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]);\r\n    }\r\n\r\n    function handleEntryPoint(index, value, that) {\r\n        var percentage;\r\n\r\n        // Wrap numerical input in an array.\r\n        if (typeof value === "number") {\r\n            value = [value];\r\n        }\r\n\r\n        // Reject any invalid input, by testing whether value is an array.\r\n        if (!Array.isArray(value)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' contains invalid value.");\r\n        }\r\n\r\n        // Covert min/max syntax to 0 and 100.\r\n        if (index === "min") {\r\n            percentage = 0;\r\n        } else if (index === "max") {\r\n            percentage = 100;\r\n        } else {\r\n            percentage = parseFloat(index);\r\n        }\r\n\r\n        // Check for correct input.\r\n        if (!isNumeric(percentage) || !isNumeric(value[0])) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' value isn\'t numeric.");\r\n        }\r\n\r\n        // Store values.\r\n        that.xPct.push(percentage);\r\n        that.xVal.push(value[0]);\r\n\r\n        // NaN will evaluate to false too, but to keep\r\n        // logging clear, set step explicitly. Make sure\r\n        // not to override the \'step\' setting with false.\r\n        if (!percentage) {\r\n            if (!isNaN(value[1])) {\r\n                that.xSteps[0] = value[1];\r\n            }\r\n        } else {\r\n            that.xSteps.push(isNaN(value[1]) ? false : value[1]);\r\n        }\r\n\r\n        that.xHighestCompleteStep.push(0);\r\n    }\r\n\r\n    function handleStepPoint(i, n, that) {\r\n        // Ignore \'false\' stepping.\r\n        if (!n) {\r\n            return;\r\n        }\r\n\r\n        // Step over zero-length ranges (#948);\r\n        if (that.xVal[i] === that.xVal[i + 1]) {\r\n            that.xSteps[i] = that.xHighestCompleteStep[i] = that.xVal[i];\r\n\r\n            return;\r\n        }\r\n\r\n        // Factor to range ratio\r\n        that.xSteps[i] =\r\n            fromPercentage([that.xVal[i], that.xVal[i + 1]], n) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);\r\n\r\n        var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i];\r\n        var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);\r\n        var step = that.xVal[i] + that.xNumSteps[i] * highestStep;\r\n\r\n        that.xHighestCompleteStep[i] = step;\r\n    }\r\n\r\n    //endregion\r\n\r\n    //region Spectrum\r\n\r\n    function Spectrum(entry, snap, singleStep) {\r\n        this.xPct = [];\r\n        this.xVal = [];\r\n        this.xSteps = [singleStep || false];\r\n        this.xNumSteps = [false];\r\n        this.xHighestCompleteStep = [];\r\n\r\n        this.snap = snap;\r\n\r\n        var index;\r\n        var ordered = []; // [0, \'min\'], [1, \'50%\'], [2, \'max\']\r\n\r\n        // Map the object keys to an array.\r\n        for (index in entry) {\r\n            if (entry.hasOwnProperty(index)) {\r\n                ordered.push([entry[index], index]);\r\n            }\r\n        }\r\n\r\n        // Sort all entries by value (numeric sort).\r\n        if (ordered.length && typeof ordered[0][0] === "object") {\r\n            ordered.sort(function(a, b) {\r\n                return a[0][0] - b[0][0];\r\n            });\r\n        } else {\r\n            ordered.sort(function(a, b) {\r\n                return a[0] - b[0];\r\n            });\r\n        }\r\n\r\n        // Convert all entries to subranges.\r\n        for (index = 0; index < ordered.length; index++) {\r\n            handleEntryPoint(ordered[index][1], ordered[index][0], this);\r\n        }\r\n\r\n        // Store the actual step values.\r\n        // xSteps is sorted in the same order as xPct and xVal.\r\n        this.xNumSteps = this.xSteps.slice(0);\r\n\r\n        // Convert all numeric steps to the percentage of the subrange they represent.\r\n        for (index = 0; index < this.xNumSteps.length; index++) {\r\n            handleStepPoint(index, this.xNumSteps[index], this);\r\n        }\r\n    }\r\n\r\n    Spectrum.prototype.getMargin = function(value) {\r\n        var step = this.xNumSteps[0];\r\n\r\n        if (step && (value / step) % 1 !== 0) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'limit\', \'margin\' and \'padding\' must be divisible by step.");\r\n        }\r\n\r\n        return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\r\n    };\r\n\r\n    Spectrum.prototype.toStepping = function(value) {\r\n        value = toStepping(this.xVal, this.xPct, value);\r\n\r\n        return value;\r\n    };\r\n\r\n    Spectrum.prototype.fromStepping = function(value) {\r\n        return fromStepping(this.xVal, this.xPct, value);\r\n    };\r\n\r\n    Spectrum.prototype.getStep = function(value) {\r\n        value = getStep(this.xPct, this.xSteps, this.snap, value);\r\n\r\n        return value;\r\n    };\r\n\r\n    Spectrum.prototype.getDefaultStep = function(value, isDown, size) {\r\n        var j = getJ(value, this.xPct);\r\n\r\n        // When at the top or stepping down, look at the previous sub-range\r\n        if (value === 100 || (isDown && value === this.xPct[j - 1])) {\r\n            j = Math.max(j - 1, 1);\r\n        }\r\n\r\n        return (this.xVal[j] - this.xVal[j - 1]) / size;\r\n    };\r\n\r\n    Spectrum.prototype.getNearbySteps = function(value) {\r\n        var j = getJ(value, this.xPct);\r\n\r\n        return {\r\n            stepBefore: {\r\n                startValue: this.xVal[j - 2],\r\n                step: this.xNumSteps[j - 2],\r\n                highestStep: this.xHighestCompleteStep[j - 2]\r\n            },\r\n            thisStep: {\r\n                startValue: this.xVal[j - 1],\r\n                step: this.xNumSteps[j - 1],\r\n                highestStep: this.xHighestCompleteStep[j - 1]\r\n            },\r\n            stepAfter: {\r\n                startValue: this.xVal[j],\r\n                step: this.xNumSteps[j],\r\n                highestStep: this.xHighestCompleteStep[j]\r\n            }\r\n        };\r\n    };\r\n\r\n    Spectrum.prototype.countStepDecimals = function() {\r\n        var stepDecimals = this.xNumSteps.map(countDecimals);\r\n        return Math.max.apply(null, stepDecimals);\r\n    };\r\n\r\n    // Outside testing\r\n    Spectrum.prototype.convert = function(value) {\r\n        return this.getStep(this.toStepping(value));\r\n    };\r\n\r\n    //endregion\r\n\r\n    //region Options\r\n\r\n    /*\tEvery input option is tested and parsed. This\'ll prevent\r\n        endless validation in internal methods. These tests are\r\n        structured with an item for every option available. An\r\n        option can be marked as required by setting the \'r\' flag.\r\n        The testing function is provided with three arguments:\r\n            - The provided value for the option;\r\n            - A reference to the options object;\r\n            - The name for the option;\r\n\r\n        The testing function returns false when an error is detected,\r\n        or true when everything is OK. It can also modify the option\r\n        object, to make sure all values can be correctly looped elsewhere. */\r\n\r\n    var defaultFormatter = {\r\n        to: function(value) {\r\n            return value !== undefined && value.toFixed(2);\r\n        },\r\n        from: Number\r\n    };\r\n\r\n    function validateFormat(entry) {\r\n        // Any object with a to and from method is supported.\r\n        if (isValidFormatter(entry)) {\r\n            return true;\r\n        }\r\n\r\n        throw new Error("noUiSlider (" + VERSION + "): \'format\' requires \'to\' and \'from\' methods.");\r\n    }\r\n\r\n    function testStep(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'step\' is not numeric.");\r\n        }\r\n\r\n        // The step option can still be used to set stepping\r\n        // for linear sliders. Overwritten if set in \'range\'.\r\n        parsed.singleStep = entry;\r\n    }\r\n\r\n    function testRange(parsed, entry) {\r\n        // Filter incorrect input.\r\n        if (typeof entry !== "object" || Array.isArray(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' is not an object.");\r\n        }\r\n\r\n        // Catch missing start or end.\r\n        if (entry.min === undefined || entry.max === undefined) {\r\n            throw new Error("noUiSlider (" + VERSION + "): Missing \'min\' or \'max\' in \'range\'.");\r\n        }\r\n\r\n        // Catch equal start or end.\r\n        if (entry.min === entry.max) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'range\' \'min\' and \'max\' cannot be equal.");\r\n        }\r\n\r\n        parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);\r\n    }\r\n\r\n    function testStart(parsed, entry) {\r\n        entry = asArray(entry);\r\n\r\n        // Validate input. Values aren\'t tested, as the public .val method\r\n        // will always provide a valid location.\r\n        if (!Array.isArray(entry) || !entry.length) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'start\' option is incorrect.");\r\n        }\r\n\r\n        // Store the number of handles.\r\n        parsed.handles = entry.length;\r\n\r\n        // When the slider is initialized, the .val method will\r\n        // be called with the start options.\r\n        parsed.start = entry;\r\n    }\r\n\r\n    function testSnap(parsed, entry) {\r\n        // Enforce 100% stepping within subranges.\r\n        parsed.snap = entry;\r\n\r\n        if (typeof entry !== "boolean") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'snap\' option must be a boolean.");\r\n        }\r\n    }\r\n\r\n    function testAnimate(parsed, entry) {\r\n        // Enforce 100% stepping within subranges.\r\n        parsed.animate = entry;\r\n\r\n        if (typeof entry !== "boolean") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'animate\' option must be a boolean.");\r\n        }\r\n    }\r\n\r\n    function testAnimationDuration(parsed, entry) {\r\n        parsed.animationDuration = entry;\r\n\r\n        if (typeof entry !== "number") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'animationDuration\' option must be a number.");\r\n        }\r\n    }\r\n\r\n    function testConnect(parsed, entry) {\r\n        var connect = [false];\r\n        var i;\r\n\r\n        // Map legacy options\r\n        if (entry === "lower") {\r\n            entry = [true, false];\r\n        } else if (entry === "upper") {\r\n            entry = [false, true];\r\n        }\r\n\r\n        // Handle boolean options\r\n        if (entry === true || entry === false) {\r\n            for (i = 1; i < parsed.handles; i++) {\r\n                connect.push(entry);\r\n            }\r\n\r\n            connect.push(false);\r\n        }\r\n\r\n        // Reject invalid input\r\n        else if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'connect\' option doesn\'t match handle count.");\r\n        } else {\r\n            connect = entry;\r\n        }\r\n\r\n        parsed.connect = connect;\r\n    }\r\n\r\n    function testOrientation(parsed, entry) {\r\n        // Set orientation to an a numerical value for easy\r\n        // array selection.\r\n        switch (entry) {\r\n            case "horizontal":\r\n                parsed.ort = 0;\r\n                break;\r\n            case "vertical":\r\n                parsed.ort = 1;\r\n                break;\r\n            default:\r\n                throw new Error("noUiSlider (" + VERSION + "): \'orientation\' option is invalid.");\r\n        }\r\n    }\r\n\r\n    function testMargin(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'margin\' option must be numeric.");\r\n        }\r\n\r\n        // Issue #582\r\n        if (entry === 0) {\r\n            return;\r\n        }\r\n\r\n        parsed.margin = parsed.spectrum.getMargin(entry);\r\n\r\n        if (!parsed.margin) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'margin\' option is only supported on linear sliders.");\r\n        }\r\n    }\r\n\r\n    function testLimit(parsed, entry) {\r\n        if (!isNumeric(entry)) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'limit\' option must be numeric.");\r\n        }\r\n\r\n        parsed.limit = parsed.spectrum.getMargin(entry);\r\n\r\n        if (!parsed.limit || parsed.handles < 2) {\r\n            throw new Error(\r\n                "noUiSlider (" +\r\n                    VERSION +\r\n                    "): \'limit\' option is only supported on linear sliders with 2 or more handles."\r\n            );\r\n        }\r\n    }\r\n\r\n    function testPadding(parsed, entry) {\r\n        if (!isNumeric(entry) && !Array.isArray(entry)) {\r\n            throw new Error(\r\n                "noUiSlider (" + VERSION + "): \'padding\' option must be numeric or array of exactly 2 numbers."\r\n            );\r\n        }\r\n\r\n        if (Array.isArray(entry) && !(entry.length === 2 || isNumeric(entry[0]) || isNumeric(entry[1]))) {\r\n            throw new Error(\r\n                "noUiSlider (" + VERSION + "): \'padding\' option must be numeric or array of exactly 2 numbers."\r\n            );\r\n        }\r\n\r\n        if (entry === 0) {\r\n            return;\r\n        }\r\n\r\n        if (!Array.isArray(entry)) {\r\n            entry = [entry, entry];\r\n        }\r\n\r\n        // \'getMargin\' returns false for invalid values.\r\n        parsed.padding = [parsed.spectrum.getMargin(entry[0]), parsed.spectrum.getMargin(entry[1])];\r\n\r\n        if (parsed.padding[0] === false || parsed.padding[1] === false) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'padding\' option is only supported on linear sliders.");\r\n        }\r\n\r\n        if (parsed.padding[0] < 0 || parsed.padding[1] < 0) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must be a positive number(s).");\r\n        }\r\n\r\n        if (parsed.padding[0] + parsed.padding[1] >= 100) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'padding\' option must not exceed 100% of the range.");\r\n        }\r\n    }\r\n\r\n    function testDirection(parsed, entry) {\r\n        // Set direction as a numerical value for easy parsing.\r\n        // Invert connection for RTL sliders, so that the proper\r\n        // handles get the connect/background classes.\r\n        switch (entry) {\r\n            case "ltr":\r\n                parsed.dir = 0;\r\n                break;\r\n            case "rtl":\r\n                parsed.dir = 1;\r\n                break;\r\n            default:\r\n                throw new Error("noUiSlider (" + VERSION + "): \'direction\' option was not recognized.");\r\n        }\r\n    }\r\n\r\n    function testBehaviour(parsed, entry) {\r\n        // Make sure the input is a string.\r\n        if (typeof entry !== "string") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'behaviour\' must be a string containing options.");\r\n        }\r\n\r\n        // Check if the string contains any keywords.\r\n        // None are required.\r\n        var tap = entry.indexOf("tap") >= 0;\r\n        var drag = entry.indexOf("drag") >= 0;\r\n        var fixed = entry.indexOf("fixed") >= 0;\r\n        var snap = entry.indexOf("snap") >= 0;\r\n        var hover = entry.indexOf("hover") >= 0;\r\n        var unconstrained = entry.indexOf("unconstrained") >= 0;\r\n\r\n        if (fixed) {\r\n            if (parsed.handles !== 2) {\r\n                throw new Error("noUiSlider (" + VERSION + "): \'fixed\' behaviour must be used with 2 handles");\r\n            }\r\n\r\n            // Use margin to enforce fixed state\r\n            testMargin(parsed, parsed.start[1] - parsed.start[0]);\r\n        }\r\n\r\n        if (unconstrained && (parsed.margin || parsed.limit)) {\r\n            throw new Error(\r\n                "noUiSlider (" + VERSION + "): \'unconstrained\' behaviour cannot be used with margin or limit"\r\n            );\r\n        }\r\n\r\n        parsed.events = {\r\n            tap: tap || snap,\r\n            drag: drag,\r\n            fixed: fixed,\r\n            snap: snap,\r\n            hover: hover,\r\n            unconstrained: unconstrained\r\n        };\r\n    }\r\n\r\n    function testTooltips(parsed, entry) {\r\n        if (entry === false) {\r\n            return;\r\n        }\r\n\r\n        if (entry === true) {\r\n            parsed.tooltips = [];\r\n\r\n            for (var i = 0; i < parsed.handles; i++) {\r\n                parsed.tooltips.push(true);\r\n            }\r\n        } else {\r\n            parsed.tooltips = asArray(entry);\r\n\r\n            if (parsed.tooltips.length !== parsed.handles) {\r\n                throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");\r\n            }\r\n\r\n            parsed.tooltips.forEach(function(formatter) {\r\n                if (\r\n                    typeof formatter !== "boolean" &&\r\n                    (typeof formatter !== "object" || typeof formatter.to !== "function")\r\n                ) {\r\n                    throw new Error("noUiSlider (" + VERSION + "): \'tooltips\' must be passed a formatter or \'false\'.");\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function testAriaFormat(parsed, entry) {\r\n        parsed.ariaFormat = entry;\r\n        validateFormat(entry);\r\n    }\r\n\r\n    function testFormat(parsed, entry) {\r\n        parsed.format = entry;\r\n        validateFormat(entry);\r\n    }\r\n\r\n    function testKeyboardSupport(parsed, entry) {\r\n        parsed.keyboardSupport = entry;\r\n\r\n        if (typeof entry !== "boolean") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'keyboardSupport\' option must be a boolean.");\r\n        }\r\n    }\r\n\r\n    function testDocumentElement(parsed, entry) {\r\n        // This is an advanced option. Passed values are used without validation.\r\n        parsed.documentElement = entry;\r\n    }\r\n\r\n    function testCssPrefix(parsed, entry) {\r\n        if (typeof entry !== "string" && entry !== false) {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'cssPrefix\' must be a string or `false`.");\r\n        }\r\n\r\n        parsed.cssPrefix = entry;\r\n    }\r\n\r\n    function testCssClasses(parsed, entry) {\r\n        if (typeof entry !== "object") {\r\n            throw new Error("noUiSlider (" + VERSION + "): \'cssClasses\' must be an object.");\r\n        }\r\n\r\n        if (typeof parsed.cssPrefix === "string") {\r\n            parsed.cssClasses = {};\r\n\r\n            for (var key in entry) {\r\n                if (!entry.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n\r\n                parsed.cssClasses[key] = parsed.cssPrefix + entry[key];\r\n            }\r\n        } else {\r\n            parsed.cssClasses = entry;\r\n        }\r\n    }\r\n\r\n    // Test all developer settings and parse to assumption-safe values.\r\n    function testOptions(options) {\r\n        // To prove a fix for #537, freeze options here.\r\n        // If the object is modified, an error will be thrown.\r\n        // Object.freeze(options);\r\n\r\n        var parsed = {\r\n            margin: 0,\r\n            limit: 0,\r\n            padding: 0,\r\n            animate: true,\r\n            animationDuration: 300,\r\n            ariaFormat: defaultFormatter,\r\n            format: defaultFormatter\r\n        };\r\n\r\n        // Tests are executed in the order they are presented here.\r\n        var tests = {\r\n            step: { r: false, t: testStep },\r\n            start: { r: true, t: testStart },\r\n            connect: { r: true, t: testConnect },\r\n            direction: { r: true, t: testDirection },\r\n            snap: { r: false, t: testSnap },\r\n            animate: { r: false, t: testAnimate },\r\n            animationDuration: { r: false, t: testAnimationDuration },\r\n            range: { r: true, t: testRange },\r\n            orientation: { r: false, t: testOrientation },\r\n            margin: { r: false, t: testMargin },\r\n            limit: { r: false, t: testLimit },\r\n            padding: { r: false, t: testPadding },\r\n            behaviour: { r: true, t: testBehaviour },\r\n            ariaFormat: { r: false, t: testAriaFormat },\r\n            format: { r: false, t: testFormat },\r\n            tooltips: { r: false, t: testTooltips },\r\n            keyboardSupport: { r: true, t: testKeyboardSupport },\r\n            documentElement: { r: false, t: testDocumentElement },\r\n            cssPrefix: { r: true, t: testCssPrefix },\r\n            cssClasses: { r: true, t: testCssClasses }\r\n        };\r\n\r\n        var defaults = {\r\n            connect: false,\r\n            direction: "ltr",\r\n            behaviour: "tap",\r\n            orientation: "horizontal",\r\n            keyboardSupport: true,\r\n            cssPrefix: "noUi-",\r\n            cssClasses: {\r\n                target: "target",\r\n                base: "base",\r\n                origin: "origin",\r\n                handle: "handle",\r\n                handleLower: "handle-lower",\r\n                handleUpper: "handle-upper",\r\n                touchArea: "touch-area",\r\n                horizontal: "horizontal",\r\n                vertical: "vertical",\r\n                background: "background",\r\n                connect: "connect",\r\n                connects: "connects",\r\n                ltr: "ltr",\r\n                rtl: "rtl",\r\n                draggable: "draggable",\r\n                drag: "state-drag",\r\n                tap: "state-tap",\r\n                active: "active",\r\n                tooltip: "tooltip",\r\n                pips: "pips",\r\n                pipsHorizontal: "pips-horizontal",\r\n                pipsVertical: "pips-vertical",\r\n                marker: "marker",\r\n                markerHorizontal: "marker-horizontal",\r\n                markerVertical: "marker-vertical",\r\n                markerNormal: "marker-normal",\r\n                markerLarge: "marker-large",\r\n                markerSub: "marker-sub",\r\n                value: "value",\r\n                valueHorizontal: "value-horizontal",\r\n                valueVertical: "value-vertical",\r\n                valueNormal: "value-normal",\r\n                valueLarge: "value-large",\r\n                valueSub: "value-sub"\r\n            }\r\n        };\r\n\r\n        // AriaFormat defaults to regular format, if any.\r\n        if (options.format && !options.ariaFormat) {\r\n            options.ariaFormat = options.format;\r\n        }\r\n\r\n        // Run all options through a testing mechanism to ensure correct\r\n        // input. It should be noted that options might get modified to\r\n        // be handled properly. E.g. wrapping integers in arrays.\r\n        Object.keys(tests).forEach(function(name) {\r\n            // If the option isn\'t set, but it is required, throw an error.\r\n            if (!isSet(options[name]) && defaults[name] === undefined) {\r\n                if (tests[name].r) {\r\n                    throw new Error("noUiSlider (" + VERSION + "): \'" + name + "\' is required.");\r\n                }\r\n\r\n                return true;\r\n            }\r\n\r\n            tests[name].t(parsed, !isSet(options[name]) ? defaults[name] : options[name]);\r\n        });\r\n\r\n        // Forward pips options\r\n        parsed.pips = options.pips;\r\n\r\n        // All recent browsers accept unprefixed transform.\r\n        // We need -ms- for IE9 and -webkit- for older Android;\r\n        // Assume use of -webkit- if unprefixed and -ms- are not supported.\r\n        // https://caniuse.com/#feat=transforms2d\r\n        var d = document.createElement("div");\r\n        var msPrefix = d.style.msTransform !== undefined;\r\n        var noPrefix = d.style.transform !== undefined;\r\n\r\n        parsed.transformRule = noPrefix ? "transform" : msPrefix ? "msTransform" : "webkitTransform";\r\n\r\n        // Pips don\'t move, so we can place them using left/top.\r\n        var styles = [["left", "top"], ["right", "bottom"]];\r\n\r\n        parsed.style = styles[parsed.dir][parsed.ort];\r\n\r\n        return parsed;\r\n    }\r\n\r\n    //endregion\r\n\r\n    function scope(target, options, originalOptions) {\r\n        var actions = getActions();\r\n        var supportsTouchActionNone = getSupportsTouchActionNone();\r\n        var supportsPassive = supportsTouchActionNone && getSupportsPassive();\r\n\r\n        // All variables local to \'scope\' are prefixed with \'scope_\'\r\n\r\n        // Slider DOM Nodes\r\n        var scope_Target = target;\r\n        var scope_Base;\r\n        var scope_Handles;\r\n        var scope_Connects;\r\n        var scope_Pips;\r\n        var scope_Tooltips;\r\n\r\n        // Slider state values\r\n        var scope_Spectrum = options.spectrum;\r\n        var scope_Values = [];\r\n        var scope_Locations = [];\r\n        var scope_HandleNumbers = [];\r\n        var scope_ActiveHandlesCount = 0;\r\n        var scope_Events = {};\r\n\r\n        // Exposed API\r\n        var scope_Self;\r\n\r\n        // Document Nodes\r\n        var scope_Document = target.ownerDocument;\r\n        var scope_DocumentElement = options.documentElement || scope_Document.documentElement;\r\n        var scope_Body = scope_Document.body;\r\n\r\n        // Pips constants\r\n        var PIPS_NONE = -1;\r\n        var PIPS_NO_VALUE = 0;\r\n        var PIPS_LARGE_VALUE = 1;\r\n        var PIPS_SMALL_VALUE = 2;\r\n\r\n        // For horizontal sliders in standard ltr documents,\r\n        // make .noUi-origin overflow to the left so the document doesn\'t scroll.\r\n        var scope_DirOffset = scope_Document.dir === "rtl" || options.ort === 1 ? 0 : 100;\r\n\r\n        // Creates a node, adds it to target, returns the new node.\r\n        function addNodeTo(addTarget, className) {\r\n            var div = scope_Document.createElement("div");\r\n\r\n            if (className) {\r\n                addClass(div, className);\r\n            }\r\n\r\n            addTarget.appendChild(div);\r\n\r\n            return div;\r\n        }\r\n\r\n        // Append a origin to the base\r\n        function addOrigin(base, handleNumber) {\r\n            var origin = addNodeTo(base, options.cssClasses.origin);\r\n            var handle = addNodeTo(origin, options.cssClasses.handle);\r\n\r\n            addNodeTo(handle, options.cssClasses.touchArea);\r\n\r\n            handle.setAttribute("data-handle", handleNumber);\r\n\r\n            if (options.keyboardSupport) {\r\n                // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n                // 0 = focusable and reachable\r\n                handle.setAttribute("tabindex", "0");\r\n                handle.addEventListener("keydown", function(event) {\r\n                    return eventKeydown(event, handleNumber);\r\n                });\r\n            }\r\n\r\n            handle.setAttribute("role", "slider");\r\n            handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal");\r\n\r\n            if (handleNumber === 0) {\r\n                addClass(handle, options.cssClasses.handleLower);\r\n            } else if (handleNumber === options.handles - 1) {\r\n                addClass(handle, options.cssClasses.handleUpper);\r\n            }\r\n\r\n            return origin;\r\n        }\r\n\r\n        // Insert nodes for connect elements\r\n        function addConnect(base, add) {\r\n            if (!add) {\r\n                return false;\r\n            }\r\n\r\n            return addNodeTo(base, options.cssClasses.connect);\r\n        }\r\n\r\n        // Add handles to the slider base.\r\n        function addElements(connectOptions, base) {\r\n            var connectBase = addNodeTo(base, options.cssClasses.connects);\r\n\r\n            scope_Handles = [];\r\n            scope_Connects = [];\r\n\r\n            scope_Connects.push(addConnect(connectBase, connectOptions[0]));\r\n\r\n            // [::::O====O====O====]\r\n            // connectOptions = [0, 1, 1, 1]\r\n\r\n            for (var i = 0; i < options.handles; i++) {\r\n                // Keep a list of all added handles.\r\n                scope_Handles.push(addOrigin(base, i));\r\n                scope_HandleNumbers[i] = i;\r\n                scope_Connects.push(addConnect(connectBase, connectOptions[i + 1]));\r\n            }\r\n        }\r\n\r\n        // Initialize a single slider.\r\n        function addSlider(addTarget) {\r\n            // Apply classes and data to the target.\r\n            addClass(addTarget, options.cssClasses.target);\r\n\r\n            if (options.dir === 0) {\r\n                addClass(addTarget, options.cssClasses.ltr);\r\n            } else {\r\n                addClass(addTarget, options.cssClasses.rtl);\r\n            }\r\n\r\n            if (options.ort === 0) {\r\n                addClass(addTarget, options.cssClasses.horizontal);\r\n            } else {\r\n                addClass(addTarget, options.cssClasses.vertical);\r\n            }\r\n\r\n            return addNodeTo(addTarget, options.cssClasses.base);\r\n        }\r\n\r\n        function addTooltip(handle, handleNumber) {\r\n            if (!options.tooltips[handleNumber]) {\r\n                return false;\r\n            }\r\n\r\n            return addNodeTo(handle.firstChild, options.cssClasses.tooltip);\r\n        }\r\n\r\n        function isSliderDisabled() {\r\n            return scope_Target.hasAttribute("disabled");\r\n        }\r\n\r\n        // Disable the slider dragging if any handle is disabled\r\n        function isHandleDisabled(handleNumber) {\r\n            var handleOrigin = scope_Handles[handleNumber];\r\n            return handleOrigin.hasAttribute("disabled");\r\n        }\r\n\r\n        function removeTooltips() {\r\n            if (scope_Tooltips) {\r\n                removeEvent("update.tooltips");\r\n                scope_Tooltips.forEach(function(tooltip) {\r\n                    if (tooltip) {\r\n                        removeElement(tooltip);\r\n                    }\r\n                });\r\n                scope_Tooltips = null;\r\n            }\r\n        }\r\n\r\n        // The tooltips option is a shorthand for using the \'update\' event.\r\n        function tooltips() {\r\n            removeTooltips();\r\n\r\n            // Tooltips are added with options.tooltips in original order.\r\n            scope_Tooltips = scope_Handles.map(addTooltip);\r\n\r\n            bindEvent("update.tooltips", function(values, handleNumber, unencoded) {\r\n                if (!scope_Tooltips[handleNumber]) {\r\n                    return;\r\n                }\r\n\r\n                var formattedValue = values[handleNumber];\r\n\r\n                if (options.tooltips[handleNumber] !== true) {\r\n                    formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);\r\n                }\r\n\r\n                scope_Tooltips[handleNumber].innerHTML = formattedValue;\r\n            });\r\n        }\r\n\r\n        function aria() {\r\n            bindEvent("update", function(values, handleNumber, unencoded, tap, positions) {\r\n                // Update Aria Values for all handles, as a change in one changes min and max values for the next.\r\n                scope_HandleNumbers.forEach(function(index) {\r\n                    var handle = scope_Handles[index];\r\n\r\n                    var min = checkHandlePosition(scope_Locations, index, 0, true, true, true);\r\n                    var max = checkHandlePosition(scope_Locations, index, 100, true, true, true);\r\n\r\n                    var now = positions[index];\r\n\r\n                    // Formatted value for display\r\n                    var text = options.ariaFormat.to(unencoded[index]);\r\n\r\n                    // Map to slider range values\r\n                    min = scope_Spectrum.fromStepping(min).toFixed(1);\r\n                    max = scope_Spectrum.fromStepping(max).toFixed(1);\r\n                    now = scope_Spectrum.fromStepping(now).toFixed(1);\r\n\r\n                    handle.children[0].setAttribute("aria-valuemin", min);\r\n                    handle.children[0].setAttribute("aria-valuemax", max);\r\n                    handle.children[0].setAttribute("aria-valuenow", now);\r\n                    handle.children[0].setAttribute("aria-valuetext", text);\r\n                });\r\n            });\r\n        }\r\n\r\n        function getGroup(mode, values, stepped) {\r\n            // Use the range.\r\n            if (mode === "range" || mode === "steps") {\r\n                return scope_Spectrum.xVal;\r\n            }\r\n\r\n            if (mode === "count") {\r\n                if (values < 2) {\r\n                    throw new Error("noUiSlider (" + VERSION + "): \'values\' (>= 2) required for mode \'count\'.");\r\n                }\r\n\r\n                // Divide 0 - 100 in \'count\' parts.\r\n                var interval = values - 1;\r\n                var spread = 100 / interval;\r\n\r\n                values = [];\r\n\r\n                // List these parts and have them handled as \'positions\'.\r\n                while (interval--) {\r\n                    values[interval] = interval * spread;\r\n                }\r\n\r\n                values.push(100);\r\n\r\n                mode = "positions";\r\n            }\r\n\r\n            if (mode === "positions") {\r\n                // Map all percentages to on-range values.\r\n                return values.map(function(value) {\r\n                    return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value);\r\n                });\r\n            }\r\n\r\n            if (mode === "values") {\r\n                // If the value must be stepped, it needs to be converted to a percentage first.\r\n                if (stepped) {\r\n                    return values.map(function(value) {\r\n                        // Convert to percentage, apply step, return to value.\r\n                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)));\r\n                    });\r\n                }\r\n\r\n                // Otherwise, we can simply use the values.\r\n                return values;\r\n            }\r\n        }\r\n\r\n        function generateSpread(density, mode, group) {\r\n            function safeIncrement(value, increment) {\r\n                // Avoid floating point variance by dropping the smallest decimal places.\r\n                return (value + increment).toFixed(7) / 1;\r\n            }\r\n\r\n            var indexes = {};\r\n            var firstInRange = scope_Spectrum.xVal[0];\r\n            var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1];\r\n            var ignoreFirst = false;\r\n            var ignoreLast = false;\r\n            var prevPct = 0;\r\n\r\n            // Create a copy of the group, sort it and filter away all duplicates.\r\n            group = unique(\r\n                group.slice().sort(function(a, b) {\r\n                    return a - b;\r\n                })\r\n            );\r\n\r\n            // Make sure the range starts with the first element.\r\n            if (group[0] !== firstInRange) {\r\n                group.unshift(firstInRange);\r\n                ignoreFirst = true;\r\n            }\r\n\r\n            // Likewise for the last one.\r\n            if (group[group.length - 1] !== lastInRange) {\r\n                group.push(lastInRange);\r\n                ignoreLast = true;\r\n            }\r\n\r\n            group.forEach(function(current, index) {\r\n                // Get the current step and the lower + upper positions.\r\n                var step;\r\n                var i;\r\n                var q;\r\n                var low = current;\r\n                var high = group[index + 1];\r\n                var newPct;\r\n                var pctDifference;\r\n                var pctPos;\r\n                var type;\r\n                var steps;\r\n                var realSteps;\r\n                var stepSize;\r\n                var isSteps = mode === "steps";\r\n\r\n                // When using \'steps\' mode, use the provided steps.\r\n                // Otherwise, we\'ll step on to the next subrange.\r\n                if (isSteps) {\r\n                    step = scope_Spectrum.xNumSteps[index];\r\n                }\r\n\r\n                // Default to a \'full\' step.\r\n                if (!step) {\r\n                    step = high - low;\r\n                }\r\n\r\n                // Low can be 0, so test for false. If high is undefined,\r\n                // we are at the last subrange. Index 0 is already handled.\r\n                if (low === false || high === undefined) {\r\n                    return;\r\n                }\r\n\r\n                // Make sure step isn\'t 0, which would cause an infinite loop (#654)\r\n                step = Math.max(step, 0.0000001);\r\n\r\n                // Find all steps in the subrange.\r\n                for (i = low; i <= high; i = safeIncrement(i, step)) {\r\n                    // Get the percentage value for the current step,\r\n                    // calculate the size for the subrange.\r\n                    newPct = scope_Spectrum.toStepping(i);\r\n                    pctDifference = newPct - prevPct;\r\n\r\n                    steps = pctDifference / density;\r\n                    realSteps = Math.round(steps);\r\n\r\n                    // This ratio represents the amount of percentage-space a point indicates.\r\n                    // For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-divided.\r\n                    // Round the percentage offset to an even number, then divide by two\r\n                    // to spread the offset on both sides of the range.\r\n                    stepSize = pctDifference / realSteps;\r\n\r\n                    // Divide all points evenly, adding the correct number to this subrange.\r\n                    // Run up to <= so that 100% gets a point, event if ignoreLast is set.\r\n                    for (q = 1; q <= realSteps; q += 1) {\r\n                        // The ratio between the rounded value and the actual size might be ~1% off.\r\n                        // Correct the percentage offset by the number of points\r\n                        // per subrange. density = 1 will result in 100 points on the\r\n                        // full range, 2 for 50, 4 for 25, etc.\r\n                        pctPos = prevPct + q * stepSize;\r\n                        indexes[pctPos.toFixed(5)] = [scope_Spectrum.fromStepping(pctPos), 0];\r\n                    }\r\n\r\n                    // Determine the point type.\r\n                    type = group.indexOf(i) > -1 ? PIPS_LARGE_VALUE : isSteps ? PIPS_SMALL_VALUE : PIPS_NO_VALUE;\r\n\r\n                    // Enforce the \'ignoreFirst\' option by overwriting the type for 0.\r\n                    if (!index && ignoreFirst) {\r\n                        type = 0;\r\n                    }\r\n\r\n                    if (!(i === high && ignoreLast)) {\r\n                        // Mark the \'type\' of this point. 0 = plain, 1 = real value, 2 = step value.\r\n                        indexes[newPct.toFixed(5)] = [i, type];\r\n                    }\r\n\r\n                    // Update the percentage count.\r\n                    prevPct = newPct;\r\n                }\r\n            });\r\n\r\n            return indexes;\r\n        }\r\n\r\n        function addMarking(spread, filterFunc, formatter) {\r\n            var element = scope_Document.createElement("div");\r\n\r\n            var valueSizeClasses = [];\r\n            valueSizeClasses[PIPS_NO_VALUE] = options.cssClasses.valueNormal;\r\n            valueSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.valueLarge;\r\n            valueSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.valueSub;\r\n\r\n            var markerSizeClasses = [];\r\n            markerSizeClasses[PIPS_NO_VALUE] = options.cssClasses.markerNormal;\r\n            markerSizeClasses[PIPS_LARGE_VALUE] = options.cssClasses.markerLarge;\r\n            markerSizeClasses[PIPS_SMALL_VALUE] = options.cssClasses.markerSub;\r\n\r\n            var valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical];\r\n            var markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];\r\n\r\n            addClass(element, options.cssClasses.pips);\r\n            addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);\r\n\r\n            function getClasses(type, source) {\r\n                var a = source === options.cssClasses.value;\r\n                var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;\r\n                var sizeClasses = a ? valueSizeClasses : markerSizeClasses;\r\n\r\n                return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type];\r\n            }\r\n\r\n            function addSpread(offset, value, type) {\r\n                // Apply the filter function, if it is set.\r\n                type = filterFunc ? filterFunc(value, type) : type;\r\n\r\n                if (type === PIPS_NONE) {\r\n                    return;\r\n                }\r\n\r\n                // Add a marker for every point\r\n                var node = addNodeTo(element, false);\r\n                node.className = getClasses(type, options.cssClasses.marker);\r\n                node.style[options.style] = offset + "%";\r\n\r\n                // Values are only appended for points marked \'1\' or \'2\'.\r\n                if (type > PIPS_NO_VALUE) {\r\n                    node = addNodeTo(element, false);\r\n                    node.className = getClasses(type, options.cssClasses.value);\r\n                    node.setAttribute("data-value", value);\r\n                    node.style[options.style] = offset + "%";\r\n                    node.innerHTML = formatter.to(value);\r\n                }\r\n            }\r\n\r\n            // Append all points.\r\n            Object.keys(spread).forEach(function(offset) {\r\n                addSpread(offset, spread[offset][0], spread[offset][1]);\r\n            });\r\n\r\n            return element;\r\n        }\r\n\r\n        function removePips() {\r\n            if (scope_Pips) {\r\n                removeElement(scope_Pips);\r\n                scope_Pips = null;\r\n            }\r\n        }\r\n\r\n        function pips(grid) {\r\n            // Fix #669\r\n            removePips();\r\n\r\n            var mode = grid.mode;\r\n            var density = grid.density || 1;\r\n            var filter = grid.filter || false;\r\n            var values = grid.values || false;\r\n            var stepped = grid.stepped || false;\r\n            var group = getGroup(mode, values, stepped);\r\n            var spread = generateSpread(density, mode, group);\r\n            var format = grid.format || {\r\n                to: Math.round\r\n            };\r\n\r\n            scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format));\r\n\r\n            return scope_Pips;\r\n        }\r\n\r\n        // Shorthand for base dimensions.\r\n        function baseSize() {\r\n            var rect = scope_Base.getBoundingClientRect();\r\n            var alt = "offset" + ["Width", "Height"][options.ort];\r\n            return options.ort === 0 ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt];\r\n        }\r\n\r\n        // Handler for attaching events trough a proxy.\r\n        function attachEvent(events, element, callback, data) {\r\n            // This function can be used to \'filter\' events to the slider.\r\n            // element is a node, not a nodeList\r\n\r\n            var method = function(e) {\r\n                e = fixEvent(e, data.pageOffset, data.target || element);\r\n\r\n                // fixEvent returns false if this event has a different target\r\n                // when handling (multi-) touch events;\r\n                if (!e) {\r\n                    return false;\r\n                }\r\n\r\n                // doNotReject is passed by all end events to make sure released touches\r\n                // are not rejected, leaving the slider "stuck" to the cursor;\r\n                if (isSliderDisabled() && !data.doNotReject) {\r\n                    return false;\r\n                }\r\n\r\n                // Stop if an active \'tap\' transition is taking place.\r\n                if (hasClass(scope_Target, options.cssClasses.tap) && !data.doNotReject) {\r\n                    return false;\r\n                }\r\n\r\n                // Ignore right or middle clicks on start #454\r\n                if (events === actions.start && e.buttons !== undefined && e.buttons > 1) {\r\n                    return false;\r\n                }\r\n\r\n                // Ignore right or middle clicks on start #454\r\n                if (data.hover && e.buttons) {\r\n                    return false;\r\n                }\r\n\r\n                // \'supportsPassive\' is only true if a browser also supports touch-action: none in CSS.\r\n                // iOS safari does not, so it doesn\'t get to benefit from passive scrolling. iOS does support\r\n                // touch-action: manipulation, but that allows panning, which breaks\r\n                // sliders after zooming/on non-responsive pages.\r\n                // See: https://bugs.webkit.org/show_bug.cgi?id=133112\r\n                if (!supportsPassive) {\r\n                    e.preventDefault();\r\n                }\r\n\r\n                e.calcPoint = e.points[options.ort];\r\n\r\n                // Call the event handler with the event [ and additional data ].\r\n                callback(e, data);\r\n            };\r\n\r\n            var methods = [];\r\n\r\n            // Bind a closure on the target for every event type.\r\n            events.split(" ").forEach(function(eventName) {\r\n                element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);\r\n                methods.push([eventName, method]);\r\n            });\r\n\r\n            return methods;\r\n        }\r\n\r\n        // Provide a clean event with standardized offset values.\r\n        function fixEvent(e, pageOffset, eventTarget) {\r\n            // Filter the event to register the type, which can be\r\n            // touch, mouse or pointer. Offset changes need to be\r\n            // made on an event specific basis.\r\n            var touch = e.type.indexOf("touch") === 0;\r\n            var mouse = e.type.indexOf("mouse") === 0;\r\n            var pointer = e.type.indexOf("pointer") === 0;\r\n\r\n            var x;\r\n            var y;\r\n\r\n            // IE10 implemented pointer events with a prefix;\r\n            if (e.type.indexOf("MSPointer") === 0) {\r\n                pointer = true;\r\n            }\r\n\r\n            // The only thing one handle should be concerned about is the touches that originated on top of it.\r\n            if (touch) {\r\n                // Returns true if a touch originated on the target.\r\n                var isTouchOnTarget = function(checkTouch) {\r\n                    return checkTouch.target === eventTarget || eventTarget.contains(checkTouch.target);\r\n                };\r\n\r\n                // In the case of touchstart events, we need to make sure there is still no more than one\r\n                // touch on the target so we look amongst all touches.\r\n                if (e.type === "touchstart") {\r\n                    var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);\r\n\r\n                    // Do not support more than one touch per handle.\r\n                    if (targetTouches.length > 1) {\r\n                        return false;\r\n                    }\r\n\r\n                    x = targetTouches[0].pageX;\r\n                    y = targetTouches[0].pageY;\r\n                } else {\r\n                    // In the other cases, find on changedTouches is enough.\r\n                    var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);\r\n\r\n                    // Cancel if the target touch has not moved.\r\n                    if (!targetTouch) {\r\n                        return false;\r\n                    }\r\n\r\n                    x = targetTouch.pageX;\r\n                    y = targetTouch.pageY;\r\n                }\r\n            }\r\n\r\n            pageOffset = pageOffset || getPageOffset(scope_Document);\r\n\r\n            if (mouse || pointer) {\r\n                x = e.clientX + pageOffset.x;\r\n                y = e.clientY + pageOffset.y;\r\n            }\r\n\r\n            e.pageOffset = pageOffset;\r\n            e.points = [x, y];\r\n            e.cursor = mouse || pointer; // Fix #435\r\n\r\n            return e;\r\n        }\r\n\r\n        // Translate a coordinate in the document to a percentage on the slider\r\n        function calcPointToPercentage(calcPoint) {\r\n            var location = calcPoint - offset(scope_Base, options.ort);\r\n            var proposal = (location * 100) / baseSize();\r\n\r\n            // Clamp proposal between 0% and 100%\r\n            // Out-of-bound coordinates may occur when .noUi-base pseudo-elements\r\n            // are used (e.g. contained handles feature)\r\n            proposal = limit(proposal);\r\n\r\n            return options.dir ? 100 - proposal : proposal;\r\n        }\r\n\r\n        // Find handle closest to a certain percentage on the slider\r\n        function getClosestHandle(proposal) {\r\n            var closest = 100;\r\n            var handleNumber = false;\r\n\r\n            scope_Handles.forEach(function(handle, index) {\r\n                // Disabled handles are ignored\r\n                if (isHandleDisabled(index)) {\r\n                    return;\r\n                }\r\n\r\n                var pos = Math.abs(scope_Locations[index] - proposal);\r\n\r\n                if (pos < closest || (pos === 100 && closest === 100)) {\r\n                    handleNumber = index;\r\n                    closest = pos;\r\n                }\r\n            });\r\n\r\n            return handleNumber;\r\n        }\r\n\r\n        // Fire \'end\' when a mouse or pen leaves the document.\r\n        function documentLeave(event, data) {\r\n            if (event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null) {\r\n                eventEnd(event, data);\r\n            }\r\n        }\r\n\r\n        // Handle movement on document for handle and range drag.\r\n        function eventMove(event, data) {\r\n            // Fix #498\r\n            // Check value of .buttons in \'start\' to work around a bug in IE10 mobile (data.buttonsProperty).\r\n            // https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\r\n            // IE9 has .buttons and .which zero on mousemove.\r\n            // Firefox breaks the spec MDN defines.\r\n            if (navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0) {\r\n                return eventEnd(event, data);\r\n            }\r\n\r\n            // Check if we are moving up or down\r\n            var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);\r\n\r\n            // Convert the movement into a percentage of the slider width/height\r\n            var proposal = (movement * 100) / data.baseSize;\r\n\r\n            moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);\r\n        }\r\n\r\n        // Unbind move events on document, call callbacks.\r\n        function eventEnd(event, data) {\r\n            // The handle is no longer active, so remove the class.\r\n            if (data.handle) {\r\n                removeClass(data.handle, options.cssClasses.active);\r\n                scope_ActiveHandlesCount -= 1;\r\n            }\r\n\r\n            // Unbind the move and end events, which are added on \'start\'.\r\n            data.listeners.forEach(function(c) {\r\n                scope_DocumentElement.removeEventListener(c[0], c[1]);\r\n            });\r\n\r\n            if (scope_ActiveHandlesCount === 0) {\r\n                // Remove dragging class.\r\n                removeClass(scope_Target, options.cssClasses.drag);\r\n                setZindex();\r\n\r\n                // Remove cursor styles and text-selection events bound to the body.\r\n                if (event.cursor) {\r\n                    scope_Body.style.cursor = "";\r\n                    scope_Body.removeEventListener("selectstart", preventDefault);\r\n                }\r\n            }\r\n\r\n            data.handleNumbers.forEach(function(handleNumber) {\r\n                fireEvent("change", handleNumber);\r\n                fireEvent("set", handleNumber);\r\n                fireEvent("end", handleNumber);\r\n            });\r\n        }\r\n\r\n        // Bind move events on document.\r\n        function eventStart(event, data) {\r\n            // Ignore event if any handle is disabled\r\n            if (data.handleNumbers.some(isHandleDisabled)) {\r\n                return false;\r\n            }\r\n\r\n            var handle;\r\n\r\n            if (data.handleNumbers.length === 1) {\r\n                var handleOrigin = scope_Handles[data.handleNumbers[0]];\r\n\r\n                handle = handleOrigin.children[0];\r\n                scope_ActiveHandlesCount += 1;\r\n\r\n                // Mark the handle as \'active\' so it can be styled.\r\n                addClass(handle, options.cssClasses.active);\r\n            }\r\n\r\n            // A drag should never propagate up to the \'tap\' event.\r\n            event.stopPropagation();\r\n\r\n            // Record the event listeners.\r\n            var listeners = [];\r\n\r\n            // Attach the move and end events.\r\n            var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {\r\n                // The event target has changed so we need to propagate the original one so that we keep\r\n                // relying on it to extract target touches.\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                startCalcPoint: event.calcPoint,\r\n                baseSize: baseSize(),\r\n                pageOffset: event.pageOffset,\r\n                handleNumbers: data.handleNumbers,\r\n                buttonsProperty: event.buttons,\r\n                locations: scope_Locations.slice()\r\n            });\r\n\r\n            var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                doNotReject: true,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n\r\n            var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {\r\n                target: event.target,\r\n                handle: handle,\r\n                listeners: listeners,\r\n                doNotReject: true,\r\n                handleNumbers: data.handleNumbers\r\n            });\r\n\r\n            // We want to make sure we pushed the listeners in the listener list rather than creating\r\n            // a new one as it has already been passed to the event handlers.\r\n            listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));\r\n\r\n            // Text selection isn\'t an issue on touch devices,\r\n            // so adding cursor styles can be skipped.\r\n            if (event.cursor) {\r\n                // Prevent the \'I\' cursor and extend the range-drag cursor.\r\n                scope_Body.style.cursor = getComputedStyle(event.target).cursor;\r\n\r\n                // Mark the target with a dragging state.\r\n                if (scope_Handles.length > 1) {\r\n                    addClass(scope_Target, options.cssClasses.drag);\r\n                }\r\n\r\n                // Prevent text selection when dragging the handles.\r\n                // In noUiSlider <= 9.2.0, this was handled by calling preventDefault on mouse/touch start/move,\r\n                // which is scroll blocking. The selectstart event is supported by FireFox starting from version 52,\r\n                // meaning the only holdout is iOS Safari. This doesn\'t matter: text selection isn\'t triggered there.\r\n                // The \'cursor\' flag is false.\r\n                // See: http://caniuse.com/#search=selectstart\r\n                scope_Body.addEventListener("selectstart", preventDefault, false);\r\n            }\r\n\r\n            data.handleNumbers.forEach(function(handleNumber) {\r\n                fireEvent("start", handleNumber);\r\n            });\r\n        }\r\n\r\n        // Move closest handle to tapped location.\r\n        function eventTap(event) {\r\n            // The tap event shouldn\'t propagate up\r\n            event.stopPropagation();\r\n\r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n            var handleNumber = getClosestHandle(proposal);\r\n\r\n            // Tackle the case that all handles are \'disabled\'.\r\n            if (handleNumber === false) {\r\n                return false;\r\n            }\r\n\r\n            // Flag the slider as it is now in a transitional state.\r\n            // Transition takes a configurable amount of ms (default 300). Re-enable the slider after that.\r\n            if (!options.events.snap) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n\r\n            setHandle(handleNumber, proposal, true, true);\r\n\r\n            setZindex();\r\n\r\n            fireEvent("slide", handleNumber, true);\r\n            fireEvent("update", handleNumber, true);\r\n            fireEvent("change", handleNumber, true);\r\n            fireEvent("set", handleNumber, true);\r\n\r\n            if (options.events.snap) {\r\n                eventStart(event, { handleNumbers: [handleNumber] });\r\n            }\r\n        }\r\n\r\n        // Fires a \'hover\' event for a hovered mouse/pen position.\r\n        function eventHover(event) {\r\n            var proposal = calcPointToPercentage(event.calcPoint);\r\n\r\n            var to = scope_Spectrum.getStep(proposal);\r\n            var value = scope_Spectrum.fromStepping(to);\r\n\r\n            Object.keys(scope_Events).forEach(function(targetEvent) {\r\n                if ("hover" === targetEvent.split(".")[0]) {\r\n                    scope_Events[targetEvent].forEach(function(callback) {\r\n                        callback.call(scope_Self, value);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        // Handles keydown on focused handles\r\n        // Don\'t move the document when pressing arrow keys on focused handles\r\n        function eventKeydown(event, handleNumber) {\r\n            if (isSliderDisabled() || isHandleDisabled(handleNumber)) {\r\n                return false;\r\n            }\r\n\r\n            var horizontalKeys = ["Left", "Right"];\r\n            var verticalKeys = ["Down", "Up"];\r\n\r\n            if (options.dir && !options.ort) {\r\n                // On an right-to-left slider, the left and right keys act inverted\r\n                horizontalKeys.reverse();\r\n            } else if (options.ort && !options.dir) {\r\n                // On a top-to-bottom slider, the up and down keys act inverted\r\n                verticalKeys.reverse();\r\n            }\r\n\r\n            // Strip "Arrow" for IE compatibility. https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\r\n            var key = event.key.replace("Arrow", "");\r\n            var isDown = key === verticalKeys[0] || key === horizontalKeys[0];\r\n            var isUp = key === verticalKeys[1] || key === horizontalKeys[1];\r\n\r\n            if (!isDown && !isUp) {\r\n                return true;\r\n            }\r\n\r\n            event.preventDefault();\r\n\r\n            var direction = isDown ? 0 : 1;\r\n            var steps = getNextStepsForHandle(handleNumber);\r\n            var step = steps[direction];\r\n\r\n            // At the edge of a slider, do nothing\r\n            if (step === null) {\r\n                return false;\r\n            }\r\n\r\n            // No step set, use the default of 10% of the sub-range\r\n            if (step === false) {\r\n                step = scope_Spectrum.getDefaultStep(scope_Locations[handleNumber], isDown, 10);\r\n            }\r\n\r\n            // Step over zero-length ranges (#948);\r\n            step = Math.max(step, 0.0000001);\r\n\r\n            // Decrement for down steps\r\n            step = (isDown ? -1 : 1) * step;\r\n\r\n            valueSetHandle(handleNumber, scope_Values[handleNumber] + step, true);\r\n\r\n            return false;\r\n        }\r\n\r\n        // Attach events to several slider parts.\r\n        function bindSliderEvents(behaviour) {\r\n            // Attach the standard drag event to the handles.\r\n            if (!behaviour.fixed) {\r\n                scope_Handles.forEach(function(handle, index) {\r\n                    // These events are only bound to the visual handle\r\n                    // element, not the \'real\' origin element.\r\n                    attachEvent(actions.start, handle.children[0], eventStart, {\r\n                        handleNumbers: [index]\r\n                    });\r\n                });\r\n            }\r\n\r\n            // Attach the tap event to the slider base.\r\n            if (behaviour.tap) {\r\n                attachEvent(actions.start, scope_Base, eventTap, {});\r\n            }\r\n\r\n            // Fire hover events\r\n            if (behaviour.hover) {\r\n                attachEvent(actions.move, scope_Base, eventHover, {\r\n                    hover: true\r\n                });\r\n            }\r\n\r\n            // Make the range draggable.\r\n            if (behaviour.drag) {\r\n                scope_Connects.forEach(function(connect, index) {\r\n                    if (connect === false || index === 0 || index === scope_Connects.length - 1) {\r\n                        return;\r\n                    }\r\n\r\n                    var handleBefore = scope_Handles[index - 1];\r\n                    var handleAfter = scope_Handles[index];\r\n                    var eventHolders = [connect];\r\n\r\n                    addClass(connect, options.cssClasses.draggable);\r\n\r\n                    // When the range is fixed, the entire range can\r\n                    // be dragged by the handles. The handle in the first\r\n                    // origin will propagate the start event upward,\r\n                    // but it needs to be bound manually on the other.\r\n                    if (behaviour.fixed) {\r\n                        eventHolders.push(handleBefore.children[0]);\r\n                        eventHolders.push(handleAfter.children[0]);\r\n                    }\r\n\r\n                    eventHolders.forEach(function(eventHolder) {\r\n                        attachEvent(actions.start, eventHolder, eventStart, {\r\n                            handles: [handleBefore, handleAfter],\r\n                            handleNumbers: [index - 1, index]\r\n                        });\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        // Attach an event to this slider, possibly including a namespace\r\n        function bindEvent(namespacedEvent, callback) {\r\n            scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\r\n            scope_Events[namespacedEvent].push(callback);\r\n\r\n            // If the event bound is \'update,\' fire it immediately for all handles.\r\n            if (namespacedEvent.split(".")[0] === "update") {\r\n                scope_Handles.forEach(function(a, index) {\r\n                    fireEvent("update", index);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Undo attachment of event\r\n        function removeEvent(namespacedEvent) {\r\n            var event = namespacedEvent && namespacedEvent.split(".")[0];\r\n            var namespace = event && namespacedEvent.substring(event.length);\r\n\r\n            Object.keys(scope_Events).forEach(function(bind) {\r\n                var tEvent = bind.split(".")[0];\r\n                var tNamespace = bind.substring(tEvent.length);\r\n\r\n                if ((!event || event === tEvent) && (!namespace || namespace === tNamespace)) {\r\n                    delete scope_Events[bind];\r\n                }\r\n            });\r\n        }\r\n\r\n        // External event handling\r\n        function fireEvent(eventName, handleNumber, tap) {\r\n            Object.keys(scope_Events).forEach(function(targetEvent) {\r\n                var eventType = targetEvent.split(".")[0];\r\n\r\n                if (eventName === eventType) {\r\n                    scope_Events[targetEvent].forEach(function(callback) {\r\n                        callback.call(\r\n                            // Use the slider public API as the scope (\'this\')\r\n                            scope_Self,\r\n                            // Return values as array, so arg_1[arg_2] is always valid.\r\n                            scope_Values.map(options.format.to),\r\n                            // Handle index, 0 or 1\r\n                            handleNumber,\r\n                            // Un-formatted slider values\r\n                            scope_Values.slice(),\r\n                            // Event is fired by tap, true or false\r\n                            tap || false,\r\n                            // Left offset of the handle, in relation to the slider\r\n                            scope_Locations.slice()\r\n                        );\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        // Split out the handle positioning logic so the Move event can use it, too\r\n        function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {\r\n            // For sliders with multiple handles, limit movement to the other handle.\r\n            // Apply the margin option by adding it to the handle positions.\r\n            if (scope_Handles.length > 1 && !options.events.unconstrained) {\r\n                if (lookBackward && handleNumber > 0) {\r\n                    to = Math.max(to, reference[handleNumber - 1] + options.margin);\r\n                }\r\n\r\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\r\n                    to = Math.min(to, reference[handleNumber + 1] - options.margin);\r\n                }\r\n            }\r\n\r\n            // The limit option has the opposite effect, limiting handles to a\r\n            // maximum distance from another. Limit must be > 0, as otherwise\r\n            // handles would be unmovable.\r\n            if (scope_Handles.length > 1 && options.limit) {\r\n                if (lookBackward && handleNumber > 0) {\r\n                    to = Math.min(to, reference[handleNumber - 1] + options.limit);\r\n                }\r\n\r\n                if (lookForward && handleNumber < scope_Handles.length - 1) {\r\n                    to = Math.max(to, reference[handleNumber + 1] - options.limit);\r\n                }\r\n            }\r\n\r\n            // The padding option keeps the handles a certain distance from the\r\n            // edges of the slider. Padding must be > 0.\r\n            if (options.padding) {\r\n                if (handleNumber === 0) {\r\n                    to = Math.max(to, options.padding[0]);\r\n                }\r\n\r\n                if (handleNumber === scope_Handles.length - 1) {\r\n                    to = Math.min(to, 100 - options.padding[1]);\r\n                }\r\n            }\r\n\r\n            to = scope_Spectrum.getStep(to);\r\n\r\n            // Limit percentage to the 0 - 100 range\r\n            to = limit(to);\r\n\r\n            // Return false if handle can\'t move\r\n            if (to === reference[handleNumber] && !getValue) {\r\n                return false;\r\n            }\r\n\r\n            return to;\r\n        }\r\n\r\n        // Uses slider orientation to create CSS rules. a = base value;\r\n        function inRuleOrder(v, a) {\r\n            var o = options.ort;\r\n            return (o ? a : v) + ", " + (o ? v : a);\r\n        }\r\n\r\n        // Moves handle(s) by a percentage\r\n        // (bool, % to move, [% where handle started, ...], [index in scope_Handles, ...])\r\n        function moveHandles(upward, proposal, locations, handleNumbers) {\r\n            var proposals = locations.slice();\r\n\r\n            var b = [!upward, upward];\r\n            var f = [upward, !upward];\r\n\r\n            // Copy handleNumbers so we don\'t change the dataset\r\n            handleNumbers = handleNumbers.slice();\r\n\r\n            // Check to see which handle is \'leading\'.\r\n            // If that one can\'t move the second can\'t either.\r\n            if (upward) {\r\n                handleNumbers.reverse();\r\n            }\r\n\r\n            // Step 1: get the maximum percentage that any of the handles can move\r\n            if (handleNumbers.length > 1) {\r\n                handleNumbers.forEach(function(handleNumber, o) {\r\n                    var to = checkHandlePosition(\r\n                        proposals,\r\n                        handleNumber,\r\n                        proposals[handleNumber] + proposal,\r\n                        b[o],\r\n                        f[o],\r\n                        false\r\n                    );\r\n\r\n                    // Stop if one of the handles can\'t move.\r\n                    if (to === false) {\r\n                        proposal = 0;\r\n                    } else {\r\n                        proposal = to - proposals[handleNumber];\r\n                        proposals[handleNumber] = to;\r\n                    }\r\n                });\r\n            }\r\n\r\n            // If using one handle, check backward AND forward\r\n            else {\r\n                b = f = [true];\r\n            }\r\n\r\n            var state = false;\r\n\r\n            // Step 2: Try to set the handles with the found percentage\r\n            handleNumbers.forEach(function(handleNumber, o) {\r\n                state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;\r\n            });\r\n\r\n            // Step 3: If a handle moved, fire events\r\n            if (state) {\r\n                handleNumbers.forEach(function(handleNumber) {\r\n                    fireEvent("update", handleNumber);\r\n                    fireEvent("slide", handleNumber);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Takes a base value and an offset. This offset is used for the connect bar size.\r\n        // In the initial design for this feature, the origin element was 1% wide.\r\n        // Unfortunately, a rounding bug in Chrome makes it impossible to implement this feature\r\n        // in this manner: https://bugs.chromium.org/p/chromium/issues/detail?id=798223\r\n        function transformDirection(a, b) {\r\n            return options.dir ? 100 - a - b : a;\r\n        }\r\n\r\n        // Updates scope_Locations and scope_Values, updates visual state\r\n        function updateHandlePosition(handleNumber, to) {\r\n            // Update locations.\r\n            scope_Locations[handleNumber] = to;\r\n\r\n            // Convert the value to the slider stepping/range.\r\n            scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);\r\n\r\n            var rule = "translate(" + inRuleOrder(transformDirection(to, 0) - scope_DirOffset + "%", "0") + ")";\r\n            scope_Handles[handleNumber].style[options.transformRule] = rule;\r\n\r\n            updateConnect(handleNumber);\r\n            updateConnect(handleNumber + 1);\r\n        }\r\n\r\n        // Handles before the slider middle are stacked later = higher,\r\n        // Handles after the middle later is lower\r\n        // [[7] [8] .......... | .......... [5] [4]\r\n        function setZindex() {\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                var dir = scope_Locations[handleNumber] > 50 ? -1 : 1;\r\n                var zIndex = 3 + (scope_Handles.length + dir * handleNumber);\r\n                scope_Handles[handleNumber].style.zIndex = zIndex;\r\n            });\r\n        }\r\n\r\n        // Test suggested values and apply margin, step.\r\n        function setHandle(handleNumber, to, lookBackward, lookForward) {\r\n            to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);\r\n\r\n            if (to === false) {\r\n                return false;\r\n            }\r\n\r\n            updateHandlePosition(handleNumber, to);\r\n\r\n            return true;\r\n        }\r\n\r\n        // Updates style attribute for connect nodes\r\n        function updateConnect(index) {\r\n            // Skip connects set to false\r\n            if (!scope_Connects[index]) {\r\n                return;\r\n            }\r\n\r\n            var l = 0;\r\n            var h = 100;\r\n\r\n            if (index !== 0) {\r\n                l = scope_Locations[index - 1];\r\n            }\r\n\r\n            if (index !== scope_Connects.length - 1) {\r\n                h = scope_Locations[index];\r\n            }\r\n\r\n            // We use two rules:\r\n            // \'translate\' to change the left/top offset;\r\n            // \'scale\' to change the width of the element;\r\n            // As the element has a width of 100%, a translation of 100% is equal to 100% of the parent (.noUi-base)\r\n            var connectWidth = h - l;\r\n            var translateRule = "translate(" + inRuleOrder(transformDirection(l, connectWidth) + "%", "0") + ")";\r\n            var scaleRule = "scale(" + inRuleOrder(connectWidth / 100, "1") + ")";\r\n\r\n            scope_Connects[index].style[options.transformRule] = translateRule + " " + scaleRule;\r\n        }\r\n\r\n        // Parses value passed to .set method. Returns current value if not parse-able.\r\n        function resolveToValue(to, handleNumber) {\r\n            // Setting with null indicates an \'ignore\'.\r\n            // Inputting \'false\' is invalid.\r\n            if (to === null || to === false || to === undefined) {\r\n                return scope_Locations[handleNumber];\r\n            }\r\n\r\n            // If a formatted number was passed, attempt to decode it.\r\n            if (typeof to === "number") {\r\n                to = String(to);\r\n            }\r\n\r\n            to = options.format.from(to);\r\n            to = scope_Spectrum.toStepping(to);\r\n\r\n            // If parsing the number failed, use the current value.\r\n            if (to === false || isNaN(to)) {\r\n                return scope_Locations[handleNumber];\r\n            }\r\n\r\n            return to;\r\n        }\r\n\r\n        // Set the slider value.\r\n        function valueSet(input, fireSetEvent) {\r\n            var values = asArray(input);\r\n            var isInit = scope_Locations[0] === undefined;\r\n\r\n            // Event fires by default\r\n            fireSetEvent = fireSetEvent === undefined ? true : !!fireSetEvent;\r\n\r\n            // Animation is optional.\r\n            // Make sure the initial values were set before using animated placement.\r\n            if (options.animate && !isInit) {\r\n                addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);\r\n            }\r\n\r\n            // First pass, without lookAhead but with lookBackward. Values are set from left to right.\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                setHandle(handleNumber, resolveToValue(values[handleNumber], handleNumber), true, false);\r\n            });\r\n\r\n            // Second pass. Now that all base values are set, apply constraints\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                setHandle(handleNumber, scope_Locations[handleNumber], true, true);\r\n            });\r\n\r\n            setZindex();\r\n\r\n            scope_HandleNumbers.forEach(function(handleNumber) {\r\n                fireEvent("update", handleNumber);\r\n\r\n                // Fire the event only for handles that received a new value, as per #579\r\n                if (values[handleNumber] !== null && fireSetEvent) {\r\n                    fireEvent("set", handleNumber);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Reset slider to initial values\r\n        function valueReset(fireSetEvent) {\r\n            valueSet(options.start, fireSetEvent);\r\n        }\r\n\r\n        // Set value for a single handle\r\n        function valueSetHandle(handleNumber, value, fireSetEvent) {\r\n            // Ensure numeric input\r\n            handleNumber = Number(handleNumber);\r\n\r\n            if (!(handleNumber >= 0 && handleNumber < scope_HandleNumbers.length)) {\r\n                throw new Error("noUiSlider (" + VERSION + "): invalid handle number, got: " + handleNumber);\r\n            }\r\n\r\n            // Look both backward and forward, since we don\'t want this handle to "push" other handles (#960);\r\n            setHandle(handleNumber, resolveToValue(value, handleNumber), true, true);\r\n\r\n            fireEvent("update", handleNumber);\r\n\r\n            if (fireSetEvent) {\r\n                fireEvent("set", handleNumber);\r\n            }\r\n        }\r\n\r\n        // Get the slider value.\r\n        function valueGet() {\r\n            var values = scope_Values.map(options.format.to);\r\n\r\n            // If only one handle is used, return a single value.\r\n            if (values.length === 1) {\r\n                return values[0];\r\n            }\r\n\r\n            return values;\r\n        }\r\n\r\n        // Removes classes from the root and empties it.\r\n        function destroy() {\r\n            for (var key in options.cssClasses) {\r\n                if (!options.cssClasses.hasOwnProperty(key)) {\r\n                    continue;\r\n                }\r\n                removeClass(scope_Target, options.cssClasses[key]);\r\n            }\r\n\r\n            while (scope_Target.firstChild) {\r\n                scope_Target.removeChild(scope_Target.firstChild);\r\n            }\r\n\r\n            delete scope_Target.noUiSlider;\r\n        }\r\n\r\n        function getNextStepsForHandle(handleNumber) {\r\n            var location = scope_Locations[handleNumber];\r\n            var nearbySteps = scope_Spectrum.getNearbySteps(location);\r\n            var value = scope_Values[handleNumber];\r\n            var increment = nearbySteps.thisStep.step;\r\n            var decrement = null;\r\n\r\n            // If snapped, directly use defined step value\r\n            if (options.snap) {\r\n                return [\r\n                    value - nearbySteps.stepBefore.startValue || null,\r\n                    nearbySteps.stepAfter.startValue - value || null\r\n                ];\r\n            }\r\n\r\n            // If the next value in this step moves into the next step,\r\n            // the increment is the start of the next step - the current value\r\n            if (increment !== false) {\r\n                if (value + increment > nearbySteps.stepAfter.startValue) {\r\n                    increment = nearbySteps.stepAfter.startValue - value;\r\n                }\r\n            }\r\n\r\n            // If the value is beyond the starting point\r\n            if (value > nearbySteps.thisStep.startValue) {\r\n                decrement = nearbySteps.thisStep.step;\r\n            } else if (nearbySteps.stepBefore.step === false) {\r\n                decrement = false;\r\n            }\r\n\r\n            // If a handle is at the start of a step, it always steps back into the previous step first\r\n            else {\r\n                decrement = value - nearbySteps.stepBefore.highestStep;\r\n            }\r\n\r\n            // Now, if at the slider edges, there is no in/decrement\r\n            if (location === 100) {\r\n                increment = null;\r\n            } else if (location === 0) {\r\n                decrement = null;\r\n            }\r\n\r\n            // As per #391, the comparison for the decrement step can have some rounding issues.\r\n            var stepDecimals = scope_Spectrum.countStepDecimals();\r\n\r\n            // Round per #391\r\n            if (increment !== null && increment !== false) {\r\n                increment = Number(increment.toFixed(stepDecimals));\r\n            }\r\n\r\n            if (decrement !== null && decrement !== false) {\r\n                decrement = Number(decrement.toFixed(stepDecimals));\r\n            }\r\n\r\n            return [decrement, increment];\r\n        }\r\n\r\n        // Get the current step size for the slider.\r\n        function getNextSteps() {\r\n            return scope_HandleNumbers.map(getNextStepsForHandle);\r\n        }\r\n\r\n        // Updateable: margin, limit, padding, step, range, animate, snap\r\n        function updateOptions(optionsToUpdate, fireSetEvent) {\r\n            // Spectrum is created using the range, snap, direction and step options.\r\n            // \'snap\' and \'step\' can be updated.\r\n            // If \'snap\' and \'step\' are not passed, they should remain unchanged.\r\n            var v = valueGet();\r\n\r\n            var updateAble = [\r\n                "margin",\r\n                "limit",\r\n                "padding",\r\n                "range",\r\n                "animate",\r\n                "snap",\r\n                "step",\r\n                "format",\r\n                "pips",\r\n                "tooltips"\r\n            ];\r\n\r\n            // Only change options that we\'re actually passed to update.\r\n            updateAble.forEach(function(name) {\r\n                // Check for undefined. null removes the value.\r\n                if (optionsToUpdate[name] !== undefined) {\r\n                    originalOptions[name] = optionsToUpdate[name];\r\n                }\r\n            });\r\n\r\n            var newOptions = testOptions(originalOptions);\r\n\r\n            // Load new options into the slider state\r\n            updateAble.forEach(function(name) {\r\n                if (optionsToUpdate[name] !== undefined) {\r\n                    options[name] = newOptions[name];\r\n                }\r\n            });\r\n\r\n            scope_Spectrum = newOptions.spectrum;\r\n\r\n            // Limit, margin and padding depend on the spectrum but are stored outside of it. (#677)\r\n            options.margin = newOptions.margin;\r\n            options.limit = newOptions.limit;\r\n            options.padding = newOptions.padding;\r\n\r\n            // Update pips, removes existing.\r\n            if (options.pips) {\r\n                pips(options.pips);\r\n            } else {\r\n                removePips();\r\n            }\r\n\r\n            // Update tooltips, removes existing.\r\n            if (options.tooltips) {\r\n                tooltips();\r\n            } else {\r\n                removeTooltips();\r\n            }\r\n\r\n            // Invalidate the current positioning so valueSet forces an update.\r\n            scope_Locations = [];\r\n            valueSet(optionsToUpdate.start || v, fireSetEvent);\r\n        }\r\n\r\n        // Initialization steps\r\n        function setupSlider() {\r\n            // Create the base element, initialize HTML and set classes.\r\n            // Add handles and connect elements.\r\n            scope_Base = addSlider(scope_Target);\r\n\r\n            addElements(options.connect, scope_Base);\r\n\r\n            // Attach user events.\r\n            bindSliderEvents(options.events);\r\n\r\n            // Use the public value method to set the start values.\r\n            valueSet(options.start);\r\n\r\n            if (options.pips) {\r\n                pips(options.pips);\r\n            }\r\n\r\n            if (options.tooltips) {\r\n                tooltips();\r\n            }\r\n\r\n            aria();\r\n        }\r\n\r\n        setupSlider();\r\n\r\n        // noinspection JSUnusedGlobalSymbols\r\n        scope_Self = {\r\n            destroy: destroy,\r\n            steps: getNextSteps,\r\n            on: bindEvent,\r\n            off: removeEvent,\r\n            get: valueGet,\r\n            set: valueSet,\r\n            setHandle: valueSetHandle,\r\n            reset: valueReset,\r\n            // Exposed for unit testing, don\'t use this in your application.\r\n            __moveHandles: function(a, b, c) {\r\n                moveHandles(a, b, scope_Locations, c);\r\n            },\r\n            options: originalOptions, // Issue #600, #678\r\n            updateOptions: updateOptions,\r\n            target: scope_Target, // Issue #597\r\n            removePips: removePips,\r\n            removeTooltips: removeTooltips,\r\n            pips: pips // Issue #594\r\n        };\r\n\r\n        return scope_Self;\r\n    }\r\n\r\n    // Run the standard initializer\r\n    function initialize(target, originalOptions) {\r\n        if (!target || !target.nodeName) {\r\n            throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);\r\n        }\r\n\r\n        // Throw an error if the slider was already initialized.\r\n        if (target.noUiSlider) {\r\n            throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");\r\n        }\r\n\r\n        // Test the options and create the slider environment;\r\n        var options = testOptions(originalOptions, target);\r\n        var api = scope(target, options, originalOptions);\r\n\r\n        target.noUiSlider = api;\r\n\r\n        return api;\r\n    }\r\n\r\n    // Use an object instead of a function for future expandability;\r\n    return {\r\n        // Exposed for unit testing, don\'t use this in your application.\r\n        __spectrum: Spectrum,\r\n        version: VERSION,\r\n        create: initialize\r\n    };\r\n});\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm91aXNsaWRlci9kaXN0cmlidXRlL25vdWlzbGlkZXIuanM/ZTlmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRDtBQUNBLFFBQVEsaUNBQU8sRUFBRSxvQ0FBRSxPQUFPO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzNCLEtBQUssTUFBTSxFQU1OO0FBQ0wsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLG9CQUFvQix3QkFBd0I7QUFDNUMsc0JBQXNCLDBCQUEwQjtBQUNoRCx3QkFBd0IsNEJBQTRCO0FBQ3BELG1CQUFtQix3QkFBd0I7QUFDM0Msc0JBQXNCLDJCQUEyQjtBQUNqRCxnQ0FBZ0MscUNBQXFDO0FBQ3JFLG9CQUFvQix3QkFBd0I7QUFDNUMsMEJBQTBCLCtCQUErQjtBQUN6RCxxQkFBcUIsMEJBQTBCO0FBQy9DLG9CQUFvQix5QkFBeUI7QUFDN0Msc0JBQXNCLDJCQUEyQjtBQUNqRCx3QkFBd0IsNEJBQTRCO0FBQ3BELHlCQUF5Qiw4QkFBOEI7QUFDdkQscUJBQXFCLDBCQUEwQjtBQUMvQyx1QkFBdUIsNEJBQTRCO0FBQ25ELDhCQUE4QixrQ0FBa0M7QUFDaEUsOEJBQThCLG1DQUFtQztBQUNqRSx3QkFBd0IsNEJBQTRCO0FBQ3BELHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIscUJBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtFQUErRSxnQkFBZ0I7QUFDL0Y7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBub3Vpc2xpZGVyIC0gMTMuMS40IC0gMy8yMC8yMDE5ICovXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgLy8gTm9kZS9Db21tb25KU1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgICAgICB3aW5kb3cubm9VaVNsaWRlciA9IGZhY3RvcnkoKTtcclxuICAgIH1cclxufSkoZnVuY3Rpb24oKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICB2YXIgVkVSU0lPTiA9IFwiMTMuMS40XCI7XHJcblxyXG4gICAgLy9yZWdpb24gSGVscGVyIE1ldGhvZHNcclxuXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRm9ybWF0dGVyKGVudHJ5KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbnRyeSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZW50cnkudG8gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZW50cnkuZnJvbSA9PT0gXCJmdW5jdGlvblwiO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnQoZWwpIHtcclxuICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJpbmRhYmxlIHZlcnNpb25cclxuICAgIGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gYW4gYXJyYXkuXHJcbiAgICBmdW5jdGlvbiB1bmlxdWUoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzW2FdID8gKHRoaXNbYV0gPSB0cnVlKSA6IGZhbHNlO1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBjbG9zZXN0ICd0bycuXHJcbiAgICBmdW5jdGlvbiBjbG9zZXN0KHZhbHVlLCB0bykge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3VycmVudCBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cclxuICAgIGZ1bmN0aW9uIG9mZnNldChlbGVtLCBvcmllbnRhdGlvbikge1xyXG4gICAgICAgIHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB2YXIgZG9jID0gZWxlbS5vd25lckRvY3VtZW50O1xyXG4gICAgICAgIHZhciBkb2NFbGVtID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoZG9jKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGNvbnRhaW5zIGxlZnQgc2Nyb2xsIGluIENocm9tZSBvbiBBbmRyb2lkLlxyXG4gICAgICAgIC8vIEkgaGF2ZW4ndCBmb3VuZCBhIGZlYXR1cmUgZGV0ZWN0aW9uIHRoYXQgcHJvdmVzIHRoaXMuIFdvcnN0IGNhc2VcclxuICAgICAgICAvLyBzY2VuYXJpbyBvbiBtaXMtbWF0Y2g6IHRoZSAndGFwJyBmZWF0dXJlIG9uIGhvcml6b250YWwgc2xpZGVycyBicmVha3MuXHJcbiAgICAgICAgaWYgKC93ZWJraXQuKkNocm9tZS4qTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xyXG4gICAgICAgICAgICBwYWdlT2Zmc2V0LnggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9yaWVudGF0aW9uXHJcbiAgICAgICAgICAgID8gcmVjdC50b3AgKyBwYWdlT2Zmc2V0LnkgLSBkb2NFbGVtLmNsaWVudFRvcFxyXG4gICAgICAgICAgICA6IHJlY3QubGVmdCArIHBhZ2VPZmZzZXQueCAtIGRvY0VsZW0uY2xpZW50TGVmdDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVja3Mgd2hldGhlciBhIHZhbHVlIGlzIG51bWVyaWNhbC5cclxuICAgIGZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmICFpc05hTihhKSAmJiBpc0Zpbml0ZShhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXRzIGEgY2xhc3MgYW5kIHJlbW92ZXMgaXQgYWZ0ZXIgW2R1cmF0aW9uXSBtcy5cclxuICAgIGZ1bmN0aW9uIGFkZENsYXNzRm9yKGVsZW1lbnQsIGNsYXNzTmFtZSwgZHVyYXRpb24pIHtcclxuICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIExpbWl0cyBhIHZhbHVlIHRvIDAgLSAxMDBcclxuICAgIGZ1bmN0aW9uIGxpbWl0KGEpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSwgMTAwKSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gV3JhcHMgYSB2YXJpYWJsZSBhcyBhbiBhcnJheSwgaWYgaXQgaXNuJ3Qgb25lIHlldC5cclxuICAgIC8vIE5vdGUgdGhhdCBhbiBpbnB1dCBhcnJheSBpcyByZXR1cm5lZCBieSByZWZlcmVuY2UhXHJcbiAgICBmdW5jdGlvbiBhc0FycmF5KGEpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ291bnRzIGRlY2ltYWxzXHJcbiAgICBmdW5jdGlvbiBjb3VudERlY2ltYWxzKG51bVN0cikge1xyXG4gICAgICAgIG51bVN0ciA9IFN0cmluZyhudW1TdHIpO1xyXG4gICAgICAgIHZhciBwaWVjZXMgPSBudW1TdHIuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIHJldHVybiBwaWVjZXMubGVuZ3RoID4gMSA/IHBpZWNlc1sxXS5sZW5ndGggOiAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNhZGRfY2xhc3NcclxuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcclxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNyZW1vdmVfY2xhc3NcclxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcclxuICAgICAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSBlbC5jbGFzc05hbWUucmVwbGFjZShcclxuICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoXCIoXnxcXFxcYilcIiArIGNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcInxcIikgKyBcIihcXFxcYnwkKVwiLCBcImdpXCIpLFxyXG4gICAgICAgICAgICAgICAgXCIgXCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gaHR0cHM6Ly9wbGFpbmpzLmNvbS9qYXZhc2NyaXB0L2F0dHJpYnV0ZXMvYWRkaW5nLXJlbW92aW5nLWFuZC10ZXN0aW5nLWZvci1jbGFzc2VzLTkvXHJcbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdFxyXG4gICAgICAgICAgICA/IGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXHJcbiAgICAgICAgICAgIDogbmV3IFJlZ0V4cChcIlxcXFxiXCIgKyBjbGFzc05hbWUgKyBcIlxcXFxiXCIpLnRlc3QoZWwuY2xhc3NOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Njcm9sbFkjTm90ZXNcclxuICAgIGZ1bmN0aW9uIGdldFBhZ2VPZmZzZXQoZG9jKSB7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGlzQ1NTMUNvbXBhdCA9IChkb2MuY29tcGF0TW9kZSB8fCBcIlwiKSA9PT0gXCJDU1MxQ29tcGF0XCI7XHJcbiAgICAgICAgdmFyIHggPSBzdXBwb3J0UGFnZU9mZnNldFxyXG4gICAgICAgICAgICA/IHdpbmRvdy5wYWdlWE9mZnNldFxyXG4gICAgICAgICAgICA6IGlzQ1NTMUNvbXBhdFxyXG4gICAgICAgICAgICAgICAgPyBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnRcclxuICAgICAgICAgICAgICAgIDogZG9jLmJvZHkuc2Nyb2xsTGVmdDtcclxuICAgICAgICB2YXIgeSA9IHN1cHBvcnRQYWdlT2Zmc2V0XHJcbiAgICAgICAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XHJcbiAgICAgICAgICAgIDogaXNDU1MxQ29tcGF0XHJcbiAgICAgICAgICAgICAgICA/IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXHJcbiAgICAgICAgICAgICAgICA6IGRvYy5ib2R5LnNjcm9sbFRvcDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogeCxcclxuICAgICAgICAgICAgeTogeVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gd2UgcHJvdmlkZSBhIGZ1bmN0aW9uIHRvIGNvbXB1dGUgY29uc3RhbnRzIGluc3RlYWRcclxuICAgIC8vIG9mIGFjY2Vzc2luZyB3aW5kb3cuKiBhcyBzb29uIGFzIHRoZSBtb2R1bGUgbmVlZHMgaXRcclxuICAgIC8vIHNvIHRoYXQgd2UgZG8gbm90IGNvbXB1dGUgYW55dGhpbmcgaWYgbm90IG5lZWRlZFxyXG4gICAgZnVuY3Rpb24gZ2V0QWN0aW9ucygpIHtcclxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGV2ZW50cyB0byBiaW5kLiBJRTExIGltcGxlbWVudHMgcG9pbnRlckV2ZW50cyB3aXRob3V0XHJcbiAgICAgICAgLy8gYSBwcmVmaXgsIHdoaWNoIGJyZWFrcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIElFMTAgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWRcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBcInBvaW50ZXJkb3duXCIsXHJcbiAgICAgICAgICAgICAgICAgIG1vdmU6IFwicG9pbnRlcm1vdmVcIixcclxuICAgICAgICAgICAgICAgICAgZW5kOiBcInBvaW50ZXJ1cFwiXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogXCJNU1BvaW50ZXJEb3duXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICBtb3ZlOiBcIk1TUG9pbnRlck1vdmVcIixcclxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogXCJNU1BvaW50ZXJVcFwiXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFwibW91c2Vkb3duIHRvdWNoc3RhcnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgIG1vdmU6IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBcIm1vdXNldXAgdG91Y2hlbmRcIlxyXG4gICAgICAgICAgICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kXHJcbiAgICAvLyBJc3N1ZSAjNzg1XHJcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1Bhc3NpdmUoKSB7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBvcHRzKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cclxuXHJcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93LkNTUyAmJiBDU1Muc3VwcG9ydHMgJiYgQ1NTLnN1cHBvcnRzKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKTtcclxuICAgIH1cclxuXHJcbiAgICAvL2VuZHJlZ2lvblxyXG5cclxuICAgIC8vcmVnaW9uIFJhbmdlIENhbGN1bGF0aW9uXHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIGEgc3ViLXJhbmdlIGluIHJlbGF0aW9uIHRvIGEgZnVsbCByYW5nZS5cclxuICAgIGZ1bmN0aW9uIHN1YlJhbmdlUmF0aW8ocGEsIHBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDEwMCAvIChwYiAtIHBhKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAocGVyY2VudGFnZSkgSG93IG1hbnkgcGVyY2VudCBpcyB0aGlzIHZhbHVlIG9mIHRoaXMgcmFuZ2U/XHJcbiAgICBmdW5jdGlvbiBmcm9tUGVyY2VudGFnZShyYW5nZSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlICogMTAwKSAvIChyYW5nZVsxXSAtIHJhbmdlWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAocGVyY2VudGFnZSkgV2hlcmUgaXMgdGhpcyB2YWx1ZSBvbiB0aGlzIHJhbmdlP1xyXG4gICAgZnVuY3Rpb24gdG9QZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tUGVyY2VudGFnZShyYW5nZSwgcmFuZ2VbMF0gPCAwID8gdmFsdWUgKyBNYXRoLmFicyhyYW5nZVswXSkgOiB2YWx1ZSAtIHJhbmdlWzBdKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xyXG4gICAgZnVuY3Rpb24gaXNQZXJjZW50YWdlKHJhbmdlLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiAodmFsdWUgKiAocmFuZ2VbMV0gLSByYW5nZVswXSkpIC8gMTAwICsgcmFuZ2VbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Sih2YWx1ZSwgYXJyKSB7XHJcbiAgICAgICAgdmFyIGogPSAxO1xyXG5cclxuICAgICAgICB3aGlsZSAodmFsdWUgPj0gYXJyW2pdKSB7XHJcbiAgICAgICAgICAgIGogKz0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBqO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIChwZXJjZW50YWdlKSBJbnB1dCBhIHZhbHVlLCBmaW5kIHdoZXJlLCBvbiBhIHNjYWxlIG9mIDAtMTAwLCBpdCBhcHBsaWVzLlxyXG4gICAgZnVuY3Rpb24gdG9TdGVwcGluZyh4VmFsLCB4UGN0LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB4VmFsKTtcclxuICAgICAgICB2YXIgdmEgPSB4VmFsW2ogLSAxXTtcclxuICAgICAgICB2YXIgdmIgPSB4VmFsW2pdO1xyXG4gICAgICAgIHZhciBwYSA9IHhQY3RbaiAtIDFdO1xyXG4gICAgICAgIHZhciBwYiA9IHhQY3Rbal07XHJcblxyXG4gICAgICAgIHJldHVybiBwYSArIHRvUGVyY2VudGFnZShbdmEsIHZiXSwgdmFsdWUpIC8gc3ViUmFuZ2VSYXRpbyhwYSwgcGIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vICh2YWx1ZSkgSW5wdXQgYSBwZXJjZW50YWdlLCBmaW5kIHdoZXJlIGl0IGlzIG9uIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXHJcbiAgICBmdW5jdGlvbiBmcm9tU3RlcHBpbmcoeFZhbCwgeFBjdCwgdmFsdWUpIHtcclxuICAgICAgICAvLyBUaGVyZSBpcyBubyByYW5nZSBncm91cCB0aGF0IGZpdHMgMTAwXHJcbiAgICAgICAgaWYgKHZhbHVlID49IDEwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4geFZhbC5zbGljZSgtMSlbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xyXG4gICAgICAgIHZhciB2YSA9IHhWYWxbaiAtIDFdO1xyXG4gICAgICAgIHZhciB2YiA9IHhWYWxbal07XHJcbiAgICAgICAgdmFyIHBhID0geFBjdFtqIC0gMV07XHJcbiAgICAgICAgdmFyIHBiID0geFBjdFtqXTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGlzUGVyY2VudGFnZShbdmEsIHZiXSwgKHZhbHVlIC0gcGEpICogc3ViUmFuZ2VSYXRpbyhwYSwgcGIpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyAocGVyY2VudGFnZSkgR2V0IHRoZSBzdGVwIHRoYXQgYXBwbGllcyBhdCBhIGNlcnRhaW4gdmFsdWUuXHJcbiAgICBmdW5jdGlvbiBnZXRTdGVwKHhQY3QsIHhTdGVwcywgc25hcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IDEwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHhQY3QpO1xyXG4gICAgICAgIHZhciBhID0geFBjdFtqIC0gMV07XHJcbiAgICAgICAgdmFyIGIgPSB4UGN0W2pdO1xyXG5cclxuICAgICAgICAvLyBJZiAnc25hcCcgaXMgc2V0LCBzdGVwcyBhcmUgdXNlZCBhcyBmaXhlZCBwb2ludHMgb24gdGhlIHNsaWRlci5cclxuICAgICAgICBpZiAoc25hcCkge1xyXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHBvc2l0aW9uLCBhIG9yIGIuXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAtIGEgPiAoYiAtIGEpIC8gMikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF4U3RlcHNbaiAtIDFdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4UGN0W2ogLSAxXSArIGNsb3Nlc3QodmFsdWUgLSB4UGN0W2ogLSAxXSwgeFN0ZXBzW2ogLSAxXSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlRW50cnlQb2ludChpbmRleCwgdmFsdWUsIHRoYXQpIHtcclxuICAgICAgICB2YXIgcGVyY2VudGFnZTtcclxuXHJcbiAgICAgICAgLy8gV3JhcCBudW1lcmljYWwgaW5wdXQgaW4gYW4gYXJyYXkuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWplY3QgYW55IGludmFsaWQgaW5wdXQsIGJ5IHRlc3Rpbmcgd2hldGhlciB2YWx1ZSBpcyBhbiBhcnJheS5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyBjb250YWlucyBpbnZhbGlkIHZhbHVlLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXHJcbiAgICAgICAgaWYgKGluZGV4ID09PSBcIm1pblwiKSB7XHJcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IFwibWF4XCIpIHtcclxuICAgICAgICAgICAgcGVyY2VudGFnZSA9IDEwMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwZXJjZW50YWdlID0gcGFyc2VGbG9hdChpbmRleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dC5cclxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhwZXJjZW50YWdlKSB8fCAhaXNOdW1lcmljKHZhbHVlWzBdKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdyYW5nZScgdmFsdWUgaXNuJ3QgbnVtZXJpYy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB2YWx1ZXMuXHJcbiAgICAgICAgdGhhdC54UGN0LnB1c2gocGVyY2VudGFnZSk7XHJcbiAgICAgICAgdGhhdC54VmFsLnB1c2godmFsdWVbMF0pO1xyXG5cclxuICAgICAgICAvLyBOYU4gd2lsbCBldmFsdWF0ZSB0byBmYWxzZSB0b28sIGJ1dCB0byBrZWVwXHJcbiAgICAgICAgLy8gbG9nZ2luZyBjbGVhciwgc2V0IHN0ZXAgZXhwbGljaXRseS4gTWFrZSBzdXJlXHJcbiAgICAgICAgLy8gbm90IHRvIG92ZXJyaWRlIHRoZSAnc3RlcCcgc2V0dGluZyB3aXRoIGZhbHNlLlxyXG4gICAgICAgIGlmICghcGVyY2VudGFnZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlWzFdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC54U3RlcHNbMF0gPSB2YWx1ZVsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoYXQueFN0ZXBzLnB1c2goaXNOYU4odmFsdWVbMV0pID8gZmFsc2UgOiB2YWx1ZVsxXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGF0LnhIaWdoZXN0Q29tcGxldGVTdGVwLnB1c2goMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RlcFBvaW50KGksIG4sIHRoYXQpIHtcclxuICAgICAgICAvLyBJZ25vcmUgJ2ZhbHNlJyBzdGVwcGluZy5cclxuICAgICAgICBpZiAoIW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RlcCBvdmVyIHplcm8tbGVuZ3RoIHJhbmdlcyAoIzk0OCk7XHJcbiAgICAgICAgaWYgKHRoYXQueFZhbFtpXSA9PT0gdGhhdC54VmFsW2kgKyAxXSkge1xyXG4gICAgICAgICAgICB0aGF0LnhTdGVwc1tpXSA9IHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSB0aGF0LnhWYWxbaV07XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGYWN0b3IgdG8gcmFuZ2UgcmF0aW9cclxuICAgICAgICB0aGF0LnhTdGVwc1tpXSA9XHJcbiAgICAgICAgICAgIGZyb21QZXJjZW50YWdlKFt0aGF0LnhWYWxbaV0sIHRoYXQueFZhbFtpICsgMV1dLCBuKSAvIHN1YlJhbmdlUmF0aW8odGhhdC54UGN0W2ldLCB0aGF0LnhQY3RbaSArIDFdKTtcclxuXHJcbiAgICAgICAgdmFyIHRvdGFsU3RlcHMgPSAodGhhdC54VmFsW2kgKyAxXSAtIHRoYXQueFZhbFtpXSkgLyB0aGF0LnhOdW1TdGVwc1tpXTtcclxuICAgICAgICB2YXIgaGlnaGVzdFN0ZXAgPSBNYXRoLmNlaWwoTnVtYmVyKHRvdGFsU3RlcHMudG9GaXhlZCgzKSkgLSAxKTtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoYXQueFZhbFtpXSArIHRoYXQueE51bVN0ZXBzW2ldICogaGlnaGVzdFN0ZXA7XHJcblxyXG4gICAgICAgIHRoYXQueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaV0gPSBzdGVwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vZW5kcmVnaW9uXHJcblxyXG4gICAgLy9yZWdpb24gU3BlY3RydW1cclxuXHJcbiAgICBmdW5jdGlvbiBTcGVjdHJ1bShlbnRyeSwgc25hcCwgc2luZ2xlU3RlcCkge1xyXG4gICAgICAgIHRoaXMueFBjdCA9IFtdO1xyXG4gICAgICAgIHRoaXMueFZhbCA9IFtdO1xyXG4gICAgICAgIHRoaXMueFN0ZXBzID0gW3NpbmdsZVN0ZXAgfHwgZmFsc2VdO1xyXG4gICAgICAgIHRoaXMueE51bVN0ZXBzID0gW2ZhbHNlXTtcclxuICAgICAgICB0aGlzLnhIaWdoZXN0Q29tcGxldGVTdGVwID0gW107XHJcblxyXG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XHJcblxyXG4gICAgICAgIHZhciBpbmRleDtcclxuICAgICAgICB2YXIgb3JkZXJlZCA9IFtdOyAvLyBbMCwgJ21pbiddLCBbMSwgJzUwJSddLCBbMiwgJ21heCddXHJcblxyXG4gICAgICAgIC8vIE1hcCB0aGUgb2JqZWN0IGtleXMgdG8gYW4gYXJyYXkuXHJcbiAgICAgICAgZm9yIChpbmRleCBpbiBlbnRyeSkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnkuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goW2VudHJ5W2luZGV4XSwgaW5kZXhdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU29ydCBhbGwgZW50cmllcyBieSB2YWx1ZSAobnVtZXJpYyBzb3J0KS5cclxuICAgICAgICBpZiAob3JkZXJlZC5sZW5ndGggJiYgdHlwZW9mIG9yZGVyZWRbMF1bMF0gPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhWzBdWzBdIC0gYlswXVswXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBlbnRyaWVzIHRvIHN1YnJhbmdlcy5cclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBvcmRlcmVkLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBoYW5kbGVFbnRyeVBvaW50KG9yZGVyZWRbaW5kZXhdWzFdLCBvcmRlcmVkW2luZGV4XVswXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgYWN0dWFsIHN0ZXAgdmFsdWVzLlxyXG4gICAgICAgIC8vIHhTdGVwcyBpcyBzb3J0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgeFBjdCBhbmQgeFZhbC5cclxuICAgICAgICB0aGlzLnhOdW1TdGVwcyA9IHRoaXMueFN0ZXBzLnNsaWNlKDApO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBudW1lcmljIHN0ZXBzIHRvIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdWJyYW5nZSB0aGV5IHJlcHJlc2VudC5cclxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgaGFuZGxlU3RlcFBvaW50KGluZGV4LCB0aGlzLnhOdW1TdGVwc1tpbmRleF0sIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0TWFyZ2luID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMueE51bVN0ZXBzWzBdO1xyXG5cclxuICAgICAgICBpZiAoc3RlcCAmJiAodmFsdWUgLyBzdGVwKSAlIDEgIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnbGltaXQnLCAnbWFyZ2luJyBhbmQgJ3BhZGRpbmcnIG11c3QgYmUgZGl2aXNpYmxlIGJ5IHN0ZXAuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMueFBjdC5sZW5ndGggPT09IDIgPyBmcm9tUGVyY2VudGFnZSh0aGlzLnhWYWwsIHZhbHVlKSA6IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUudG9TdGVwcGluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b1N0ZXBwaW5nKHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmZyb21TdGVwcGluZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdGVwcGluZyh0aGlzLnhWYWwsIHRoaXMueFBjdCwgdmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBnZXRTdGVwKHRoaXMueFBjdCwgdGhpcy54U3RlcHMsIHRoaXMuc25hcCwgdmFsdWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXREZWZhdWx0U3RlcCA9IGZ1bmN0aW9uKHZhbHVlLCBpc0Rvd24sIHNpemUpIHtcclxuICAgICAgICB2YXIgaiA9IGdldEoodmFsdWUsIHRoaXMueFBjdCk7XHJcblxyXG4gICAgICAgIC8vIFdoZW4gYXQgdGhlIHRvcCBvciBzdGVwcGluZyBkb3duLCBsb29rIGF0IHRoZSBwcmV2aW91cyBzdWItcmFuZ2VcclxuICAgICAgICBpZiAodmFsdWUgPT09IDEwMCB8fCAoaXNEb3duICYmIHZhbHVlID09PSB0aGlzLnhQY3RbaiAtIDFdKSkge1xyXG4gICAgICAgICAgICBqID0gTWF0aC5tYXgoaiAtIDEsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnhWYWxbal0gLSB0aGlzLnhWYWxbaiAtIDFdKSAvIHNpemU7XHJcbiAgICB9O1xyXG5cclxuICAgIFNwZWN0cnVtLnByb3RvdHlwZS5nZXROZWFyYnlTdGVwcyA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzdGVwQmVmb3JlOiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDJdLFxyXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDJdLFxyXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDJdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHRoaXNTdGVwOiB7XHJcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlOiB0aGlzLnhWYWxbaiAtIDFdLFxyXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbaiAtIDFdLFxyXG4gICAgICAgICAgICAgICAgaGlnaGVzdFN0ZXA6IHRoaXMueEhpZ2hlc3RDb21wbGV0ZVN0ZXBbaiAtIDFdXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0ZXBBZnRlcjoge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRWYWx1ZTogdGhpcy54VmFsW2pdLFxyXG4gICAgICAgICAgICAgICAgc3RlcDogdGhpcy54TnVtU3RlcHNbal0sXHJcbiAgICAgICAgICAgICAgICBoaWdoZXN0U3RlcDogdGhpcy54SGlnaGVzdENvbXBsZXRlU3RlcFtqXVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgU3BlY3RydW0ucHJvdG90eXBlLmNvdW50U3RlcERlY2ltYWxzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHN0ZXBEZWNpbWFscyA9IHRoaXMueE51bVN0ZXBzLm1hcChjb3VudERlY2ltYWxzKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgc3RlcERlY2ltYWxzKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gT3V0c2lkZSB0ZXN0aW5nXHJcbiAgICBTcGVjdHJ1bS5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlcCh0aGlzLnRvU3RlcHBpbmcodmFsdWUpKTtcclxuICAgIH07XHJcblxyXG4gICAgLy9lbmRyZWdpb25cclxuXHJcbiAgICAvL3JlZ2lvbiBPcHRpb25zXHJcblxyXG4gICAgLypcdEV2ZXJ5IGlucHV0IG9wdGlvbiBpcyB0ZXN0ZWQgYW5kIHBhcnNlZC4gVGhpcydsbCBwcmV2ZW50XHJcbiAgICAgICAgZW5kbGVzcyB2YWxpZGF0aW9uIGluIGludGVybmFsIG1ldGhvZHMuIFRoZXNlIHRlc3RzIGFyZVxyXG4gICAgICAgIHN0cnVjdHVyZWQgd2l0aCBhbiBpdGVtIGZvciBldmVyeSBvcHRpb24gYXZhaWxhYmxlLiBBblxyXG4gICAgICAgIG9wdGlvbiBjYW4gYmUgbWFya2VkIGFzIHJlcXVpcmVkIGJ5IHNldHRpbmcgdGhlICdyJyBmbGFnLlxyXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxyXG4gICAgICAgICAgICAtIFRoZSBwcm92aWRlZCB2YWx1ZSBmb3IgdGhlIG9wdGlvbjtcclxuICAgICAgICAgICAgLSBBIHJlZmVyZW5jZSB0byB0aGUgb3B0aW9ucyBvYmplY3Q7XHJcbiAgICAgICAgICAgIC0gVGhlIG5hbWUgZm9yIHRoZSBvcHRpb247XHJcblxyXG4gICAgICAgIFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIHJldHVybnMgZmFsc2Ugd2hlbiBhbiBlcnJvciBpcyBkZXRlY3RlZCxcclxuICAgICAgICBvciB0cnVlIHdoZW4gZXZlcnl0aGluZyBpcyBPSy4gSXQgY2FuIGFsc28gbW9kaWZ5IHRoZSBvcHRpb25cclxuICAgICAgICBvYmplY3QsIHRvIG1ha2Ugc3VyZSBhbGwgdmFsdWVzIGNhbiBiZSBjb3JyZWN0bHkgbG9vcGVkIGVsc2V3aGVyZS4gKi9cclxuXHJcbiAgICB2YXIgZGVmYXVsdEZvcm1hdHRlciA9IHtcclxuICAgICAgICB0bzogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudG9GaXhlZCgyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZyb206IE51bWJlclxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChlbnRyeSkge1xyXG4gICAgICAgIC8vIEFueSBvYmplY3Qgd2l0aCBhIHRvIGFuZCBmcm9tIG1ldGhvZCBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgICAgaWYgKGlzVmFsaWRGb3JtYXR0ZXIoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnZm9ybWF0JyByZXF1aXJlcyAndG8nIGFuZCAnZnJvbScgbWV0aG9kcy5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdFN0ZXAocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdzdGVwJyBpcyBub3QgbnVtZXJpYy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgc3RlcCBvcHRpb24gY2FuIHN0aWxsIGJlIHVzZWQgdG8gc2V0IHN0ZXBwaW5nXHJcbiAgICAgICAgLy8gZm9yIGxpbmVhciBzbGlkZXJzLiBPdmVyd3JpdHRlbiBpZiBzZXQgaW4gJ3JhbmdlJy5cclxuICAgICAgICBwYXJzZWQuc2luZ2xlU3RlcCA9IGVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RSYW5nZShwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gRmlsdGVyIGluY29ycmVjdCBpbnB1dC5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyBpcyBub3QgYW4gb2JqZWN0LlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhdGNoIG1pc3Npbmcgc3RhcnQgb3IgZW5kLlxyXG4gICAgICAgIGlmIChlbnRyeS5taW4gPT09IHVuZGVmaW5lZCB8fCBlbnRyeS5tYXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IE1pc3NpbmcgJ21pbicgb3IgJ21heCcgaW4gJ3JhbmdlJy5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYXRjaCBlcXVhbCBzdGFydCBvciBlbmQuXHJcbiAgICAgICAgaWYgKGVudHJ5Lm1pbiA9PT0gZW50cnkubWF4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3JhbmdlJyAnbWluJyBhbmQgJ21heCcgY2Fubm90IGJlIGVxdWFsLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5zcGVjdHJ1bSA9IG5ldyBTcGVjdHJ1bShlbnRyeSwgcGFyc2VkLnNuYXAsIHBhcnNlZC5zaW5nbGVTdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0U3RhcnQocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGVudHJ5ID0gYXNBcnJheShlbnRyeSk7XHJcblxyXG4gICAgICAgIC8vIFZhbGlkYXRlIGlucHV0LiBWYWx1ZXMgYXJlbid0IHRlc3RlZCwgYXMgdGhlIHB1YmxpYyAudmFsIG1ldGhvZFxyXG4gICAgICAgIC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50cnkpIHx8ICFlbnRyeS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RvcmUgdGhlIG51bWJlciBvZiBoYW5kbGVzLlxyXG4gICAgICAgIHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSBzbGlkZXIgaXMgaW5pdGlhbGl6ZWQsIHRoZSAudmFsIG1ldGhvZCB3aWxsXHJcbiAgICAgICAgLy8gYmUgY2FsbGVkIHdpdGggdGhlIHN0YXJ0IG9wdGlvbnMuXHJcbiAgICAgICAgcGFyc2VkLnN0YXJ0ID0gZW50cnk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdFNuYXAocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIC8vIEVuZm9yY2UgMTAwJSBzdGVwcGluZyB3aXRoaW4gc3VicmFuZ2VzLlxyXG4gICAgICAgIHBhcnNlZC5zbmFwID0gZW50cnk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RBbmltYXRlKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICAvLyBFbmZvcmNlIDEwMCUgc3RlcHBpbmcgd2l0aGluIHN1YnJhbmdlcy5cclxuICAgICAgICBwYXJzZWQuYW5pbWF0ZSA9IGVudHJ5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcImJvb2xlYW5cIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdhbmltYXRlJyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0QW5pbWF0aW9uRHVyYXRpb24ocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIHBhcnNlZC5hbmltYXRpb25EdXJhdGlvbiA9IGVudHJ5O1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2FuaW1hdGlvbkR1cmF0aW9uJyBvcHRpb24gbXVzdCBiZSBhIG51bWJlci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RDb25uZWN0KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICB2YXIgY29ubmVjdCA9IFtmYWxzZV07XHJcbiAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgIC8vIE1hcCBsZWdhY3kgb3B0aW9uc1xyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gXCJsb3dlclwiKSB7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gW3RydWUsIGZhbHNlXTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVudHJ5ID09PSBcInVwcGVyXCIpIHtcclxuICAgICAgICAgICAgZW50cnkgPSBbZmFsc2UsIHRydWVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGJvb2xlYW4gb3B0aW9uc1xyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gdHJ1ZSB8fCBlbnRyeSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8IHBhcnNlZC5oYW5kbGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3QucHVzaChlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbm5lY3QucHVzaChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWplY3QgaW52YWxpZCBpbnB1dFxyXG4gICAgICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCAhZW50cnkubGVuZ3RoIHx8IGVudHJ5Lmxlbmd0aCAhPT0gcGFyc2VkLmhhbmRsZXMgKyAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2Nvbm5lY3QnIG9wdGlvbiBkb2Vzbid0IG1hdGNoIGhhbmRsZSBjb3VudC5cIik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29ubmVjdCA9IGVudHJ5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcGFyc2VkLmNvbm5lY3QgPSBjb25uZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RPcmllbnRhdGlvbihwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gU2V0IG9yaWVudGF0aW9uIHRvIGFuIGEgbnVtZXJpY2FsIHZhbHVlIGZvciBlYXN5XHJcbiAgICAgICAgLy8gYXJyYXkgc2VsZWN0aW9uLlxyXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcclxuICAgICAgICAgICAgICAgIHBhcnNlZC5vcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLm9ydCA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ29yaWVudGF0aW9uJyBvcHRpb24gaXMgaW52YWxpZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RNYXJnaW4ocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmICghaXNOdW1lcmljKGVudHJ5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdtYXJnaW4nIG9wdGlvbiBtdXN0IGJlIG51bWVyaWMuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSXNzdWUgIzU4MlxyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXJzZWQubWFyZ2luID0gcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeSk7XHJcblxyXG4gICAgICAgIGlmICghcGFyc2VkLm1hcmdpbikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdtYXJnaW4nIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RMaW1pdChwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKCFpc051bWVyaWMoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2xpbWl0JyBvcHRpb24gbXVzdCBiZSBudW1lcmljLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5saW1pdCA9IHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnkpO1xyXG5cclxuICAgICAgICBpZiAoIXBhcnNlZC5saW1pdCB8fCBwYXJzZWQuaGFuZGxlcyA8IDIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgVkVSU0lPTiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIpOiAnbGltaXQnIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycyB3aXRoIDIgb3IgbW9yZSBoYW5kbGVzLlwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RQYWRkaW5nKHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBpZiAoIWlzTnVtZXJpYyhlbnRyeSkgJiYgIUFycmF5LmlzQXJyYXkoZW50cnkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIG11c3QgYmUgbnVtZXJpYyBvciBhcnJheSBvZiBleGFjdGx5IDIgbnVtYmVycy5cIlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW50cnkpICYmICEoZW50cnkubGVuZ3RoID09PSAyIHx8IGlzTnVtZXJpYyhlbnRyeVswXSkgfHwgaXNOdW1lcmljKGVudHJ5WzFdKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBiZSBudW1lcmljIG9yIGFycmF5IG9mIGV4YWN0bHkgMiBudW1iZXJzLlwiXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZW50cnkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGVudHJ5KSkge1xyXG4gICAgICAgICAgICBlbnRyeSA9IFtlbnRyeSwgZW50cnldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ2dldE1hcmdpbicgcmV0dXJucyBmYWxzZSBmb3IgaW52YWxpZCB2YWx1ZXMuXHJcbiAgICAgICAgcGFyc2VkLnBhZGRpbmcgPSBbcGFyc2VkLnNwZWN0cnVtLmdldE1hcmdpbihlbnRyeVswXSksIHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnlbMV0pXTtcclxuXHJcbiAgICAgICAgaWYgKHBhcnNlZC5wYWRkaW5nWzBdID09PSBmYWxzZSB8fCBwYXJzZWQucGFkZGluZ1sxXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAncGFkZGluZycgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWQucGFkZGluZ1swXSA8IDAgfHwgcGFyc2VkLnBhZGRpbmdbMV0gPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3BhZGRpbmcnIG9wdGlvbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKHMpLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwYXJzZWQucGFkZGluZ1swXSArIHBhcnNlZC5wYWRkaW5nWzFdID49IDEwMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdwYWRkaW5nJyBvcHRpb24gbXVzdCBub3QgZXhjZWVkIDEwMCUgb2YgdGhlIHJhbmdlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdGVzdERpcmVjdGlvbihwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgLy8gU2V0IGRpcmVjdGlvbiBhcyBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgZWFzeSBwYXJzaW5nLlxyXG4gICAgICAgIC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXHJcbiAgICAgICAgLy8gaGFuZGxlcyBnZXQgdGhlIGNvbm5lY3QvYmFja2dyb3VuZCBjbGFzc2VzLlxyXG4gICAgICAgIHN3aXRjaCAoZW50cnkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImx0clwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLmRpciA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInJ0bFwiOlxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLmRpciA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2RpcmVjdGlvbicgb3B0aW9uIHdhcyBub3QgcmVjb2duaXplZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RCZWhhdmlvdXIocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgaW5wdXQgaXMgYSBzdHJpbmcuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdiZWhhdmlvdXInIG11c3QgYmUgYSBzdHJpbmcgY29udGFpbmluZyBvcHRpb25zLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHJpbmcgY29udGFpbnMgYW55IGtleXdvcmRzLlxyXG4gICAgICAgIC8vIE5vbmUgYXJlIHJlcXVpcmVkLlxyXG4gICAgICAgIHZhciB0YXAgPSBlbnRyeS5pbmRleE9mKFwidGFwXCIpID49IDA7XHJcbiAgICAgICAgdmFyIGRyYWcgPSBlbnRyeS5pbmRleE9mKFwiZHJhZ1wiKSA+PSAwO1xyXG4gICAgICAgIHZhciBmaXhlZCA9IGVudHJ5LmluZGV4T2YoXCJmaXhlZFwiKSA+PSAwO1xyXG4gICAgICAgIHZhciBzbmFwID0gZW50cnkuaW5kZXhPZihcInNuYXBcIikgPj0gMDtcclxuICAgICAgICB2YXIgaG92ZXIgPSBlbnRyeS5pbmRleE9mKFwiaG92ZXJcIikgPj0gMDtcclxuICAgICAgICB2YXIgdW5jb25zdHJhaW5lZCA9IGVudHJ5LmluZGV4T2YoXCJ1bmNvbnN0cmFpbmVkXCIpID49IDA7XHJcblxyXG4gICAgICAgIGlmIChmaXhlZCkge1xyXG4gICAgICAgICAgICBpZiAocGFyc2VkLmhhbmRsZXMgIT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2ZpeGVkJyBiZWhhdmlvdXIgbXVzdCBiZSB1c2VkIHdpdGggMiBoYW5kbGVzXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVc2UgbWFyZ2luIHRvIGVuZm9yY2UgZml4ZWQgc3RhdGVcclxuICAgICAgICAgICAgdGVzdE1hcmdpbihwYXJzZWQsIHBhcnNlZC5zdGFydFsxXSAtIHBhcnNlZC5zdGFydFswXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodW5jb25zdHJhaW5lZCAmJiAocGFyc2VkLm1hcmdpbiB8fCBwYXJzZWQubGltaXQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgIFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAndW5jb25zdHJhaW5lZCcgYmVoYXZpb3VyIGNhbm5vdCBiZSB1c2VkIHdpdGggbWFyZ2luIG9yIGxpbWl0XCJcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5ldmVudHMgPSB7XHJcbiAgICAgICAgICAgIHRhcDogdGFwIHx8IHNuYXAsXHJcbiAgICAgICAgICAgIGRyYWc6IGRyYWcsXHJcbiAgICAgICAgICAgIGZpeGVkOiBmaXhlZCxcclxuICAgICAgICAgICAgc25hcDogc25hcCxcclxuICAgICAgICAgICAgaG92ZXI6IGhvdmVyLFxyXG4gICAgICAgICAgICB1bmNvbnN0cmFpbmVkOiB1bmNvbnN0cmFpbmVkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0VG9vbHRpcHMocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmIChlbnRyeSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVudHJ5ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMucHVzaCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhcnNlZC50b29sdGlwcyA9IGFzQXJyYXkoZW50cnkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHBhcnNlZC50b29sdGlwcy5sZW5ndGggIT09IHBhcnNlZC5oYW5kbGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IG11c3QgcGFzcyBhIGZvcm1hdHRlciBmb3IgYWxsIGhhbmRsZXMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwYXJzZWQudG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbihmb3JtYXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZm9ybWF0dGVyICE9PSBcImJvb2xlYW5cIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZm9ybWF0dGVyICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmb3JtYXR0ZXIudG8gIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3Rvb2x0aXBzJyBtdXN0IGJlIHBhc3NlZCBhIGZvcm1hdHRlciBvciAnZmFsc2UnLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RBcmlhRm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBwYXJzZWQuYXJpYUZvcm1hdCA9IGVudHJ5O1xyXG4gICAgICAgIHZhbGlkYXRlRm9ybWF0KGVudHJ5KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0Rm9ybWF0KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICBwYXJzZWQuZm9ybWF0ID0gZW50cnk7XHJcbiAgICAgICAgdmFsaWRhdGVGb3JtYXQoZW50cnkpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RLZXlib2FyZFN1cHBvcnQocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIHBhcnNlZC5rZXlib2FyZFN1cHBvcnQgPSBlbnRyeTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAna2V5Ym9hcmRTdXBwb3J0JyBvcHRpb24gbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0RG9jdW1lbnRFbGVtZW50KHBhcnNlZCwgZW50cnkpIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGFuIGFkdmFuY2VkIG9wdGlvbi4gUGFzc2VkIHZhbHVlcyBhcmUgdXNlZCB3aXRob3V0IHZhbGlkYXRpb24uXHJcbiAgICAgICAgcGFyc2VkLmRvY3VtZW50RWxlbWVudCA9IGVudHJ5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRlc3RDc3NQcmVmaXgocGFyc2VkLCBlbnRyeSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwic3RyaW5nXCIgJiYgZW50cnkgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ2Nzc1ByZWZpeCcgbXVzdCBiZSBhIHN0cmluZyBvciBgZmFsc2VgLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHBhcnNlZC5jc3NQcmVmaXggPSBlbnRyeTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0ZXN0Q3NzQ2xhc3NlcyhwYXJzZWQsIGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6ICdjc3NDbGFzc2VzJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIHBhcnNlZC5jc3NQcmVmaXggPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSB7fTtcclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbnRyeS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXNba2V5XSA9IHBhcnNlZC5jc3NQcmVmaXggKyBlbnRyeVtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcGFyc2VkLmNzc0NsYXNzZXMgPSBlbnRyeTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGVzdCBhbGwgZGV2ZWxvcGVyIHNldHRpbmdzIGFuZCBwYXJzZSB0byBhc3N1bXB0aW9uLXNhZmUgdmFsdWVzLlxyXG4gICAgZnVuY3Rpb24gdGVzdE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIC8vIFRvIHByb3ZlIGEgZml4IGZvciAjNTM3LCBmcmVlemUgb3B0aW9ucyBoZXJlLlxyXG4gICAgICAgIC8vIElmIHRoZSBvYmplY3QgaXMgbW9kaWZpZWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxyXG4gICAgICAgIC8vIE9iamVjdC5mcmVlemUob3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHZhciBwYXJzZWQgPSB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogMCxcclxuICAgICAgICAgICAgbGltaXQ6IDAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXHJcbiAgICAgICAgICAgIGFuaW1hdGU6IHRydWUsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAzMDAsXHJcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IGRlZmF1bHRGb3JtYXR0ZXIsXHJcbiAgICAgICAgICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdHRlclxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFRlc3RzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcHJlc2VudGVkIGhlcmUuXHJcbiAgICAgICAgdmFyIHRlc3RzID0ge1xyXG4gICAgICAgICAgICBzdGVwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U3RlcCB9LFxyXG4gICAgICAgICAgICBzdGFydDogeyByOiB0cnVlLCB0OiB0ZXN0U3RhcnQgfSxcclxuICAgICAgICAgICAgY29ubmVjdDogeyByOiB0cnVlLCB0OiB0ZXN0Q29ubmVjdCB9LFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IHsgcjogdHJ1ZSwgdDogdGVzdERpcmVjdGlvbiB9LFxyXG4gICAgICAgICAgICBzbmFwOiB7IHI6IGZhbHNlLCB0OiB0ZXN0U25hcCB9LFxyXG4gICAgICAgICAgICBhbmltYXRlOiB7IHI6IGZhbHNlLCB0OiB0ZXN0QW5pbWF0ZSB9LFxyXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbjogeyByOiBmYWxzZSwgdDogdGVzdEFuaW1hdGlvbkR1cmF0aW9uIH0sXHJcbiAgICAgICAgICAgIHJhbmdlOiB7IHI6IHRydWUsIHQ6IHRlc3RSYW5nZSB9LFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogeyByOiBmYWxzZSwgdDogdGVzdE9yaWVudGF0aW9uIH0sXHJcbiAgICAgICAgICAgIG1hcmdpbjogeyByOiBmYWxzZSwgdDogdGVzdE1hcmdpbiB9LFxyXG4gICAgICAgICAgICBsaW1pdDogeyByOiBmYWxzZSwgdDogdGVzdExpbWl0IH0sXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IHsgcjogZmFsc2UsIHQ6IHRlc3RQYWRkaW5nIH0sXHJcbiAgICAgICAgICAgIGJlaGF2aW91cjogeyByOiB0cnVlLCB0OiB0ZXN0QmVoYXZpb3VyIH0sXHJcbiAgICAgICAgICAgIGFyaWFGb3JtYXQ6IHsgcjogZmFsc2UsIHQ6IHRlc3RBcmlhRm9ybWF0IH0sXHJcbiAgICAgICAgICAgIGZvcm1hdDogeyByOiBmYWxzZSwgdDogdGVzdEZvcm1hdCB9LFxyXG4gICAgICAgICAgICB0b29sdGlwczogeyByOiBmYWxzZSwgdDogdGVzdFRvb2x0aXBzIH0sXHJcbiAgICAgICAgICAgIGtleWJvYXJkU3VwcG9ydDogeyByOiB0cnVlLCB0OiB0ZXN0S2V5Ym9hcmRTdXBwb3J0IH0sXHJcbiAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudDogeyByOiBmYWxzZSwgdDogdGVzdERvY3VtZW50RWxlbWVudCB9LFxyXG4gICAgICAgICAgICBjc3NQcmVmaXg6IHsgcjogdHJ1ZSwgdDogdGVzdENzc1ByZWZpeCB9LFxyXG4gICAgICAgICAgICBjc3NDbGFzc2VzOiB7IHI6IHRydWUsIHQ6IHRlc3RDc3NDbGFzc2VzIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XHJcbiAgICAgICAgICAgIGNvbm5lY3Q6IGZhbHNlLFxyXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXHJcbiAgICAgICAgICAgIGJlaGF2aW91cjogXCJ0YXBcIixcclxuICAgICAgICAgICAgb3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgICAgICAgICBrZXlib2FyZFN1cHBvcnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGNzc1ByZWZpeDogXCJub1VpLVwiLFxyXG4gICAgICAgICAgICBjc3NDbGFzc2VzOiB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwidGFyZ2V0XCIsXHJcbiAgICAgICAgICAgICAgICBiYXNlOiBcImJhc2VcIixcclxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJvcmlnaW5cIixcclxuICAgICAgICAgICAgICAgIGhhbmRsZTogXCJoYW5kbGVcIixcclxuICAgICAgICAgICAgICAgIGhhbmRsZUxvd2VyOiBcImhhbmRsZS1sb3dlclwiLFxyXG4gICAgICAgICAgICAgICAgaGFuZGxlVXBwZXI6IFwiaGFuZGxlLXVwcGVyXCIsXHJcbiAgICAgICAgICAgICAgICB0b3VjaEFyZWE6IFwidG91Y2gtYXJlYVwiLFxyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbDogXCJob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbDogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZDogXCJiYWNrZ3JvdW5kXCIsXHJcbiAgICAgICAgICAgICAgICBjb25uZWN0OiBcImNvbm5lY3RcIixcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RzOiBcImNvbm5lY3RzXCIsXHJcbiAgICAgICAgICAgICAgICBsdHI6IFwibHRyXCIsXHJcbiAgICAgICAgICAgICAgICBydGw6IFwicnRsXCIsXHJcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IFwiZHJhZ2dhYmxlXCIsXHJcbiAgICAgICAgICAgICAgICBkcmFnOiBcInN0YXRlLWRyYWdcIixcclxuICAgICAgICAgICAgICAgIHRhcDogXCJzdGF0ZS10YXBcIixcclxuICAgICAgICAgICAgICAgIGFjdGl2ZTogXCJhY3RpdmVcIixcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IFwidG9vbHRpcFwiLFxyXG4gICAgICAgICAgICAgICAgcGlwczogXCJwaXBzXCIsXHJcbiAgICAgICAgICAgICAgICBwaXBzSG9yaXpvbnRhbDogXCJwaXBzLWhvcml6b250YWxcIixcclxuICAgICAgICAgICAgICAgIHBpcHNWZXJ0aWNhbDogXCJwaXBzLXZlcnRpY2FsXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXI6IFwibWFya2VyXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJIb3Jpem9udGFsOiBcIm1hcmtlci1ob3Jpem9udGFsXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJWZXJ0aWNhbDogXCJtYXJrZXItdmVydGljYWxcIixcclxuICAgICAgICAgICAgICAgIG1hcmtlck5vcm1hbDogXCJtYXJrZXItbm9ybWFsXCIsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJMYXJnZTogXCJtYXJrZXItbGFyZ2VcIixcclxuICAgICAgICAgICAgICAgIG1hcmtlclN1YjogXCJtYXJrZXItc3ViXCIsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJ2YWx1ZVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVIb3Jpem9udGFsOiBcInZhbHVlLWhvcml6b250YWxcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlVmVydGljYWw6IFwidmFsdWUtdmVydGljYWxcIixcclxuICAgICAgICAgICAgICAgIHZhbHVlTm9ybWFsOiBcInZhbHVlLW5vcm1hbFwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVMYXJnZTogXCJ2YWx1ZS1sYXJnZVwiLFxyXG4gICAgICAgICAgICAgICAgdmFsdWVTdWI6IFwidmFsdWUtc3ViXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEFyaWFGb3JtYXQgZGVmYXVsdHMgdG8gcmVndWxhciBmb3JtYXQsIGlmIGFueS5cclxuICAgICAgICBpZiAob3B0aW9ucy5mb3JtYXQgJiYgIW9wdGlvbnMuYXJpYUZvcm1hdCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmFyaWFGb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJ1biBhbGwgb3B0aW9ucyB0aHJvdWdoIGEgdGVzdGluZyBtZWNoYW5pc20gdG8gZW5zdXJlIGNvcnJlY3RcclxuICAgICAgICAvLyBpbnB1dC4gSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgb3B0aW9ucyBtaWdodCBnZXQgbW9kaWZpZWQgdG9cclxuICAgICAgICAvLyBiZSBoYW5kbGVkIHByb3Blcmx5LiBFLmcuIHdyYXBwaW5nIGludGVnZXJzIGluIGFycmF5cy5cclxuICAgICAgICBPYmplY3Qua2V5cyh0ZXN0cykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXNuJ3Qgc2V0LCBidXQgaXQgaXMgcmVxdWlyZWQsIHRocm93IGFuIGVycm9yLlxyXG4gICAgICAgICAgICBpZiAoIWlzU2V0KG9wdGlvbnNbbmFtZV0pICYmIGRlZmF1bHRzW25hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXN0c1tuYW1lXS5yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiAnXCIgKyBuYW1lICsgXCInIGlzIHJlcXVpcmVkLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGVzdHNbbmFtZV0udChwYXJzZWQsICFpc1NldChvcHRpb25zW25hbWVdKSA/IGRlZmF1bHRzW25hbWVdIDogb3B0aW9uc1tuYW1lXSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEZvcndhcmQgcGlwcyBvcHRpb25zXHJcbiAgICAgICAgcGFyc2VkLnBpcHMgPSBvcHRpb25zLnBpcHM7XHJcblxyXG4gICAgICAgIC8vIEFsbCByZWNlbnQgYnJvd3NlcnMgYWNjZXB0IHVucHJlZml4ZWQgdHJhbnNmb3JtLlxyXG4gICAgICAgIC8vIFdlIG5lZWQgLW1zLSBmb3IgSUU5IGFuZCAtd2Via2l0LSBmb3Igb2xkZXIgQW5kcm9pZDtcclxuICAgICAgICAvLyBBc3N1bWUgdXNlIG9mIC13ZWJraXQtIGlmIHVucHJlZml4ZWQgYW5kIC1tcy0gYXJlIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD10cmFuc2Zvcm1zMmRcclxuICAgICAgICB2YXIgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XHJcbiAgICAgICAgdmFyIG1zUHJlZml4ID0gZC5zdHlsZS5tc1RyYW5zZm9ybSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBub1ByZWZpeCA9IGQuc3R5bGUudHJhbnNmb3JtICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHBhcnNlZC50cmFuc2Zvcm1SdWxlID0gbm9QcmVmaXggPyBcInRyYW5zZm9ybVwiIDogbXNQcmVmaXggPyBcIm1zVHJhbnNmb3JtXCIgOiBcIndlYmtpdFRyYW5zZm9ybVwiO1xyXG5cclxuICAgICAgICAvLyBQaXBzIGRvbid0IG1vdmUsIHNvIHdlIGNhbiBwbGFjZSB0aGVtIHVzaW5nIGxlZnQvdG9wLlxyXG4gICAgICAgIHZhciBzdHlsZXMgPSBbW1wibGVmdFwiLCBcInRvcFwiXSwgW1wicmlnaHRcIiwgXCJib3R0b21cIl1dO1xyXG5cclxuICAgICAgICBwYXJzZWQuc3R5bGUgPSBzdHlsZXNbcGFyc2VkLmRpcl1bcGFyc2VkLm9ydF07XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy9lbmRyZWdpb25cclxuXHJcbiAgICBmdW5jdGlvbiBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucykge1xyXG4gICAgICAgIHZhciBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xyXG4gICAgICAgIHZhciBzdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSA9IGdldFN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lKCk7XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IHN1cHBvcnRzVG91Y2hBY3Rpb25Ob25lICYmIGdldFN1cHBvcnRzUGFzc2l2ZSgpO1xyXG5cclxuICAgICAgICAvLyBBbGwgdmFyaWFibGVzIGxvY2FsIHRvICdzY29wZScgYXJlIHByZWZpeGVkIHdpdGggJ3Njb3BlXydcclxuXHJcbiAgICAgICAgLy8gU2xpZGVyIERPTSBOb2Rlc1xyXG4gICAgICAgIHZhciBzY29wZV9UYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdmFyIHNjb3BlX0Jhc2U7XHJcbiAgICAgICAgdmFyIHNjb3BlX0hhbmRsZXM7XHJcbiAgICAgICAgdmFyIHNjb3BlX0Nvbm5lY3RzO1xyXG4gICAgICAgIHZhciBzY29wZV9QaXBzO1xyXG4gICAgICAgIHZhciBzY29wZV9Ub29sdGlwcztcclxuXHJcbiAgICAgICAgLy8gU2xpZGVyIHN0YXRlIHZhbHVlc1xyXG4gICAgICAgIHZhciBzY29wZV9TcGVjdHJ1bSA9IG9wdGlvbnMuc3BlY3RydW07XHJcbiAgICAgICAgdmFyIHNjb3BlX1ZhbHVlcyA9IFtdO1xyXG4gICAgICAgIHZhciBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcclxuICAgICAgICB2YXIgc2NvcGVfSGFuZGxlTnVtYmVycyA9IFtdO1xyXG4gICAgICAgIHZhciBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBzY29wZV9FdmVudHMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gRXhwb3NlZCBBUElcclxuICAgICAgICB2YXIgc2NvcGVfU2VsZjtcclxuXHJcbiAgICAgICAgLy8gRG9jdW1lbnQgTm9kZXNcclxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnQgPSB0YXJnZXQub3duZXJEb2N1bWVudDtcclxuICAgICAgICB2YXIgc2NvcGVfRG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5kb2N1bWVudEVsZW1lbnQgfHwgc2NvcGVfRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgIHZhciBzY29wZV9Cb2R5ID0gc2NvcGVfRG9jdW1lbnQuYm9keTtcclxuXHJcbiAgICAgICAgLy8gUGlwcyBjb25zdGFudHNcclxuICAgICAgICB2YXIgUElQU19OT05FID0gLTE7XHJcbiAgICAgICAgdmFyIFBJUFNfTk9fVkFMVUUgPSAwO1xyXG4gICAgICAgIHZhciBQSVBTX0xBUkdFX1ZBTFVFID0gMTtcclxuICAgICAgICB2YXIgUElQU19TTUFMTF9WQUxVRSA9IDI7XHJcblxyXG4gICAgICAgIC8vIEZvciBob3Jpem9udGFsIHNsaWRlcnMgaW4gc3RhbmRhcmQgbHRyIGRvY3VtZW50cyxcclxuICAgICAgICAvLyBtYWtlIC5ub1VpLW9yaWdpbiBvdmVyZmxvdyB0byB0aGUgbGVmdCBzbyB0aGUgZG9jdW1lbnQgZG9lc24ndCBzY3JvbGwuXHJcbiAgICAgICAgdmFyIHNjb3BlX0Rpck9mZnNldCA9IHNjb3BlX0RvY3VtZW50LmRpciA9PT0gXCJydGxcIiB8fCBvcHRpb25zLm9ydCA9PT0gMSA/IDAgOiAxMDA7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZXMgYSBub2RlLCBhZGRzIGl0IHRvIHRhcmdldCwgcmV0dXJucyB0aGUgbmV3IG5vZGUuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkTm9kZVRvKGFkZFRhcmdldCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXYgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoZGl2LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBhZGRUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBkaXY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgYSBvcmlnaW4gdG8gdGhlIGJhc2VcclxuICAgICAgICBmdW5jdGlvbiBhZGRPcmlnaW4oYmFzZSwgaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSBhZGROb2RlVG8oYmFzZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm9yaWdpbik7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGROb2RlVG8ob3JpZ2luLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlKTtcclxuXHJcbiAgICAgICAgICAgIGFkZE5vZGVUbyhoYW5kbGUsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50b3VjaEFyZWEpO1xyXG5cclxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcImRhdGEtaGFuZGxlXCIsIGhhbmRsZU51bWJlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5rZXlib2FyZFN1cHBvcnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvR2xvYmFsX2F0dHJpYnV0ZXMvdGFiaW5kZXhcclxuICAgICAgICAgICAgICAgIC8vIDAgPSBmb2N1c2FibGUgYW5kIHJlYWNoYWJsZVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudEtleWRvd24oZXZlbnQsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaGFuZGxlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzbGlkZXJcIik7XHJcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIG9wdGlvbnMub3J0ID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlTG93ZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhbmRsZU51bWJlciA9PT0gb3B0aW9ucy5oYW5kbGVzIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuaGFuZGxlVXBwZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5zZXJ0IG5vZGVzIGZvciBjb25uZWN0IGVsZW1lbnRzXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkQ29ubmVjdChiYXNlLCBhZGQpIHtcclxuICAgICAgICAgICAgaWYgKCFhZGQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhiYXNlLCBvcHRpb25zLmNzc0NsYXNzZXMuY29ubmVjdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBZGQgaGFuZGxlcyB0byB0aGUgc2xpZGVyIGJhc2UuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkRWxlbWVudHMoY29ubmVjdE9wdGlvbnMsIGJhc2UpIHtcclxuICAgICAgICAgICAgdmFyIGNvbm5lY3RCYXNlID0gYWRkTm9kZVRvKGJhc2UsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5jb25uZWN0cyk7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzID0gW107XHJcbiAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzID0gW107XHJcblxyXG4gICAgICAgICAgICBzY29wZV9Db25uZWN0cy5wdXNoKGFkZENvbm5lY3QoY29ubmVjdEJhc2UsIGNvbm5lY3RPcHRpb25zWzBdKSk7XHJcblxyXG4gICAgICAgICAgICAvLyBbOjo6Ok89PT09Tz09PT1PPT09PV1cclxuICAgICAgICAgICAgLy8gY29ubmVjdE9wdGlvbnMgPSBbMCwgMSwgMSwgMV1cclxuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5oYW5kbGVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIEtlZXAgYSBsaXN0IG9mIGFsbCBhZGRlZCBoYW5kbGVzLlxyXG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5wdXNoKGFkZE9yaWdpbihiYXNlLCBpKSk7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzW2ldID0gaTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLnB1c2goYWRkQ29ubmVjdChjb25uZWN0QmFzZSwgY29ubmVjdE9wdGlvbnNbaSArIDFdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYSBzaW5nbGUgc2xpZGVyLlxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFNsaWRlcihhZGRUYXJnZXQpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY2xhc3NlcyBhbmQgZGF0YSB0byB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXJnZXQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5sdHIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWRkQ2xhc3MoYWRkVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMucnRsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub3J0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5ob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGFkZFRhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnZlcnRpY2FsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhhZGRUYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5iYXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFRvb2x0aXAoaGFuZGxlLCBoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRvb2x0aXBzW2hhbmRsZU51bWJlcl0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVUbyhoYW5kbGUuZmlyc3RDaGlsZCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRvb2x0aXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNTbGlkZXJEaXNhYmxlZCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNjb3BlX1RhcmdldC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERpc2FibGUgdGhlIHNsaWRlciBkcmFnZ2luZyBpZiBhbnkgaGFuZGxlIGlzIGRpc2FibGVkXHJcbiAgICAgICAgZnVuY3Rpb24gaXNIYW5kbGVEaXNhYmxlZChoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXTtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU9yaWdpbi5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVRvb2x0aXBzKCkge1xyXG4gICAgICAgICAgICBpZiAoc2NvcGVfVG9vbHRpcHMpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KFwidXBkYXRlLnRvb2x0aXBzXCIpO1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMuZm9yRWFjaChmdW5jdGlvbih0b29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2x0aXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0b29sdGlwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX1Rvb2x0aXBzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHRvb2x0aXBzIG9wdGlvbiBpcyBhIHNob3J0aGFuZCBmb3IgdXNpbmcgdGhlICd1cGRhdGUnIGV2ZW50LlxyXG4gICAgICAgIGZ1bmN0aW9uIHRvb2x0aXBzKCkge1xyXG4gICAgICAgICAgICByZW1vdmVUb29sdGlwcygpO1xyXG5cclxuICAgICAgICAgICAgLy8gVG9vbHRpcHMgYXJlIGFkZGVkIHdpdGggb3B0aW9ucy50b29sdGlwcyBpbiBvcmlnaW5hbCBvcmRlci5cclxuICAgICAgICAgICAgc2NvcGVfVG9vbHRpcHMgPSBzY29wZV9IYW5kbGVzLm1hcChhZGRUb29sdGlwKTtcclxuXHJcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZS50b29sdGlwc1wiLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNjb3BlX1Rvb2x0aXBzW2hhbmRsZU51bWJlcl0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gdmFsdWVzW2hhbmRsZU51bWJlcl07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHNbaGFuZGxlTnVtYmVyXSAhPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlID0gb3B0aW9ucy50b29sdGlwc1toYW5kbGVOdW1iZXJdLnRvKHVuZW5jb2RlZFtoYW5kbGVOdW1iZXJdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzY29wZV9Ub29sdGlwc1toYW5kbGVOdW1iZXJdLmlubmVySFRNTCA9IGZvcm1hdHRlZFZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFyaWEoKSB7XHJcbiAgICAgICAgICAgIGJpbmRFdmVudChcInVwZGF0ZVwiLCBmdW5jdGlvbih2YWx1ZXMsIGhhbmRsZU51bWJlciwgdW5lbmNvZGVkLCB0YXAsIHBvc2l0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEFyaWEgVmFsdWVzIGZvciBhbGwgaGFuZGxlcywgYXMgYSBjaGFuZ2UgaW4gb25lIGNoYW5nZXMgbWluIGFuZCBtYXggdmFsdWVzIGZvciB0aGUgbmV4dC5cclxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbiA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBpbmRleCwgMCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IGNoZWNrSGFuZGxlUG9zaXRpb24oc2NvcGVfTG9jYXRpb25zLCBpbmRleCwgMTAwLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IHBvc2l0aW9uc1tpbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdHRlZCB2YWx1ZSBmb3IgZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gb3B0aW9ucy5hcmlhRm9ybWF0LnRvKHVuZW5jb2RlZFtpbmRleF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXAgdG8gc2xpZGVyIHJhbmdlIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyhtaW4pLnRvRml4ZWQoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKG1heCkudG9GaXhlZCgxKTtcclxuICAgICAgICAgICAgICAgICAgICBub3cgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcobm93KS50b0ZpeGVkKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZW1pblwiLCBtaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZS5jaGlsZHJlblswXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXZhbHVlbWF4XCIsIG1heCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtdmFsdWVub3dcIiwgbm93KTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUuY2hpbGRyZW5bMF0uc2V0QXR0cmlidXRlKFwiYXJpYS12YWx1ZXRleHRcIiwgdGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBnZXRHcm91cChtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQpIHtcclxuICAgICAgICAgICAgLy8gVXNlIHRoZSByYW5nZS5cclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwicmFuZ2VcIiB8fCBtb2RlID09PSBcInN0ZXBzXCIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS54VmFsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJjb3VudFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzIDwgMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogJ3ZhbHVlcycgKD49IDIpIHJlcXVpcmVkIGZvciBtb2RlICdjb3VudCcuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIERpdmlkZSAwIC0gMTAwIGluICdjb3VudCcgcGFydHMuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSB2YWx1ZXMgLSAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwcmVhZCA9IDEwMCAvIGludGVydmFsO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGludGVydmFsLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaW50ZXJ2YWxdID0gaW50ZXJ2YWwgKiBzcHJlYWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goMTAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBtb2RlID0gXCJwb3NpdGlvbnNcIjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG1vZGUgPT09IFwicG9zaXRpb25zXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1hcCBhbGwgcGVyY2VudGFnZXMgdG8gb24tcmFuZ2UgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHN0ZXBwZWQgPyBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHZhbHVlKSA6IHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gXCJ2YWx1ZXNcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIG11c3QgYmUgc3RlcHBlZCwgaXQgbmVlZHMgdG8gYmUgY29udmVydGVkIHRvIGEgcGVyY2VudGFnZSBmaXJzdC5cclxuICAgICAgICAgICAgICAgIGlmIChzdGVwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBwZXJjZW50YWdlLCBhcHBseSBzdGVwLCByZXR1cm4gdG8gdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoc2NvcGVfU3BlY3RydW0uZ2V0U3RlcChzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKHZhbHVlKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2FuIHNpbXBseSB1c2UgdGhlIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlU3ByZWFkKGRlbnNpdHksIG1vZGUsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNhZmVJbmNyZW1lbnQodmFsdWUsIGluY3JlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgZmxvYXRpbmcgcG9pbnQgdmFyaWFuY2UgYnkgZHJvcHBpbmcgdGhlIHNtYWxsZXN0IGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSArIGluY3JlbWVudCkudG9GaXhlZCg3KSAvIDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0ge307XHJcbiAgICAgICAgICAgIHZhciBmaXJzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsWzBdO1xyXG4gICAgICAgICAgICB2YXIgbGFzdEluUmFuZ2UgPSBzY29wZV9TcGVjdHJ1bS54VmFsW3Njb3BlX1NwZWN0cnVtLnhWYWwubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIHZhciBpZ25vcmVGaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgaWdub3JlTGFzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgcHJldlBjdCA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBncm91cCwgc29ydCBpdCBhbmQgZmlsdGVyIGF3YXkgYWxsIGR1cGxpY2F0ZXMuXHJcbiAgICAgICAgICAgIGdyb3VwID0gdW5pcXVlKFxyXG4gICAgICAgICAgICAgICAgZ3JvdXAuc2xpY2UoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByYW5nZSBzdGFydHMgd2l0aCB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcclxuICAgICAgICAgICAgICAgIGlnbm9yZUZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGlrZXdpc2UgZm9yIHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgICAgaWYgKGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdICE9PSBsYXN0SW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAucHVzaChsYXN0SW5SYW5nZSk7XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVMYXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihjdXJyZW50LCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgYW5kIHRoZSBsb3dlciArIHVwcGVyIHBvc2l0aW9ucy5cclxuICAgICAgICAgICAgICAgIHZhciBzdGVwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcTtcclxuICAgICAgICAgICAgICAgIHZhciBsb3cgPSBjdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpZ2ggPSBncm91cFtpbmRleCArIDFdO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld1BjdDtcclxuICAgICAgICAgICAgICAgIHZhciBwY3REaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBjdFBvcztcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWxTdGVwcztcclxuICAgICAgICAgICAgICAgIHZhciBzdGVwU2l6ZTtcclxuICAgICAgICAgICAgICAgIHZhciBpc1N0ZXBzID0gbW9kZSA9PT0gXCJzdGVwc1wiO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgJ3N0ZXBzJyBtb2RlLCB1c2UgdGhlIHByb3ZpZGVkIHN0ZXBzLlxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSdsbCBzdGVwIG9uIHRvIHRoZSBuZXh0IHN1YnJhbmdlLlxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RlcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwID0gc2NvcGVfU3BlY3RydW0ueE51bVN0ZXBzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGEgJ2Z1bGwnIHN0ZXAuXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0ZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwID0gaGlnaCAtIGxvdztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb3cgY2FuIGJlIDAsIHNvIHRlc3QgZm9yIGZhbHNlLiBJZiBoaWdoIGlzIHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBhdCB0aGUgbGFzdCBzdWJyYW5nZS4gSW5kZXggMCBpcyBhbHJlYWR5IGhhbmRsZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAobG93ID09PSBmYWxzZSB8fCBoaWdoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN0ZXAgaXNuJ3QgMCwgd2hpY2ggd291bGQgY2F1c2UgYW4gaW5maW5pdGUgbG9vcCAoIzY1NClcclxuICAgICAgICAgICAgICAgIHN0ZXAgPSBNYXRoLm1heChzdGVwLCAwLjAwMDAwMDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgYWxsIHN0ZXBzIGluIHRoZSBzdWJyYW5nZS5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBoaWdoOyBpID0gc2FmZUluY3JlbWVudChpLCBzdGVwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGVyY2VudGFnZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQgc3RlcCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHNpemUgZm9yIHRoZSBzdWJyYW5nZS5cclxuICAgICAgICAgICAgICAgICAgICBuZXdQY3QgPSBzY29wZV9TcGVjdHJ1bS50b1N0ZXBwaW5nKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzdGVwcyA9IHBjdERpZmZlcmVuY2UgLyBkZW5zaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWxTdGVwcyA9IE1hdGgucm91bmQoc3RlcHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHJhdGlvIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBwZXJjZW50YWdlLXNwYWNlIGEgcG9pbnQgaW5kaWNhdGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBhIGRlbnNpdHkgMSB0aGUgcG9pbnRzL3BlcmNlbnRhZ2UgPSAxLiBGb3IgZGVuc2l0eSAyLCB0aGF0IHBlcmNlbnRhZ2UgbmVlZHMgdG8gYmUgcmUtZGl2aWRlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgdG8gYW4gZXZlbiBudW1iZXIsIHRoZW4gZGl2aWRlIGJ5IHR3b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHNwcmVhZCB0aGUgb2Zmc2V0IG9uIGJvdGggc2lkZXMgb2YgdGhlIHJhbmdlLlxyXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBTaXplID0gcGN0RGlmZmVyZW5jZSAvIHJlYWxTdGVwcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGl2aWRlIGFsbCBwb2ludHMgZXZlbmx5LCBhZGRpbmcgdGhlIGNvcnJlY3QgbnVtYmVyIHRvIHRoaXMgc3VicmFuZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHVwIHRvIDw9IHNvIHRoYXQgMTAwJSBnZXRzIGEgcG9pbnQsIGV2ZW50IGlmIGlnbm9yZUxhc3QgaXMgc2V0LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocSA9IDE7IHEgPD0gcmVhbFN0ZXBzOyBxICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJhdGlvIGJldHdlZW4gdGhlIHJvdW5kZWQgdmFsdWUgYW5kIHRoZSBhY3R1YWwgc2l6ZSBtaWdodCBiZSB+MSUgb2ZmLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IHRoZSBwZXJjZW50YWdlIG9mZnNldCBieSB0aGUgbnVtYmVyIG9mIHBvaW50c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXIgc3VicmFuZ2UuIGRlbnNpdHkgPSAxIHdpbGwgcmVzdWx0IGluIDEwMCBwb2ludHMgb24gdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZ1bGwgcmFuZ2UsIDIgZm9yIDUwLCA0IGZvciAyNSwgZXRjLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwY3RQb3MgPSBwcmV2UGN0ICsgcSAqIHN0ZXBTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzW3BjdFBvcy50b0ZpeGVkKDUpXSA9IFtzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcocGN0UG9zKSwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHBvaW50IHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGdyb3VwLmluZGV4T2YoaSkgPiAtMSA/IFBJUFNfTEFSR0VfVkFMVUUgOiBpc1N0ZXBzID8gUElQU19TTUFMTF9WQUxVRSA6IFBJUFNfTk9fVkFMVUU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZm9yY2UgdGhlICdpZ25vcmVGaXJzdCcgb3B0aW9uIGJ5IG92ZXJ3cml0aW5nIHRoZSB0eXBlIGZvciAwLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5kZXggJiYgaWdub3JlRmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpID09PSBoaWdoICYmIGlnbm9yZUxhc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgdGhlICd0eXBlJyBvZiB0aGlzIHBvaW50LiAwID0gcGxhaW4sIDEgPSByZWFsIHZhbHVlLCAyID0gc3RlcCB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1tuZXdQY3QudG9GaXhlZCg1KV0gPSBbaSwgdHlwZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBlcmNlbnRhZ2UgY291bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldlBjdCA9IG5ld1BjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZE1hcmtpbmcoc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzY29wZV9Eb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuICAgICAgICAgICAgdmFyIHZhbHVlU2l6ZUNsYXNzZXMgPSBbXTtcclxuICAgICAgICAgICAgdmFsdWVTaXplQ2xhc3Nlc1tQSVBTX05PX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZU5vcm1hbDtcclxuICAgICAgICAgICAgdmFsdWVTaXplQ2xhc3Nlc1tQSVBTX0xBUkdFX1ZBTFVFXSA9IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZUxhcmdlO1xyXG4gICAgICAgICAgICB2YWx1ZVNpemVDbGFzc2VzW1BJUFNfU01BTExfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlU3ViO1xyXG5cclxuICAgICAgICAgICAgdmFyIG1hcmtlclNpemVDbGFzc2VzID0gW107XHJcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfTk9fVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlck5vcm1hbDtcclxuICAgICAgICAgICAgbWFya2VyU2l6ZUNsYXNzZXNbUElQU19MQVJHRV9WQUxVRV0gPSBvcHRpb25zLmNzc0NsYXNzZXMubWFya2VyTGFyZ2U7XHJcbiAgICAgICAgICAgIG1hcmtlclNpemVDbGFzc2VzW1BJUFNfU01BTExfVkFMVUVdID0gb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlclN1YjtcclxuXHJcbiAgICAgICAgICAgIHZhciB2YWx1ZU9yaWVudGF0aW9uQ2xhc3NlcyA9IFtvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVIb3Jpem9udGFsLCBvcHRpb25zLmNzc0NsYXNzZXMudmFsdWVWZXJ0aWNhbF07XHJcbiAgICAgICAgICAgIHZhciBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXMgPSBbb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlckhvcml6b250YWwsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5tYXJrZXJWZXJ0aWNhbF07XHJcblxyXG4gICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBvcHRpb25zLmNzc0NsYXNzZXMucGlwcyk7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIG9wdGlvbnMub3J0ID09PSAwID8gb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNIb3Jpem9udGFsIDogb3B0aW9ucy5jc3NDbGFzc2VzLnBpcHNWZXJ0aWNhbCk7XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRDbGFzc2VzKHR5cGUsIHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBzb3VyY2UgPT09IG9wdGlvbnMuY3NzQ2xhc3Nlcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmllbnRhdGlvbkNsYXNzZXMgPSBhID8gdmFsdWVPcmllbnRhdGlvbkNsYXNzZXMgOiBtYXJrZXJPcmllbnRhdGlvbkNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZUNsYXNzZXMgPSBhID8gdmFsdWVTaXplQ2xhc3NlcyA6IG1hcmtlclNpemVDbGFzc2VzO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UgKyBcIiBcIiArIG9yaWVudGF0aW9uQ2xhc3Nlc1tvcHRpb25zLm9ydF0gKyBcIiBcIiArIHNpemVDbGFzc2VzW3R5cGVdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhZGRTcHJlYWQob2Zmc2V0LCB2YWx1ZSwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGZpbHRlciBmdW5jdGlvbiwgaWYgaXQgaXMgc2V0LlxyXG4gICAgICAgICAgICAgICAgdHlwZSA9IGZpbHRlckZ1bmMgPyBmaWx0ZXJGdW5jKHZhbHVlLCB0eXBlKSA6IHR5cGU7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBJUFNfTk9ORSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBtYXJrZXIgZm9yIGV2ZXJ5IHBvaW50XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFkZE5vZGVUbyhlbGVtZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLm1hcmtlcik7XHJcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlW29wdGlvbnMuc3R5bGVdID0gb2Zmc2V0ICsgXCIlXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVmFsdWVzIGFyZSBvbmx5IGFwcGVuZGVkIGZvciBwb2ludHMgbWFya2VkICcxJyBvciAnMicuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA+IFBJUFNfTk9fVkFMVUUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gYWRkTm9kZVRvKGVsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTmFtZSA9IGdldENsYXNzZXModHlwZSwgb3B0aW9ucy5jc3NDbGFzc2VzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRhdGEtdmFsdWVcIiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSBvZmZzZXQgKyBcIiVcIjtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IGZvcm1hdHRlci50byh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFwcGVuZCBhbGwgcG9pbnRzLlxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzcHJlYWQpLmZvckVhY2goZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBhZGRTcHJlYWQob2Zmc2V0LCBzcHJlYWRbb2Zmc2V0XVswXSwgc3ByZWFkW29mZnNldF1bMV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUGlwcygpIHtcclxuICAgICAgICAgICAgaWYgKHNjb3BlX1BpcHMpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUVsZW1lbnQoc2NvcGVfUGlwcyk7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9QaXBzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcGlwcyhncmlkKSB7XHJcbiAgICAgICAgICAgIC8vIEZpeCAjNjY5XHJcbiAgICAgICAgICAgIHJlbW92ZVBpcHMoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBtb2RlID0gZ3JpZC5tb2RlO1xyXG4gICAgICAgICAgICB2YXIgZGVuc2l0eSA9IGdyaWQuZGVuc2l0eSB8fCAxO1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gZ3JpZC5maWx0ZXIgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBncmlkLnZhbHVlcyB8fCBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIHN0ZXBwZWQgPSBncmlkLnN0ZXBwZWQgfHwgZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdldEdyb3VwKG1vZGUsIHZhbHVlcywgc3RlcHBlZCk7XHJcbiAgICAgICAgICAgIHZhciBzcHJlYWQgPSBnZW5lcmF0ZVNwcmVhZChkZW5zaXR5LCBtb2RlLCBncm91cCk7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBncmlkLmZvcm1hdCB8fCB7XHJcbiAgICAgICAgICAgICAgICB0bzogTWF0aC5yb3VuZFxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfUGlwcyA9IHNjb3BlX1RhcmdldC5hcHBlbmRDaGlsZChhZGRNYXJraW5nKHNwcmVhZCwgZmlsdGVyLCBmb3JtYXQpKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9QaXBzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2hvcnRoYW5kIGZvciBiYXNlIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgZnVuY3Rpb24gYmFzZVNpemUoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWN0ID0gc2NvcGVfQmFzZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgdmFyIGFsdCA9IFwib2Zmc2V0XCIgKyBbXCJXaWR0aFwiLCBcIkhlaWdodFwiXVtvcHRpb25zLm9ydF07XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLm9ydCA9PT0gMCA/IHJlY3Qud2lkdGggfHwgc2NvcGVfQmFzZVthbHRdIDogcmVjdC5oZWlnaHQgfHwgc2NvcGVfQmFzZVthbHRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlciBmb3IgYXR0YWNoaW5nIGV2ZW50cyB0cm91Z2ggYSBwcm94eS5cclxuICAgICAgICBmdW5jdGlvbiBhdHRhY2hFdmVudChldmVudHMsIGVsZW1lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gJ2ZpbHRlcicgZXZlbnRzIHRvIHRoZSBzbGlkZXIuXHJcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYSBub2RlLCBub3QgYSBub2RlTGlzdFxyXG5cclxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBmaXhFdmVudChlLCBkYXRhLnBhZ2VPZmZzZXQsIGRhdGEudGFyZ2V0IHx8IGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGZpeEV2ZW50IHJldHVybnMgZmFsc2UgaWYgdGhpcyBldmVudCBoYXMgYSBkaWZmZXJlbnQgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIGhhbmRsaW5nIChtdWx0aS0pIHRvdWNoIGV2ZW50cztcclxuICAgICAgICAgICAgICAgIGlmICghZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkb05vdFJlamVjdCBpcyBwYXNzZWQgYnkgYWxsIGVuZCBldmVudHMgdG8gbWFrZSBzdXJlIHJlbGVhc2VkIHRvdWNoZXNcclxuICAgICAgICAgICAgICAgIC8vIGFyZSBub3QgcmVqZWN0ZWQsIGxlYXZpbmcgdGhlIHNsaWRlciBcInN0dWNrXCIgdG8gdGhlIGN1cnNvcjtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NsaWRlckRpc2FibGVkKCkgJiYgIWRhdGEuZG9Ob3RSZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBhbiBhY3RpdmUgJ3RhcCcgdHJhbnNpdGlvbiBpcyB0YWtpbmcgcGxhY2UuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3Moc2NvcGVfVGFyZ2V0LCBvcHRpb25zLmNzc0NsYXNzZXMudGFwKSAmJiAhZGF0YS5kb05vdFJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIHJpZ2h0IG9yIG1pZGRsZSBjbGlja3Mgb24gc3RhcnQgIzQ1NFxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaG92ZXIgJiYgZS5idXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vICdzdXBwb3J0c1Bhc3NpdmUnIGlzIG9ubHkgdHJ1ZSBpZiBhIGJyb3dzZXIgYWxzbyBzdXBwb3J0cyB0b3VjaC1hY3Rpb246IG5vbmUgaW4gQ1NTLlxyXG4gICAgICAgICAgICAgICAgLy8gaU9TIHNhZmFyaSBkb2VzIG5vdCwgc28gaXQgZG9lc24ndCBnZXQgdG8gYmVuZWZpdCBmcm9tIHBhc3NpdmUgc2Nyb2xsaW5nLiBpT1MgZG9lcyBzdXBwb3J0XHJcbiAgICAgICAgICAgICAgICAvLyB0b3VjaC1hY3Rpb246IG1hbmlwdWxhdGlvbiwgYnV0IHRoYXQgYWxsb3dzIHBhbm5pbmcsIHdoaWNoIGJyZWFrc1xyXG4gICAgICAgICAgICAgICAgLy8gc2xpZGVycyBhZnRlciB6b29taW5nL29uIG5vbi1yZXNwb25zaXZlIHBhZ2VzLlxyXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTMzMTEyXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBlLmNhbGNQb2ludCA9IGUucG9pbnRzW29wdGlvbnMub3J0XTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBldmVudCBoYW5kbGVyIHdpdGggdGhlIGV2ZW50IFsgYW5kIGFkZGl0aW9uYWwgZGF0YSBdLlxyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZGF0YSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQmluZCBhIGNsb3N1cmUgb24gdGhlIHRhcmdldCBmb3IgZXZlcnkgZXZlbnQgdHlwZS5cclxuICAgICAgICAgICAgZXZlbnRzLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbWV0aG9kLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IHBhc3NpdmU6IHRydWUgfSA6IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIG1ldGhvZHMucHVzaChbZXZlbnROYW1lLCBtZXRob2RdKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByb3ZpZGUgYSBjbGVhbiBldmVudCB3aXRoIHN0YW5kYXJkaXplZCBvZmZzZXQgdmFsdWVzLlxyXG4gICAgICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGUsIHBhZ2VPZmZzZXQsIGV2ZW50VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIC8vIEZpbHRlciB0aGUgZXZlbnQgdG8gcmVnaXN0ZXIgdGhlIHR5cGUsIHdoaWNoIGNhbiBiZVxyXG4gICAgICAgICAgICAvLyB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlci4gT2Zmc2V0IGNoYW5nZXMgbmVlZCB0byBiZVxyXG4gICAgICAgICAgICAvLyBtYWRlIG9uIGFuIGV2ZW50IHNwZWNpZmljIGJhc2lzLlxyXG4gICAgICAgICAgICB2YXIgdG91Y2ggPSBlLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID09PSAwO1xyXG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLnR5cGUuaW5kZXhPZihcIm1vdXNlXCIpID09PSAwO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnRlciA9IGUudHlwZS5pbmRleE9mKFwicG9pbnRlclwiKSA9PT0gMDtcclxuXHJcbiAgICAgICAgICAgIHZhciB4O1xyXG4gICAgICAgICAgICB2YXIgeTtcclxuXHJcbiAgICAgICAgICAgIC8vIElFMTAgaW1wbGVtZW50ZWQgcG9pbnRlciBldmVudHMgd2l0aCBhIHByZWZpeDtcclxuICAgICAgICAgICAgaWYgKGUudHlwZS5pbmRleE9mKFwiTVNQb2ludGVyXCIpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG9ubHkgdGhpbmcgb25lIGhhbmRsZSBzaG91bGQgYmUgY29uY2VybmVkIGFib3V0IGlzIHRoZSB0b3VjaGVzIHRoYXQgb3JpZ2luYXRlZCBvbiB0b3Agb2YgaXQuXHJcbiAgICAgICAgICAgIGlmICh0b3VjaCkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGEgdG91Y2ggb3JpZ2luYXRlZCBvbiB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgdmFyIGlzVG91Y2hPblRhcmdldCA9IGZ1bmN0aW9uKGNoZWNrVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tUb3VjaC50YXJnZXQgPT09IGV2ZW50VGFyZ2V0IHx8IGV2ZW50VGFyZ2V0LmNvbnRhaW5zKGNoZWNrVG91Y2gudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdG91Y2hzdGFydCBldmVudHMsIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZXJlIGlzIHN0aWxsIG5vIG1vcmUgdGhhbiBvbmVcclxuICAgICAgICAgICAgICAgIC8vIHRvdWNoIG9uIHRoZSB0YXJnZXQgc28gd2UgbG9vayBhbW9uZ3N0IGFsbCB0b3VjaGVzLlxyXG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VG91Y2hlcyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChlLnRvdWNoZXMsIGlzVG91Y2hPblRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzdXBwb3J0IG1vcmUgdGhhbiBvbmUgdG91Y2ggcGVyIGhhbmRsZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSB0YXJnZXRUb3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGUgb3RoZXIgY2FzZXMsIGZpbmQgb24gY2hhbmdlZFRvdWNoZXMgaXMgZW5vdWdoLlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRUb3VjaCA9IEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoZS5jaGFuZ2VkVG91Y2hlcywgaXNUb3VjaE9uVGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGlmIHRoZSB0YXJnZXQgdG91Y2ggaGFzIG5vdCBtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFRvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHggPSB0YXJnZXRUb3VjaC5wYWdlWDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gdGFyZ2V0VG91Y2gucGFnZVk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0IHx8IGdldFBhZ2VPZmZzZXQoc2NvcGVfRG9jdW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1vdXNlIHx8IHBvaW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIHggPSBlLmNsaWVudFggKyBwYWdlT2Zmc2V0Lng7XHJcbiAgICAgICAgICAgICAgICB5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBlLnBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0O1xyXG4gICAgICAgICAgICBlLnBvaW50cyA9IFt4LCB5XTtcclxuICAgICAgICAgICAgZS5jdXJzb3IgPSBtb3VzZSB8fCBwb2ludGVyOyAvLyBGaXggIzQzNVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUcmFuc2xhdGUgYSBjb29yZGluYXRlIGluIHRoZSBkb2N1bWVudCB0byBhIHBlcmNlbnRhZ2Ugb24gdGhlIHNsaWRlclxyXG4gICAgICAgIGZ1bmN0aW9uIGNhbGNQb2ludFRvUGVyY2VudGFnZShjYWxjUG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY2FsY1BvaW50IC0gb2Zmc2V0KHNjb3BlX0Jhc2UsIG9wdGlvbnMub3J0KTtcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKGxvY2F0aW9uICogMTAwKSAvIGJhc2VTaXplKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDbGFtcCBwcm9wb3NhbCBiZXR3ZWVuIDAlIGFuZCAxMDAlXHJcbiAgICAgICAgICAgIC8vIE91dC1vZi1ib3VuZCBjb29yZGluYXRlcyBtYXkgb2NjdXIgd2hlbiAubm9VaS1iYXNlIHBzZXVkby1lbGVtZW50c1xyXG4gICAgICAgICAgICAvLyBhcmUgdXNlZCAoZS5nLiBjb250YWluZWQgaGFuZGxlcyBmZWF0dXJlKVxyXG4gICAgICAgICAgICBwcm9wb3NhbCA9IGxpbWl0KHByb3Bvc2FsKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRpciA/IDEwMCAtIHByb3Bvc2FsIDogcHJvcG9zYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGaW5kIGhhbmRsZSBjbG9zZXN0IHRvIGEgY2VydGFpbiBwZXJjZW50YWdlIG9uIHRoZSBzbGlkZXJcclxuICAgICAgICBmdW5jdGlvbiBnZXRDbG9zZXN0SGFuZGxlKHByb3Bvc2FsKSB7XHJcbiAgICAgICAgICAgIHZhciBjbG9zZXN0ID0gMTAwO1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZWQgaGFuZGxlcyBhcmUgaWdub3JlZFxyXG4gICAgICAgICAgICAgICAgaWYgKGlzSGFuZGxlRGlzYWJsZWQoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBNYXRoLmFicyhzY29wZV9Mb2NhdGlvbnNbaW5kZXhdIC0gcHJvcG9zYWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwb3MgPCBjbG9zZXN0IHx8IChwb3MgPT09IDEwMCAmJiBjbG9zZXN0ID09PSAxMDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdCA9IHBvcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlTnVtYmVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyZSAnZW5kJyB3aGVuIGEgbW91c2Ugb3IgcGVuIGxlYXZlcyB0aGUgZG9jdW1lbnQuXHJcbiAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRMZWF2ZShldmVudCwgZGF0YSkge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJtb3VzZW91dFwiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA9PT0gXCJIVE1MXCIgJiYgZXZlbnQucmVsYXRlZFRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRFbmQoZXZlbnQsIGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgbW92ZW1lbnQgb24gZG9jdW1lbnQgZm9yIGhhbmRsZSBhbmQgcmFuZ2UgZHJhZy5cclxuICAgICAgICBmdW5jdGlvbiBldmVudE1vdmUoZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gRml4ICM0OThcclxuICAgICAgICAgICAgLy8gQ2hlY2sgdmFsdWUgb2YgLmJ1dHRvbnMgaW4gJ3N0YXJ0JyB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpbiBJRTEwIG1vYmlsZSAoZGF0YS5idXR0b25zUHJvcGVydHkpLlxyXG4gICAgICAgICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzkyNzAwNS9tb2JpbGUtaWUxMC13aW5kb3dzLXBob25lLWJ1dHRvbnMtcHJvcGVydHktb2YtcG9pbnRlcm1vdmUtZXZlbnQtYWx3YXlzLXplcm9cclxuICAgICAgICAgICAgLy8gSUU5IGhhcyAuYnV0dG9ucyBhbmQgLndoaWNoIHplcm8gb24gbW91c2Vtb3ZlLlxyXG4gICAgICAgICAgICAvLyBGaXJlZm94IGJyZWFrcyB0aGUgc3BlYyBNRE4gZGVmaW5lcy5cclxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoXCJNU0lFIDlcIikgPT09IC0xICYmIGV2ZW50LmJ1dHRvbnMgPT09IDAgJiYgZGF0YS5idXR0b25zUHJvcGVydHkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBldmVudEVuZChldmVudCwgZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBtb3ZpbmcgdXAgb3IgZG93blxyXG4gICAgICAgICAgICB2YXIgbW92ZW1lbnQgPSAob3B0aW9ucy5kaXIgPyAtMSA6IDEpICogKGV2ZW50LmNhbGNQb2ludCAtIGRhdGEuc3RhcnRDYWxjUG9pbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbW92ZW1lbnQgaW50byBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciB3aWR0aC9oZWlnaHRcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gKG1vdmVtZW50ICogMTAwKSAvIGRhdGEuYmFzZVNpemU7XHJcblxyXG4gICAgICAgICAgICBtb3ZlSGFuZGxlcyhtb3ZlbWVudCA+IDAsIHByb3Bvc2FsLCBkYXRhLmxvY2F0aW9ucywgZGF0YS5oYW5kbGVOdW1iZXJzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVuYmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudCwgY2FsbCBjYWxsYmFja3MuXHJcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRFbmQoZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGhhbmRsZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyByZW1vdmUgdGhlIGNsYXNzLlxyXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGRhdGEuaGFuZGxlLCBvcHRpb25zLmNzc0NsYXNzZXMuYWN0aXZlKTtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0FjdGl2ZUhhbmRsZXNDb3VudCAtPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxyXG4gICAgICAgICAgICBkYXRhLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0RvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGNbMF0sIGNbMV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBkcmFnZ2luZyBjbGFzcy5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xyXG4gICAgICAgICAgICAgICAgc2V0WmluZGV4KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnNvciBzdHlsZXMgYW5kIHRleHQtc2VsZWN0aW9uIGV2ZW50cyBib3VuZCB0byB0aGUgYm9keS5cclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5jdXJzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzY29wZV9Cb2R5LnN0eWxlLmN1cnNvciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfQm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgcHJldmVudERlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkYXRhLmhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgIGZpcmVFdmVudChcImNoYW5nZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJlbmRcIiwgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxyXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50U3RhcnQoZXZlbnQsIGRhdGEpIHtcclxuICAgICAgICAgICAgLy8gSWdub3JlIGV2ZW50IGlmIGFueSBoYW5kbGUgaXMgZGlzYWJsZWRcclxuICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlTnVtYmVycy5zb21lKGlzSGFuZGxlRGlzYWJsZWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBoYW5kbGU7XHJcblxyXG4gICAgICAgICAgICBpZiAoZGF0YS5oYW5kbGVOdW1iZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZU9yaWdpbiA9IHNjb3BlX0hhbmRsZXNbZGF0YS5oYW5kbGVOdW1iZXJzWzBdXTtcclxuXHJcbiAgICAgICAgICAgICAgICBoYW5kbGUgPSBoYW5kbGVPcmlnaW4uY2hpbGRyZW5bMF07XHJcbiAgICAgICAgICAgICAgICBzY29wZV9BY3RpdmVIYW5kbGVzQ291bnQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSBoYW5kbGUgYXMgJ2FjdGl2ZScgc28gaXQgY2FuIGJlIHN0eWxlZC5cclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGhhbmRsZSwgb3B0aW9ucy5jc3NDbGFzc2VzLmFjdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEEgZHJhZyBzaG91bGQgbmV2ZXIgcHJvcGFnYXRlIHVwIHRvIHRoZSAndGFwJyBldmVudC5cclxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWNvcmQgdGhlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBtb3ZlIGFuZCBlbmQgZXZlbnRzLlxyXG4gICAgICAgICAgICB2YXIgbW92ZUV2ZW50ID0gYXR0YWNoRXZlbnQoYWN0aW9ucy5tb3ZlLCBzY29wZV9Eb2N1bWVudEVsZW1lbnQsIGV2ZW50TW92ZSwge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGV2ZW50IHRhcmdldCBoYXMgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHByb3BhZ2F0ZSB0aGUgb3JpZ2luYWwgb25lIHNvIHRoYXQgd2Uga2VlcFxyXG4gICAgICAgICAgICAgICAgLy8gcmVseWluZyBvbiBpdCB0byBleHRyYWN0IHRhcmdldCB0b3VjaGVzLlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRDYWxjUG9pbnQ6IGV2ZW50LmNhbGNQb2ludCxcclxuICAgICAgICAgICAgICAgIGJhc2VTaXplOiBiYXNlU2l6ZSgpLFxyXG4gICAgICAgICAgICAgICAgcGFnZU9mZnNldDogZXZlbnQucGFnZU9mZnNldCxcclxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IGRhdGEuaGFuZGxlTnVtYmVycyxcclxuICAgICAgICAgICAgICAgIGJ1dHRvbnNQcm9wZXJ0eTogZXZlbnQuYnV0dG9ucyxcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uczogc2NvcGVfTG9jYXRpb25zLnNsaWNlKClcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZW5kRXZlbnQgPSBhdHRhY2hFdmVudChhY3Rpb25zLmVuZCwgc2NvcGVfRG9jdW1lbnRFbGVtZW50LCBldmVudEVuZCwge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxyXG4gICAgICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgb3V0RXZlbnQgPSBhdHRhY2hFdmVudChcIm1vdXNlb3V0XCIsIHNjb3BlX0RvY3VtZW50RWxlbWVudCwgZG9jdW1lbnRMZWF2ZSwge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGhhbmRsZSxcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxyXG4gICAgICAgICAgICAgICAgZG9Ob3RSZWplY3Q6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzOiBkYXRhLmhhbmRsZU51bWJlcnNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBwdXNoZWQgdGhlIGxpc3RlbmVycyBpbiB0aGUgbGlzdGVuZXIgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGluZ1xyXG4gICAgICAgICAgICAvLyBhIG5ldyBvbmUgYXMgaXQgaGFzIGFscmVhZHkgYmVlbiBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXJzLlxyXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIG1vdmVFdmVudC5jb25jYXQoZW5kRXZlbnQsIG91dEV2ZW50KSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUZXh0IHNlbGVjdGlvbiBpc24ndCBhbiBpc3N1ZSBvbiB0b3VjaCBkZXZpY2VzLFxyXG4gICAgICAgICAgICAvLyBzbyBhZGRpbmcgY3Vyc29yIHN0eWxlcyBjYW4gYmUgc2tpcHBlZC5cclxuICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnNvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cclxuICAgICAgICAgICAgICAgIHNjb3BlX0JvZHkuc3R5bGUuY3Vyc29yID0gZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSB0YXJnZXQgd2l0aCBhIGRyYWdnaW5nIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLmRyYWcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdGV4dCBzZWxlY3Rpb24gd2hlbiBkcmFnZ2luZyB0aGUgaGFuZGxlcy5cclxuICAgICAgICAgICAgICAgIC8vIEluIG5vVWlTbGlkZXIgPD0gOS4yLjAsIHRoaXMgd2FzIGhhbmRsZWQgYnkgY2FsbGluZyBwcmV2ZW50RGVmYXVsdCBvbiBtb3VzZS90b3VjaCBzdGFydC9tb3ZlLFxyXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgc2Nyb2xsIGJsb2NraW5nLiBUaGUgc2VsZWN0c3RhcnQgZXZlbnQgaXMgc3VwcG9ydGVkIGJ5IEZpcmVGb3ggc3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDUyLFxyXG4gICAgICAgICAgICAgICAgLy8gbWVhbmluZyB0aGUgb25seSBob2xkb3V0IGlzIGlPUyBTYWZhcmkuIFRoaXMgZG9lc24ndCBtYXR0ZXI6IHRleHQgc2VsZWN0aW9uIGlzbid0IHRyaWdnZXJlZCB0aGVyZS5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSAnY3Vyc29yJyBmbGFnIGlzIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwOi8vY2FuaXVzZS5jb20vI3NlYXJjaD1zZWxlY3RzdGFydFxyXG4gICAgICAgICAgICAgICAgc2NvcGVfQm9keS5hZGRFdmVudExpc3RlbmVyKFwic2VsZWN0c3RhcnRcIiwgcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGF0YS5oYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzdGFydFwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1vdmUgY2xvc2VzdCBoYW5kbGUgdG8gdGFwcGVkIGxvY2F0aW9uLlxyXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50VGFwKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSB0YXAgZXZlbnQgc2hvdWxkbid0IHByb3BhZ2F0ZSB1cFxyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwcm9wb3NhbCA9IGNhbGNQb2ludFRvUGVyY2VudGFnZShldmVudC5jYWxjUG9pbnQpO1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlTnVtYmVyID0gZ2V0Q2xvc2VzdEhhbmRsZShwcm9wb3NhbCk7XHJcblxyXG4gICAgICAgICAgICAvLyBUYWNrbGUgdGhlIGNhc2UgdGhhdCBhbGwgaGFuZGxlcyBhcmUgJ2Rpc2FibGVkJy5cclxuICAgICAgICAgICAgaWYgKGhhbmRsZU51bWJlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRmxhZyB0aGUgc2xpZGVyIGFzIGl0IGlzIG5vdyBpbiBhIHRyYW5zaXRpb25hbCBzdGF0ZS5cclxuICAgICAgICAgICAgLy8gVHJhbnNpdGlvbiB0YWtlcyBhIGNvbmZpZ3VyYWJsZSBhbW91bnQgb2YgbXMgKGRlZmF1bHQgMzAwKS4gUmUtZW5hYmxlIHRoZSBzbGlkZXIgYWZ0ZXIgdGhhdC5cclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmV2ZW50cy5zbmFwKSB7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzc0ZvcihzY29wZV9UYXJnZXQsIG9wdGlvbnMuY3NzQ2xhc3Nlcy50YXAsIG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBwcm9wb3NhbCwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBzZXRaaW5kZXgoKTtcclxuXHJcbiAgICAgICAgICAgIGZpcmVFdmVudChcInNsaWRlXCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIsIHRydWUpO1xyXG4gICAgICAgICAgICBmaXJlRXZlbnQoXCJjaGFuZ2VcIiwgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlciwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudHMuc25hcCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRTdGFydChldmVudCwgeyBoYW5kbGVOdW1iZXJzOiBbaGFuZGxlTnVtYmVyXSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRmlyZXMgYSAnaG92ZXInIGV2ZW50IGZvciBhIGhvdmVyZWQgbW91c2UvcGVuIHBvc2l0aW9uLlxyXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50SG92ZXIoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FsID0gY2FsY1BvaW50VG9QZXJjZW50YWdlKGV2ZW50LmNhbGNQb2ludCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdG8gPSBzY29wZV9TcGVjdHJ1bS5nZXRTdGVwKHByb3Bvc2FsKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKHRvKTtcclxuXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNjb3BlX0V2ZW50cykuZm9yRWFjaChmdW5jdGlvbih0YXJnZXRFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFwiaG92ZXJcIiA9PT0gdGFyZ2V0RXZlbnQuc3BsaXQoXCIuXCIpWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGVfU2VsZiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZXMga2V5ZG93biBvbiBmb2N1c2VkIGhhbmRsZXNcclxuICAgICAgICAvLyBEb24ndCBtb3ZlIHRoZSBkb2N1bWVudCB3aGVuIHByZXNzaW5nIGFycm93IGtleXMgb24gZm9jdXNlZCBoYW5kbGVzXHJcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRLZXlkb3duKGV2ZW50LCBoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgaWYgKGlzU2xpZGVyRGlzYWJsZWQoKSB8fCBpc0hhbmRsZURpc2FibGVkKGhhbmRsZU51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxLZXlzID0gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdO1xyXG4gICAgICAgICAgICB2YXIgdmVydGljYWxLZXlzID0gW1wiRG93blwiLCBcIlVwXCJdO1xyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlyICYmICFvcHRpb25zLm9ydCkge1xyXG4gICAgICAgICAgICAgICAgLy8gT24gYW4gcmlnaHQtdG8tbGVmdCBzbGlkZXIsIHRoZSBsZWZ0IGFuZCByaWdodCBrZXlzIGFjdCBpbnZlcnRlZFxyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEtleXMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMub3J0ICYmICFvcHRpb25zLmRpcikge1xyXG4gICAgICAgICAgICAgICAgLy8gT24gYSB0b3AtdG8tYm90dG9tIHNsaWRlciwgdGhlIHVwIGFuZCBkb3duIGtleXMgYWN0IGludmVydGVkXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEtleXMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdHJpcCBcIkFycm93XCIgZm9yIElFIGNvbXBhdGliaWxpdHkuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleVxyXG4gICAgICAgICAgICB2YXIga2V5ID0gZXZlbnQua2V5LnJlcGxhY2UoXCJBcnJvd1wiLCBcIlwiKTtcclxuICAgICAgICAgICAgdmFyIGlzRG93biA9IGtleSA9PT0gdmVydGljYWxLZXlzWzBdIHx8IGtleSA9PT0gaG9yaXpvbnRhbEtleXNbMF07XHJcbiAgICAgICAgICAgIHZhciBpc1VwID0ga2V5ID09PSB2ZXJ0aWNhbEtleXNbMV0gfHwga2V5ID09PSBob3Jpem9udGFsS2V5c1sxXTtcclxuXHJcbiAgICAgICAgICAgIGlmICghaXNEb3duICYmICFpc1VwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBpc0Rvd24gPyAwIDogMTtcclxuICAgICAgICAgICAgdmFyIHN0ZXBzID0gZ2V0TmV4dFN0ZXBzRm9ySGFuZGxlKGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgIHZhciBzdGVwID0gc3RlcHNbZGlyZWN0aW9uXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEF0IHRoZSBlZGdlIG9mIGEgc2xpZGVyLCBkbyBub3RoaW5nXHJcbiAgICAgICAgICAgIGlmIChzdGVwID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vIHN0ZXAgc2V0LCB1c2UgdGhlIGRlZmF1bHQgb2YgMTAlIG9mIHRoZSBzdWItcmFuZ2VcclxuICAgICAgICAgICAgaWYgKHN0ZXAgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwID0gc2NvcGVfU3BlY3RydW0uZ2V0RGVmYXVsdFN0ZXAoc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0sIGlzRG93biwgMTApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIG92ZXIgemVyby1sZW5ndGggcmFuZ2VzICgjOTQ4KTtcclxuICAgICAgICAgICAgc3RlcCA9IE1hdGgubWF4KHN0ZXAsIDAuMDAwMDAwMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNyZW1lbnQgZm9yIGRvd24gc3RlcHNcclxuICAgICAgICAgICAgc3RlcCA9IChpc0Rvd24gPyAtMSA6IDEpICogc3RlcDtcclxuXHJcbiAgICAgICAgICAgIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl0gKyBzdGVwLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEF0dGFjaCBldmVudHMgdG8gc2V2ZXJhbCBzbGlkZXIgcGFydHMuXHJcbiAgICAgICAgZnVuY3Rpb24gYmluZFNsaWRlckV2ZW50cyhiZWhhdmlvdXIpIHtcclxuICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBzdGFuZGFyZCBkcmFnIGV2ZW50IHRvIHRoZSBoYW5kbGVzLlxyXG4gICAgICAgICAgICBpZiAoIWJlaGF2aW91ci5maXhlZCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcGVfSGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZSwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgYXJlIG9ubHkgYm91bmQgdG8gdGhlIHZpc3VhbCBoYW5kbGVcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50LCBub3QgdGhlICdyZWFsJyBvcmlnaW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICBhdHRhY2hFdmVudChhY3Rpb25zLnN0YXJ0LCBoYW5kbGUuY2hpbGRyZW5bMF0sIGV2ZW50U3RhcnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTnVtYmVyczogW2luZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEF0dGFjaCB0aGUgdGFwIGV2ZW50IHRvIHRoZSBzbGlkZXIgYmFzZS5cclxuICAgICAgICAgICAgaWYgKGJlaGF2aW91ci50YXApIHtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMuc3RhcnQsIHNjb3BlX0Jhc2UsIGV2ZW50VGFwLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpcmUgaG92ZXIgZXZlbnRzXHJcbiAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuaG92ZXIpIHtcclxuICAgICAgICAgICAgICAgIGF0dGFjaEV2ZW50KGFjdGlvbnMubW92ZSwgc2NvcGVfQmFzZSwgZXZlbnRIb3Zlciwge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdmVyOiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTWFrZSB0aGUgcmFuZ2UgZHJhZ2dhYmxlLlxyXG4gICAgICAgICAgICBpZiAoYmVoYXZpb3VyLmRyYWcpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0Nvbm5lY3RzLmZvckVhY2goZnVuY3Rpb24oY29ubmVjdCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdCA9PT0gZmFsc2UgfHwgaW5kZXggPT09IDAgfHwgaW5kZXggPT09IHNjb3BlX0Nvbm5lY3RzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUJlZm9yZSA9IHNjb3BlX0hhbmRsZXNbaW5kZXggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlQWZ0ZXIgPSBzY29wZV9IYW5kbGVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRIb2xkZXJzID0gW2Nvbm5lY3RdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhjb25uZWN0LCBvcHRpb25zLmNzc0NsYXNzZXMuZHJhZ2dhYmxlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgcmFuZ2UgaXMgZml4ZWQsIHRoZSBlbnRpcmUgcmFuZ2UgY2FuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmUgZHJhZ2dlZCBieSB0aGUgaGFuZGxlcy4gVGhlIGhhbmRsZSBpbiB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAvLyBvcmlnaW4gd2lsbCBwcm9wYWdhdGUgdGhlIHN0YXJ0IGV2ZW50IHVwd2FyZCxcclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaXQgbmVlZHMgdG8gYmUgYm91bmQgbWFudWFsbHkgb24gdGhlIG90aGVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZWhhdmlvdXIuZml4ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQmVmb3JlLmNoaWxkcmVuWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLnB1c2goaGFuZGxlQWZ0ZXIuY2hpbGRyZW5bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRIb2xkZXJzLmZvckVhY2goZnVuY3Rpb24oZXZlbnRIb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoRXZlbnQoYWN0aW9ucy5zdGFydCwgZXZlbnRIb2xkZXIsIGV2ZW50U3RhcnQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXM6IFtoYW5kbGVCZWZvcmUsIGhhbmRsZUFmdGVyXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnM6IFtpbmRleCAtIDEsIGluZGV4XVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdHRhY2ggYW4gZXZlbnQgdG8gdGhpcyBzbGlkZXIsIHBvc3NpYmx5IGluY2x1ZGluZyBhIG5hbWVzcGFjZVxyXG4gICAgICAgIGZ1bmN0aW9uIGJpbmRFdmVudChuYW1lc3BhY2VkRXZlbnQsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdID0gc2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0gfHwgW107XHJcbiAgICAgICAgICAgIHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdLnB1c2goY2FsbGJhY2spO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGV2ZW50IGJvdW5kIGlzICd1cGRhdGUsJyBmaXJlIGl0IGltbWVkaWF0ZWx5IGZvciBhbGwgaGFuZGxlcy5cclxuICAgICAgICAgICAgaWYgKG5hbWVzcGFjZWRFdmVudC5zcGxpdChcIi5cIilbMF0gPT09IFwidXBkYXRlXCIpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVW5kbyBhdHRhY2htZW50IG9mIGV2ZW50XHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnQobmFtZXNwYWNlZEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudCA9IG5hbWVzcGFjZWRFdmVudCAmJiBuYW1lc3BhY2VkRXZlbnQuc3BsaXQoXCIuXCIpWzBdO1xyXG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gZXZlbnQgJiYgbmFtZXNwYWNlZEV2ZW50LnN1YnN0cmluZyhldmVudC5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGJpbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0RXZlbnQgPSBiaW5kLnNwbGl0KFwiLlwiKVswXTtcclxuICAgICAgICAgICAgICAgIHZhciB0TmFtZXNwYWNlID0gYmluZC5zdWJzdHJpbmcodEV2ZW50Lmxlbmd0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCghZXZlbnQgfHwgZXZlbnQgPT09IHRFdmVudCkgJiYgKCFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSB0TmFtZXNwYWNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXh0ZXJuYWwgZXZlbnQgaGFuZGxpbmdcclxuICAgICAgICBmdW5jdGlvbiBmaXJlRXZlbnQoZXZlbnROYW1lLCBoYW5kbGVOdW1iZXIsIHRhcCkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzY29wZV9FdmVudHMpLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0RXZlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSB0YXJnZXRFdmVudC5zcGxpdChcIi5cIilbMF07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gZXZlbnRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVfRXZlbnRzW3RhcmdldEV2ZW50XS5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIHNsaWRlciBwdWJsaWMgQVBJIGFzIHRoZSBzY29wZSAoJ3RoaXMnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfU2VsZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB2YWx1ZXMgYXMgYXJyYXksIHNvIGFyZ18xW2FyZ18yXSBpcyBhbHdheXMgdmFsaWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZV9WYWx1ZXMubWFwKG9wdGlvbnMuZm9ybWF0LnRvKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBpbmRleCwgMCBvciAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbi1mb3JtYXR0ZWQgc2xpZGVyIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVfVmFsdWVzLnNsaWNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFdmVudCBpcyBmaXJlZCBieSB0YXAsIHRydWUgb3IgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcCB8fCBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgb2Zmc2V0IG9mIHRoZSBoYW5kbGUsIGluIHJlbGF0aW9uIHRvIHRoZSBzbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9ucy5zbGljZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3BsaXQgb3V0IHRoZSBoYW5kbGUgcG9zaXRpb25pbmcgbG9naWMgc28gdGhlIE1vdmUgZXZlbnQgY2FuIHVzZSBpdCwgdG9vXHJcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tIYW5kbGVQb3NpdGlvbihyZWZlcmVuY2UsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGdldFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIEZvciBzbGlkZXJzIHdpdGggbXVsdGlwbGUgaGFuZGxlcywgbGltaXQgbW92ZW1lbnQgdG8gdGhlIG90aGVyIGhhbmRsZS5cclxuICAgICAgICAgICAgLy8gQXBwbHkgdGhlIG1hcmdpbiBvcHRpb24gYnkgYWRkaW5nIGl0IHRvIHRoZSBoYW5kbGUgcG9zaXRpb25zLlxyXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmICFvcHRpb25zLmV2ZW50cy51bmNvbnN0cmFpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9va0JhY2t3YXJkICYmIGhhbmRsZU51bWJlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyIC0gMV0gKyBvcHRpb25zLm1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxvb2tGb3J3YXJkICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgKyAxXSAtIG9wdGlvbnMubWFyZ2luKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGxpbWl0IG9wdGlvbiBoYXMgdGhlIG9wcG9zaXRlIGVmZmVjdCwgbGltaXRpbmcgaGFuZGxlcyB0byBhXHJcbiAgICAgICAgICAgIC8vIG1heGltdW0gZGlzdGFuY2UgZnJvbSBhbm90aGVyLiBMaW1pdCBtdXN0IGJlID4gMCwgYXMgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgIC8vIGhhbmRsZXMgd291bGQgYmUgdW5tb3ZhYmxlLlxyXG4gICAgICAgICAgICBpZiAoc2NvcGVfSGFuZGxlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMubGltaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsb29rQmFja3dhcmQgJiYgaGFuZGxlTnVtYmVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJlZmVyZW5jZVtoYW5kbGVOdW1iZXIgLSAxXSArIG9wdGlvbnMubGltaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChsb29rRm9yd2FyZCAmJiBoYW5kbGVOdW1iZXIgPCBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWF4KHRvLCByZWZlcmVuY2VbaGFuZGxlTnVtYmVyICsgMV0gLSBvcHRpb25zLmxpbWl0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHBhZGRpbmcgb3B0aW9uIGtlZXBzIHRoZSBoYW5kbGVzIGEgY2VydGFpbiBkaXN0YW5jZSBmcm9tIHRoZVxyXG4gICAgICAgICAgICAvLyBlZGdlcyBvZiB0aGUgc2xpZGVyLiBQYWRkaW5nIG11c3QgYmUgPiAwLlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYWRkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG8gPSBNYXRoLm1heCh0bywgb3B0aW9ucy5wYWRkaW5nWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVyID09PSBzY29wZV9IYW5kbGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0byA9IE1hdGgubWluKHRvLCAxMDAgLSBvcHRpb25zLnBhZGRpbmdbMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLmdldFN0ZXAodG8pO1xyXG5cclxuICAgICAgICAgICAgLy8gTGltaXQgcGVyY2VudGFnZSB0byB0aGUgMCAtIDEwMCByYW5nZVxyXG4gICAgICAgICAgICB0byA9IGxpbWl0KHRvKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiBmYWxzZSBpZiBoYW5kbGUgY2FuJ3QgbW92ZVxyXG4gICAgICAgICAgICBpZiAodG8gPT09IHJlZmVyZW5jZVtoYW5kbGVOdW1iZXJdICYmICFnZXRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2VzIHNsaWRlciBvcmllbnRhdGlvbiB0byBjcmVhdGUgQ1NTIHJ1bGVzLiBhID0gYmFzZSB2YWx1ZTtcclxuICAgICAgICBmdW5jdGlvbiBpblJ1bGVPcmRlcih2LCBhKSB7XHJcbiAgICAgICAgICAgIHZhciBvID0gb3B0aW9ucy5vcnQ7XHJcbiAgICAgICAgICAgIHJldHVybiAobyA/IGEgOiB2KSArIFwiLCBcIiArIChvID8gdiA6IGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTW92ZXMgaGFuZGxlKHMpIGJ5IGEgcGVyY2VudGFnZVxyXG4gICAgICAgIC8vIChib29sLCAlIHRvIG1vdmUsIFslIHdoZXJlIGhhbmRsZSBzdGFydGVkLCAuLi5dLCBbaW5kZXggaW4gc2NvcGVfSGFuZGxlcywgLi4uXSlcclxuICAgICAgICBmdW5jdGlvbiBtb3ZlSGFuZGxlcyh1cHdhcmQsIHByb3Bvc2FsLCBsb2NhdGlvbnMsIGhhbmRsZU51bWJlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHByb3Bvc2FscyA9IGxvY2F0aW9ucy5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGIgPSBbIXVwd2FyZCwgdXB3YXJkXTtcclxuICAgICAgICAgICAgdmFyIGYgPSBbdXB3YXJkLCAhdXB3YXJkXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvcHkgaGFuZGxlTnVtYmVycyBzbyB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRhdGFzZXRcclxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycyA9IGhhbmRsZU51bWJlcnMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSB3aGljaCBoYW5kbGUgaXMgJ2xlYWRpbmcnLlxyXG4gICAgICAgICAgICAvLyBJZiB0aGF0IG9uZSBjYW4ndCBtb3ZlIHRoZSBzZWNvbmQgY2FuJ3QgZWl0aGVyLlxyXG4gICAgICAgICAgICBpZiAodXB3YXJkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAxOiBnZXQgdGhlIG1heGltdW0gcGVyY2VudGFnZSB0aGF0IGFueSBvZiB0aGUgaGFuZGxlcyBjYW4gbW92ZVxyXG4gICAgICAgICAgICBpZiAoaGFuZGxlTnVtYmVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyLCBvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWxzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOdW1iZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdICsgcHJvcG9zYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJbb10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZbb10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpZiBvbmUgb2YgdGhlIGhhbmRsZXMgY2FuJ3QgbW92ZS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wb3NhbCA9IHRvIC0gcHJvcG9zYWxzW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3Bvc2Fsc1toYW5kbGVOdW1iZXJdID0gdG87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHVzaW5nIG9uZSBoYW5kbGUsIGNoZWNrIGJhY2t3YXJkIEFORCBmb3J3YXJkXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYiA9IGYgPSBbdHJ1ZV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RlcCAyOiBUcnkgdG8gc2V0IHRoZSBoYW5kbGVzIHdpdGggdGhlIGZvdW5kIHBlcmNlbnRhZ2VcclxuICAgICAgICAgICAgaGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlciwgbykge1xyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCBsb2NhdGlvbnNbaGFuZGxlTnVtYmVyXSArIHByb3Bvc2FsLCBiW29dLCBmW29dKSB8fCBzdGF0ZTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTdGVwIDM6IElmIGEgaGFuZGxlIG1vdmVkLCBmaXJlIGV2ZW50c1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZU51bWJlcnMuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJ1cGRhdGVcIiwgaGFuZGxlTnVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQoXCJzbGlkZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRha2VzIGEgYmFzZSB2YWx1ZSBhbmQgYW4gb2Zmc2V0LiBUaGlzIG9mZnNldCBpcyB1c2VkIGZvciB0aGUgY29ubmVjdCBiYXIgc2l6ZS5cclxuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBkZXNpZ24gZm9yIHRoaXMgZmVhdHVyZSwgdGhlIG9yaWdpbiBlbGVtZW50IHdhcyAxJSB3aWRlLlxyXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIGEgcm91bmRpbmcgYnVnIGluIENocm9tZSBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGltcGxlbWVudCB0aGlzIGZlYXR1cmVcclxuICAgICAgICAvLyBpbiB0aGlzIG1hbm5lcjogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Nzk4MjIzXHJcbiAgICAgICAgZnVuY3Rpb24gdHJhbnNmb3JtRGlyZWN0aW9uKGEsIGIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlyID8gMTAwIC0gYSAtIGIgOiBhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlcyBzY29wZV9Mb2NhdGlvbnMgYW5kIHNjb3BlX1ZhbHVlcywgdXBkYXRlcyB2aXN1YWwgc3RhdGVcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVIYW5kbGVQb3NpdGlvbihoYW5kbGVOdW1iZXIsIHRvKSB7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsb2NhdGlvbnMuXHJcbiAgICAgICAgICAgIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID0gdG87XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byB0aGUgc2xpZGVyIHN0ZXBwaW5nL3JhbmdlLlxyXG4gICAgICAgICAgICBzY29wZV9WYWx1ZXNbaGFuZGxlTnVtYmVyXSA9IHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyh0byk7XHJcblxyXG4gICAgICAgICAgICB2YXIgcnVsZSA9IFwidHJhbnNsYXRlKFwiICsgaW5SdWxlT3JkZXIodHJhbnNmb3JtRGlyZWN0aW9uKHRvLCAwKSAtIHNjb3BlX0Rpck9mZnNldCArIFwiJVwiLCBcIjBcIikgKyBcIilcIjtcclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLnN0eWxlW29wdGlvbnMudHJhbnNmb3JtUnVsZV0gPSBydWxlO1xyXG5cclxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdChoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0KGhhbmRsZU51bWJlciArIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlcyBiZWZvcmUgdGhlIHNsaWRlciBtaWRkbGUgYXJlIHN0YWNrZWQgbGF0ZXIgPSBoaWdoZXIsXHJcbiAgICAgICAgLy8gSGFuZGxlcyBhZnRlciB0aGUgbWlkZGxlIGxhdGVyIGlzIGxvd2VyXHJcbiAgICAgICAgLy8gW1s3XSBbOF0gLi4uLi4uLi4uLiB8IC4uLi4uLi4uLi4gWzVdIFs0XVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldFppbmRleCgpIHtcclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdID4gNTAgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgekluZGV4ID0gMyArIChzY29wZV9IYW5kbGVzLmxlbmd0aCArIGRpciAqIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgICAgICBzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl0uc3R5bGUuekluZGV4ID0gekluZGV4O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRlc3Qgc3VnZ2VzdGVkIHZhbHVlcyBhbmQgYXBwbHkgbWFyZ2luLCBzdGVwLlxyXG4gICAgICAgIGZ1bmN0aW9uIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHRvLCBsb29rQmFja3dhcmQsIGxvb2tGb3J3YXJkKSB7XHJcbiAgICAgICAgICAgIHRvID0gY2hlY2tIYW5kbGVQb3NpdGlvbihzY29wZV9Mb2NhdGlvbnMsIGhhbmRsZU51bWJlciwgdG8sIGxvb2tCYWNrd2FyZCwgbG9va0ZvcndhcmQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdXBkYXRlSGFuZGxlUG9zaXRpb24oaGFuZGxlTnVtYmVyLCB0byk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZXMgc3R5bGUgYXR0cmlidXRlIGZvciBjb25uZWN0IG5vZGVzXHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdChpbmRleCkge1xyXG4gICAgICAgICAgICAvLyBTa2lwIGNvbm5lY3RzIHNldCB0byBmYWxzZVxyXG4gICAgICAgICAgICBpZiAoIXNjb3BlX0Nvbm5lY3RzW2luZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgbCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBoID0gMTAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsID0gc2NvcGVfTG9jYXRpb25zW2luZGV4IC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gc2NvcGVfQ29ubmVjdHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgaCA9IHNjb3BlX0xvY2F0aW9uc1tpbmRleF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFdlIHVzZSB0d28gcnVsZXM6XHJcbiAgICAgICAgICAgIC8vICd0cmFuc2xhdGUnIHRvIGNoYW5nZSB0aGUgbGVmdC90b3Agb2Zmc2V0O1xyXG4gICAgICAgICAgICAvLyAnc2NhbGUnIHRvIGNoYW5nZSB0aGUgd2lkdGggb2YgdGhlIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIC8vIEFzIHRoZSBlbGVtZW50IGhhcyBhIHdpZHRoIG9mIDEwMCUsIGEgdHJhbnNsYXRpb24gb2YgMTAwJSBpcyBlcXVhbCB0byAxMDAlIG9mIHRoZSBwYXJlbnQgKC5ub1VpLWJhc2UpXHJcbiAgICAgICAgICAgIHZhciBjb25uZWN0V2lkdGggPSBoIC0gbDtcclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZVJ1bGUgPSBcInRyYW5zbGF0ZShcIiArIGluUnVsZU9yZGVyKHRyYW5zZm9ybURpcmVjdGlvbihsLCBjb25uZWN0V2lkdGgpICsgXCIlXCIsIFwiMFwiKSArIFwiKVwiO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVSdWxlID0gXCJzY2FsZShcIiArIGluUnVsZU9yZGVyKGNvbm5lY3RXaWR0aCAvIDEwMCwgXCIxXCIpICsgXCIpXCI7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9Db25uZWN0c1tpbmRleF0uc3R5bGVbb3B0aW9ucy50cmFuc2Zvcm1SdWxlXSA9IHRyYW5zbGF0ZVJ1bGUgKyBcIiBcIiArIHNjYWxlUnVsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBhcnNlcyB2YWx1ZSBwYXNzZWQgdG8gLnNldCBtZXRob2QuIFJldHVybnMgY3VycmVudCB2YWx1ZSBpZiBub3QgcGFyc2UtYWJsZS5cclxuICAgICAgICBmdW5jdGlvbiByZXNvbHZlVG9WYWx1ZSh0bywgaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgIC8vIFNldHRpbmcgd2l0aCBudWxsIGluZGljYXRlcyBhbiAnaWdub3JlJy5cclxuICAgICAgICAgICAgLy8gSW5wdXR0aW5nICdmYWxzZScgaXMgaW52YWxpZC5cclxuICAgICAgICAgICAgaWYgKHRvID09PSBudWxsIHx8IHRvID09PSBmYWxzZSB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgZm9ybWF0dGVkIG51bWJlciB3YXMgcGFzc2VkLCBhdHRlbXB0IHRvIGRlY29kZSBpdC5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgdG8gPSBTdHJpbmcodG8pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0byA9IG9wdGlvbnMuZm9ybWF0LmZyb20odG8pO1xyXG4gICAgICAgICAgICB0byA9IHNjb3BlX1NwZWN0cnVtLnRvU3RlcHBpbmcodG8pO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcGFyc2luZyB0aGUgbnVtYmVyIGZhaWxlZCwgdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxyXG4gICAgICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzTmFOKHRvKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlX0xvY2F0aW9uc1toYW5kbGVOdW1iZXJdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG87XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHNsaWRlciB2YWx1ZS5cclxuICAgICAgICBmdW5jdGlvbiB2YWx1ZVNldChpbnB1dCwgZmlyZVNldEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBhc0FycmF5KGlucHV0KTtcclxuICAgICAgICAgICAgdmFyIGlzSW5pdCA9IHNjb3BlX0xvY2F0aW9uc1swXSA9PT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgLy8gRXZlbnQgZmlyZXMgYnkgZGVmYXVsdFxyXG4gICAgICAgICAgICBmaXJlU2V0RXZlbnQgPSBmaXJlU2V0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIWZpcmVTZXRFdmVudDtcclxuXHJcbiAgICAgICAgICAgIC8vIEFuaW1hdGlvbiBpcyBvcHRpb25hbC5cclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBpbml0aWFsIHZhbHVlcyB3ZXJlIHNldCBiZWZvcmUgdXNpbmcgYW5pbWF0ZWQgcGxhY2VtZW50LlxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRlICYmICFpc0luaXQpIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzRm9yKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzLnRhcCwgb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEZpcnN0IHBhc3MsIHdpdGhvdXQgbG9va0FoZWFkIGJ1dCB3aXRoIGxvb2tCYWNrd2FyZC4gVmFsdWVzIGFyZSBzZXQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxyXG4gICAgICAgICAgICBzY29wZV9IYW5kbGVOdW1iZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRIYW5kbGUoaGFuZGxlTnVtYmVyLCByZXNvbHZlVG9WYWx1ZSh2YWx1ZXNbaGFuZGxlTnVtYmVyXSwgaGFuZGxlTnVtYmVyKSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNlY29uZCBwYXNzLiBOb3cgdGhhdCBhbGwgYmFzZSB2YWx1ZXMgYXJlIHNldCwgYXBwbHkgY29uc3RyYWludHNcclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgc2V0SGFuZGxlKGhhbmRsZU51bWJlciwgc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl0sIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHNldFppbmRleCgpO1xyXG5cclxuICAgICAgICAgICAgc2NvcGVfSGFuZGxlTnVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZU51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwidXBkYXRlXCIsIGhhbmRsZU51bWJlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmlyZSB0aGUgZXZlbnQgb25seSBmb3IgaGFuZGxlcyB0aGF0IHJlY2VpdmVkIGEgbmV3IHZhbHVlLCBhcyBwZXIgIzU3OVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1toYW5kbGVOdW1iZXJdICE9PSBudWxsICYmIGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudChcInNldFwiLCBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IHNsaWRlciB0byBpbml0aWFsIHZhbHVlc1xyXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlUmVzZXQoZmlyZVNldEV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhbHVlU2V0KG9wdGlvbnMuc3RhcnQsIGZpcmVTZXRFdmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdmFsdWUgZm9yIGEgc2luZ2xlIGhhbmRsZVxyXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlU2V0SGFuZGxlKGhhbmRsZU51bWJlciwgdmFsdWUsIGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgbnVtZXJpYyBpbnB1dFxyXG4gICAgICAgICAgICBoYW5kbGVOdW1iZXIgPSBOdW1iZXIoaGFuZGxlTnVtYmVyKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghKGhhbmRsZU51bWJlciA+PSAwICYmIGhhbmRsZU51bWJlciA8IHNjb3BlX0hhbmRsZU51bWJlcnMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlciAoXCIgKyBWRVJTSU9OICsgXCIpOiBpbnZhbGlkIGhhbmRsZSBudW1iZXIsIGdvdDogXCIgKyBoYW5kbGVOdW1iZXIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMb29rIGJvdGggYmFja3dhcmQgYW5kIGZvcndhcmQsIHNpbmNlIHdlIGRvbid0IHdhbnQgdGhpcyBoYW5kbGUgdG8gXCJwdXNoXCIgb3RoZXIgaGFuZGxlcyAoIzk2MCk7XHJcbiAgICAgICAgICAgIHNldEhhbmRsZShoYW5kbGVOdW1iZXIsIHJlc29sdmVUb1ZhbHVlKHZhbHVlLCBoYW5kbGVOdW1iZXIpLCB0cnVlLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIGZpcmVFdmVudChcInVwZGF0ZVwiLCBoYW5kbGVOdW1iZXIpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGZpcmVTZXRFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KFwic2V0XCIsIGhhbmRsZU51bWJlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgc2xpZGVyIHZhbHVlLlxyXG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlR2V0KCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gc2NvcGVfVmFsdWVzLm1hcChvcHRpb25zLmZvcm1hdC50byk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxyXG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1swXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZXMgY2xhc3NlcyBmcm9tIHRoZSByb290IGFuZCBlbXB0aWVzIGl0LlxyXG4gICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNzc0NsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5jc3NDbGFzc2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgb3B0aW9ucy5jc3NDbGFzc2VzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoc2NvcGVfVGFyZ2V0LmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgIHNjb3BlX1RhcmdldC5yZW1vdmVDaGlsZChzY29wZV9UYXJnZXQuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGRlbGV0ZSBzY29wZV9UYXJnZXQubm9VaVNsaWRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGdldE5leHRTdGVwc0ZvckhhbmRsZShoYW5kbGVOdW1iZXIpIHtcclxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gc2NvcGVfTG9jYXRpb25zW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgIHZhciBuZWFyYnlTdGVwcyA9IHNjb3BlX1NwZWN0cnVtLmdldE5lYXJieVN0ZXBzKGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NvcGVfVmFsdWVzW2hhbmRsZU51bWJlcl07XHJcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBuZWFyYnlTdGVwcy50aGlzU3RlcC5zdGVwO1xyXG4gICAgICAgICAgICB2YXIgZGVjcmVtZW50ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHNuYXBwZWQsIGRpcmVjdGx5IHVzZSBkZWZpbmVkIHN0ZXAgdmFsdWVcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc25hcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuc3RhcnRWYWx1ZSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWUgfHwgbnVsbFxyXG4gICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgdmFsdWUgaW4gdGhpcyBzdGVwIG1vdmVzIGludG8gdGhlIG5leHQgc3RlcCxcclxuICAgICAgICAgICAgLy8gdGhlIGluY3JlbWVudCBpcyB0aGUgc3RhcnQgb2YgdGhlIG5leHQgc3RlcCAtIHRoZSBjdXJyZW50IHZhbHVlXHJcbiAgICAgICAgICAgIGlmIChpbmNyZW1lbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgKyBpbmNyZW1lbnQgPiBuZWFyYnlTdGVwcy5zdGVwQWZ0ZXIuc3RhcnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IG5lYXJieVN0ZXBzLnN0ZXBBZnRlci5zdGFydFZhbHVlIC0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBiZXlvbmQgdGhlIHN0YXJ0aW5nIHBvaW50XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0YXJ0VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGRlY3JlbWVudCA9IG5lYXJieVN0ZXBzLnRoaXNTdGVwLnN0ZXA7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmVhcmJ5U3RlcHMuc3RlcEJlZm9yZS5zdGVwID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGEgaGFuZGxlIGlzIGF0IHRoZSBzdGFydCBvZiBhIHN0ZXAsIGl0IGFsd2F5cyBzdGVwcyBiYWNrIGludG8gdGhlIHByZXZpb3VzIHN0ZXAgZmlyc3RcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSB2YWx1ZSAtIG5lYXJieVN0ZXBzLnN0ZXBCZWZvcmUuaGlnaGVzdFN0ZXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vdywgaWYgYXQgdGhlIHNsaWRlciBlZGdlcywgdGhlcmUgaXMgbm8gaW4vZGVjcmVtZW50XHJcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBcyBwZXIgIzM5MSwgdGhlIGNvbXBhcmlzb24gZm9yIHRoZSBkZWNyZW1lbnQgc3RlcCBjYW4gaGF2ZSBzb21lIHJvdW5kaW5nIGlzc3Vlcy5cclxuICAgICAgICAgICAgdmFyIHN0ZXBEZWNpbWFscyA9IHNjb3BlX1NwZWN0cnVtLmNvdW50U3RlcERlY2ltYWxzKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZCBwZXIgIzM5MVxyXG4gICAgICAgICAgICBpZiAoaW5jcmVtZW50ICE9PSBudWxsICYmIGluY3JlbWVudCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGluY3JlbWVudCA9IE51bWJlcihpbmNyZW1lbnQudG9GaXhlZChzdGVwRGVjaW1hbHMpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGRlY3JlbWVudCAhPT0gbnVsbCAmJiBkZWNyZW1lbnQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnQgPSBOdW1iZXIoZGVjcmVtZW50LnRvRml4ZWQoc3RlcERlY2ltYWxzKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbZGVjcmVtZW50LCBpbmNyZW1lbnRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgc2l6ZSBmb3IgdGhlIHNsaWRlci5cclxuICAgICAgICBmdW5jdGlvbiBnZXROZXh0U3RlcHMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzY29wZV9IYW5kbGVOdW1iZXJzLm1hcChnZXROZXh0U3RlcHNGb3JIYW5kbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlYWJsZTogbWFyZ2luLCBsaW1pdCwgcGFkZGluZywgc3RlcCwgcmFuZ2UsIGFuaW1hdGUsIHNuYXBcclxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVPcHRpb25zKG9wdGlvbnNUb1VwZGF0ZSwgZmlyZVNldEV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFNwZWN0cnVtIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIHJhbmdlLCBzbmFwLCBkaXJlY3Rpb24gYW5kIHN0ZXAgb3B0aW9ucy5cclxuICAgICAgICAgICAgLy8gJ3NuYXAnIGFuZCAnc3RlcCcgY2FuIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgIC8vIElmICdzbmFwJyBhbmQgJ3N0ZXAnIGFyZSBub3QgcGFzc2VkLCB0aGV5IHNob3VsZCByZW1haW4gdW5jaGFuZ2VkLlxyXG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlR2V0KCk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdXBkYXRlQWJsZSA9IFtcclxuICAgICAgICAgICAgICAgIFwibWFyZ2luXCIsXHJcbiAgICAgICAgICAgICAgICBcImxpbWl0XCIsXHJcbiAgICAgICAgICAgICAgICBcInBhZGRpbmdcIixcclxuICAgICAgICAgICAgICAgIFwicmFuZ2VcIixcclxuICAgICAgICAgICAgICAgIFwiYW5pbWF0ZVwiLFxyXG4gICAgICAgICAgICAgICAgXCJzbmFwXCIsXHJcbiAgICAgICAgICAgICAgICBcInN0ZXBcIixcclxuICAgICAgICAgICAgICAgIFwiZm9ybWF0XCIsXHJcbiAgICAgICAgICAgICAgICBcInBpcHNcIixcclxuICAgICAgICAgICAgICAgIFwidG9vbHRpcHNcIlxyXG4gICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBjaGFuZ2Ugb3B0aW9ucyB0aGF0IHdlJ3JlIGFjdHVhbGx5IHBhc3NlZCB0byB1cGRhdGUuXHJcbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdW5kZWZpbmVkLiBudWxsIHJlbW92ZXMgdGhlIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNUb1VwZGF0ZVtuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxPcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHZhciBuZXdPcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIC8vIExvYWQgbmV3IG9wdGlvbnMgaW50byB0aGUgc2xpZGVyIHN0YXRlXHJcbiAgICAgICAgICAgIHVwZGF0ZUFibGUuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1RvVXBkYXRlW25hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW25hbWVdID0gbmV3T3B0aW9uc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBzY29wZV9TcGVjdHJ1bSA9IG5ld09wdGlvbnMuc3BlY3RydW07XHJcblxyXG4gICAgICAgICAgICAvLyBMaW1pdCwgbWFyZ2luIGFuZCBwYWRkaW5nIGRlcGVuZCBvbiB0aGUgc3BlY3RydW0gYnV0IGFyZSBzdG9yZWQgb3V0c2lkZSBvZiBpdC4gKCM2NzcpXHJcbiAgICAgICAgICAgIG9wdGlvbnMubWFyZ2luID0gbmV3T3B0aW9ucy5tYXJnaW47XHJcbiAgICAgICAgICAgIG9wdGlvbnMubGltaXQgPSBuZXdPcHRpb25zLmxpbWl0O1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBuZXdPcHRpb25zLnBhZGRpbmc7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcGlwcywgcmVtb3ZlcyBleGlzdGluZy5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGlwcykge1xyXG4gICAgICAgICAgICAgICAgcGlwcyhvcHRpb25zLnBpcHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlUGlwcygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcHMsIHJlbW92ZXMgZXhpc3RpbmcuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXBzKSB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwcygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHMoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBzbyB2YWx1ZVNldCBmb3JjZXMgYW4gdXBkYXRlLlxyXG4gICAgICAgICAgICBzY29wZV9Mb2NhdGlvbnMgPSBbXTtcclxuICAgICAgICAgICAgdmFsdWVTZXQob3B0aW9uc1RvVXBkYXRlLnN0YXJ0IHx8IHYsIGZpcmVTZXRFdmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbml0aWFsaXphdGlvbiBzdGVwc1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldHVwU2xpZGVyKCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGJhc2UgZWxlbWVudCwgaW5pdGlhbGl6ZSBIVE1MIGFuZCBzZXQgY2xhc3Nlcy5cclxuICAgICAgICAgICAgLy8gQWRkIGhhbmRsZXMgYW5kIGNvbm5lY3QgZWxlbWVudHMuXHJcbiAgICAgICAgICAgIHNjb3BlX0Jhc2UgPSBhZGRTbGlkZXIoc2NvcGVfVGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgIGFkZEVsZW1lbnRzKG9wdGlvbnMuY29ubmVjdCwgc2NvcGVfQmFzZSk7XHJcblxyXG4gICAgICAgICAgICAvLyBBdHRhY2ggdXNlciBldmVudHMuXHJcbiAgICAgICAgICAgIGJpbmRTbGlkZXJFdmVudHMob3B0aW9ucy5ldmVudHMpO1xyXG5cclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBwdWJsaWMgdmFsdWUgbWV0aG9kIHRvIHNldCB0aGUgc3RhcnQgdmFsdWVzLlxyXG4gICAgICAgICAgICB2YWx1ZVNldChvcHRpb25zLnN0YXJ0KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnBpcHMpIHtcclxuICAgICAgICAgICAgICAgIHBpcHMob3B0aW9ucy5waXBzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcHMpIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXBzKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFyaWEoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldHVwU2xpZGVyKCk7XHJcblxyXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcclxuICAgICAgICBzY29wZV9TZWxmID0ge1xyXG4gICAgICAgICAgICBkZXN0cm95OiBkZXN0cm95LFxyXG4gICAgICAgICAgICBzdGVwczogZ2V0TmV4dFN0ZXBzLFxyXG4gICAgICAgICAgICBvbjogYmluZEV2ZW50LFxyXG4gICAgICAgICAgICBvZmY6IHJlbW92ZUV2ZW50LFxyXG4gICAgICAgICAgICBnZXQ6IHZhbHVlR2V0LFxyXG4gICAgICAgICAgICBzZXQ6IHZhbHVlU2V0LFxyXG4gICAgICAgICAgICBzZXRIYW5kbGU6IHZhbHVlU2V0SGFuZGxlLFxyXG4gICAgICAgICAgICByZXNldDogdmFsdWVSZXNldCxcclxuICAgICAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAgICBfX21vdmVIYW5kbGVzOiBmdW5jdGlvbihhLCBiLCBjKSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlSGFuZGxlcyhhLCBiLCBzY29wZV9Mb2NhdGlvbnMsIGMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvcHRpb25zOiBvcmlnaW5hbE9wdGlvbnMsIC8vIElzc3VlICM2MDAsICM2NzhcclxuICAgICAgICAgICAgdXBkYXRlT3B0aW9uczogdXBkYXRlT3B0aW9ucyxcclxuICAgICAgICAgICAgdGFyZ2V0OiBzY29wZV9UYXJnZXQsIC8vIElzc3VlICM1OTdcclxuICAgICAgICAgICAgcmVtb3ZlUGlwczogcmVtb3ZlUGlwcyxcclxuICAgICAgICAgICAgcmVtb3ZlVG9vbHRpcHM6IHJlbW92ZVRvb2x0aXBzLFxyXG4gICAgICAgICAgICBwaXBzOiBwaXBzIC8vIElzc3VlICM1OTRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gc2NvcGVfU2VsZjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSdW4gdGhlIHN0YW5kYXJkIGluaXRpYWxpemVyXHJcbiAgICBmdW5jdGlvbiBpbml0aWFsaXplKHRhcmdldCwgb3JpZ2luYWxPcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5ub2RlTmFtZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyIChcIiArIFZFUlNJT04gKyBcIik6IGNyZWF0ZSByZXF1aXJlcyBhIHNpbmdsZSBlbGVtZW50LCBnb3Q6IFwiICsgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBzbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgaWYgKHRhcmdldC5ub1VpU2xpZGVyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXIgKFwiICsgVkVSU0lPTiArIFwiKTogU2xpZGVyIHdhcyBhbHJlYWR5IGluaXRpYWxpemVkLlwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRlc3QgdGhlIG9wdGlvbnMgYW5kIGNyZWF0ZSB0aGUgc2xpZGVyIGVudmlyb25tZW50O1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gdGVzdE9wdGlvbnMob3JpZ2luYWxPcHRpb25zLCB0YXJnZXQpO1xyXG4gICAgICAgIHZhciBhcGkgPSBzY29wZSh0YXJnZXQsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIHRhcmdldC5ub1VpU2xpZGVyID0gYXBpO1xyXG5cclxuICAgICAgICByZXR1cm4gYXBpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIGZvciBmdXR1cmUgZXhwYW5kYWJpbGl0eTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLCBkb24ndCB1c2UgdGhpcyBpbiB5b3VyIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgIF9fc3BlY3RydW06IFNwZWN0cnVtLFxyXG4gICAgICAgIHZlcnNpb246IFZFUlNJT04sXHJcbiAgICAgICAgY3JlYXRlOiBpbml0aWFsaXplXHJcbiAgICB9O1xyXG59KTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n')},44:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=template&id=a95d0764&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.items.length > 0),expression:\"items.length > 0\"}],staticClass:\"catalog-control__menu catalog-control__menu_white\"},[_c('div',{staticClass:\"category-list-mob\"},[_c('div',{staticClass:\"category-list-mob__item\",class:{active: _vm.checkedItems.length === 0},on:{\"click\":_vm.onReset}},[_c('div',{staticClass:\"category-list-mob__label\"},[_vm._v(_vm._s(_vm.filter.name === 'Category' ? 'Все категории' : 'Все'))])]),_vm._v(\" \"),_vm._l((_vm.items),function(item){return _c('div',{staticClass:\"category-list-mob__item\",class:{active: item.checked, 'category-list-mob__item_parent': !_vm.filter.parent},on:{\"click\":function($event){return _vm.onClick(item)}}},[_c('div',{staticClass:\"category-list-mob__label\"},[_vm._v(_vm._s(item.label))])])})],2)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=template&id=a95d0764&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js\nvar vuex_esm = __webpack_require__(4);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var CatalogFilterMobileHorizontalvue_type_script_lang_js_ = ({\n  name: \"CatalogFilterMobileHorizontal\",\n  props: {\n    filter: {\n      type: Object\n    }\n  },\n  computed: {\n    items: function items() {\n      if (this.filter.parent) {\n        // TODO: Как-то поправить эту хуйню с обновлениием наследника при изменении родителя, см. Multifilter.vue\n        // const checkedParentItemIds = this.$store.getters['filters/checkedItemIdsByName'](this.filter.parent);\n        var parent = typeof this.filter.parent === 'string' ? this.$store.state.filters.filters[this.filter.parent] : this.filter.parent;\n        var checkedParentItemIds = parent.data.filter(function (item) {\n          return item.checked;\n        }).map(function (item) {\n          return item.value;\n        }); // TODO: Добавить полифилл для Array.prototype.includes()\n\n        return this.filter.data.filter(function (item) {\n          return checkedParentItemIds.includes(item.parent);\n        });\n      }\n\n      return this.filter.data;\n    },\n    checkedItems: function checkedItems() {\n      return this.items.filter(function (item) {\n        return item.checked;\n      });\n    }\n  },\n  methods: {\n    reset: function reset(filter) {\n      this.filter.data.forEach(function (item) {\n        item.checked = false;\n      }); // this.$store.dispatch('filters/filterReset', { container: 'filters', name: filter.name, type: filter.type });\n    },\n    onReset: function onReset() {\n      this.reset(this.filter);\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    },\n    onClick: function onClick(item) {\n      this.reset(this.filter);\n      item.checked = true;\n      this.$emit('change');\n      this.$store.dispatch('filters/onChange');\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CatalogFilterMobileHorizontalvue_type_script_lang_js_ = (CatalogFilterMobileHorizontalvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  components_CatalogFilterMobileHorizontalvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"a95d0764\",\n  null\n  \n)\n\n/* harmony default export */ var CatalogFilterMobileHorizontal = __webpack_exports__[\"a\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9DYXRhbG9nRmlsdGVyTW9iaWxlSG9yaXpvbnRhbC52dWU/NWRmNSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlPzk1MTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP2JlNGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlPzYyOWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQixhQUFhLHdGQUF3RixrRUFBa0UsWUFBWSxnQ0FBZ0MsWUFBWSw2Q0FBNkMsc0NBQXNDLEtBQUsscUJBQXFCLFlBQVksdUNBQXVDLDZIQUE2SCxpQkFBaUIsNkNBQTZDLDJFQUEyRSxLQUFLLHlCQUF5QiwyQkFBMkIsWUFBWSx1Q0FBdUMsaUNBQWlDO0FBQzUzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDa0JBO0FBRUE7QUFDQSx1Q0FEQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBREEsR0FGQTtBQU9BO0FBQ0EsU0FEQSxtQkFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBLDhEQUNBLHFEQURBLEdBRUEsa0JBRkE7QUFJQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBVEEsQ0FXQTs7QUFDQTtBQUFBO0FBQUE7QUFDQTs7QUFDQTtBQUNBLEtBakJBO0FBa0JBLGdCQWxCQSwwQkFrQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQXBCQSxHQVBBO0FBNkJBO0FBQ0EsU0FEQSxpQkFDQSxNQURBLEVBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FGQSxFQURBLENBSUE7QUFDQSxLQU5BO0FBT0EsV0FQQSxxQkFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBLEtBWkE7QUFhQSxXQWJBLG1CQWFBLElBYkEsRUFhQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFuQkE7QUE3QkEsRzs7QUNyQjZNLENBQWdCLDBKQUFHLEVBQUMsQzs7Ozs7QUNBekc7QUFDdkM7QUFDTDs7O0FBRzVFO0FBQzZGO0FBQzdGLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLGdFQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLDhHIiwiZmlsZSI6IjQ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLml0ZW1zLmxlbmd0aCA+IDApLGV4cHJlc3Npb246XCJpdGVtcy5sZW5ndGggPiAwXCJ9XSxzdGF0aWNDbGFzczpcImNhdGFsb2ctY29udHJvbF9fbWVudSBjYXRhbG9nLWNvbnRyb2xfX21lbnVfd2hpdGVcIn0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGVnb3J5LWxpc3QtbW9iXCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRlZ29yeS1saXN0LW1vYl9faXRlbVwiLGNsYXNzOnthY3RpdmU6IF92bS5jaGVja2VkSXRlbXMubGVuZ3RoID09PSAwfSxvbjp7XCJjbGlja1wiOl92bS5vblJlc2V0fX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhfdm0uZmlsdGVyLm5hbWUgPT09ICdDYXRlZ29yeScgPyAn0JLRgdC1INC60LDRgtC10LPQvtGA0LjQuCcgOiAn0JLRgdC1JykpXSldKSxfdm0uX3YoXCIgXCIpLF92bS5fbCgoX3ZtLml0ZW1zKSxmdW5jdGlvbihpdGVtKXtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY2F0ZWdvcnktbGlzdC1tb2JfX2l0ZW1cIixjbGFzczp7YWN0aXZlOiBpdGVtLmNoZWNrZWQsICdjYXRlZ29yeS1saXN0LW1vYl9faXRlbV9wYXJlbnQnOiAhX3ZtLmZpbHRlci5wYXJlbnR9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLm9uQ2xpY2soaXRlbSl9fX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhpdGVtLmxhYmVsKSldKV0pfSldLDIpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImNhdGFsb2ctY29udHJvbF9fbWVudSBjYXRhbG9nLWNvbnRyb2xfX21lbnVfd2hpdGVcIiB2LXNob3c9XCJpdGVtcy5sZW5ndGggPiAwXCI+XG4gICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5LWxpc3QtbW9iXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY2F0ZWdvcnktbGlzdC1tb2JfX2l0ZW1cIlxuICAgICAgICAgICAgICA6Y2xhc3M9XCJ7YWN0aXZlOiBjaGVja2VkSXRlbXMubGVuZ3RoID09PSAwfVwiXG4gICAgICAgICAgICAgIEBjbGljaz1cIm9uUmVzZXRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwiPnt7ZmlsdGVyLm5hbWUgPT09ICdDYXRlZ29yeScgPyAn0JLRgdC1INC60LDRgtC10LPQvtGA0LjQuCcgOiAn0JLRgdC1J319PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJjYXRlZ29yeS1saXN0LW1vYl9faXRlbVwiXG4gICAgICAgICAgICAgIHYtZm9yPVwiaXRlbSBpbiBpdGVtc1wiXG4gICAgICAgICAgICAgIDpjbGFzcz1cInthY3RpdmU6IGl0ZW0uY2hlY2tlZCwgJ2NhdGVnb3J5LWxpc3QtbW9iX19pdGVtX3BhcmVudCc6ICFmaWx0ZXIucGFyZW50fVwiXG4gICAgICAgICAgICAgIEBjbGljaz1cIm9uQ2xpY2soaXRlbSlcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhdGVnb3J5LWxpc3QtbW9iX19sYWJlbFwiPnt7aXRlbS5sYWJlbH19PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBTdGF0ZSwgbWFwQWN0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiBcIkNhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsXCIsXG4gICAgcHJvcHM6IHtcbiAgICAgIGZpbHRlcjoge1xuICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB9LFxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGl0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXIucGFyZW50KSB7XG4gICAgICAgICAgLy8gVE9ETzog0JrQsNC6LdGC0L4g0L/QvtC/0YDQsNCy0LjRgtGMINGN0YLRgyDRhdGD0LnQvdGOINGBINC+0LHQvdC+0LLQu9C10L3QuNC40LXQvCDQvdCw0YHQu9C10LTQvdC40LrQsCDQv9GA0Lgg0LjQt9C80LXQvdC10L3QuNC4INGA0L7QtNC40YLQtdC70Y8sINGB0LwuIE11bHRpZmlsdGVyLnZ1ZVxuICAgICAgICAgIC8vIGNvbnN0IGNoZWNrZWRQYXJlbnRJdGVtSWRzID0gdGhpcy4kc3RvcmUuZ2V0dGVyc1snZmlsdGVycy9jaGVja2VkSXRlbUlkc0J5TmFtZSddKHRoaXMuZmlsdGVyLnBhcmVudCk7XG5cblxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9ICh0eXBlb2YgdGhpcy5maWx0ZXIucGFyZW50ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgID8gdGhpcy4kc3RvcmUuc3RhdGUuZmlsdGVycy5maWx0ZXJzW3RoaXMuZmlsdGVyLnBhcmVudF1cbiAgICAgICAgICAgIDogdGhpcy5maWx0ZXIucGFyZW50O1xuXG4gICAgICAgICAgY29uc3QgY2hlY2tlZFBhcmVudEl0ZW1JZHMgPSBwYXJlbnQuZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpLm1hcChpdGVtID0+IGl0ZW0udmFsdWUpO1xuXG4gICAgICAgICAgLy8gVE9ETzog0JTQvtCx0LDQstC40YLRjCDQv9C+0LvQuNGE0LjQu9C7INC00LvRjyBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMoKVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlci5kYXRhLmZpbHRlcihpdGVtID0+IGNoZWNrZWRQYXJlbnRJdGVtSWRzLmluY2x1ZGVzKGl0ZW0ucGFyZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyLmRhdGE7XG4gICAgICB9LFxuICAgICAgY2hlY2tlZEl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpO1xuICAgICAgfSxcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlc2V0KGZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlci5kYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICBpdGVtLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL2ZpbHRlclJlc2V0JywgeyBjb250YWluZXI6ICdmaWx0ZXJzJywgbmFtZTogZmlsdGVyLm5hbWUsIHR5cGU6IGZpbHRlci50eXBlIH0pO1xuICAgICAgfSxcbiAgICAgIG9uUmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXQodGhpcy5maWx0ZXIpO1xuXG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScpO1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScpO1xuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soaXRlbSkge1xuICAgICAgICB0aGlzLnJlc2V0KHRoaXMuZmlsdGVyKTtcbiAgICAgICAgaXRlbS5jaGVja2VkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnKTtcbiAgICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICAgIH0sXG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblxuPC9zdHlsZT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0NhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWE5NWQwNzY0JnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0NhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCJhOTVkMDc2NFwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n")},54:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProductCard; });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3);\n\n\n\n// import Vue from \'vue\';\n\n // import ProductCartVue from \'./ProductCard.vue\';\n\nvar ProductCard =\n/*#__PURE__*/\nfunction () {\n  function ProductCard(data) {\n    var _this = this;\n\n    var el = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, ProductCard);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_2___default()(this, "onClick", function (event) {\n      event.preventDefault(); // event.stopPropagation();\n\n      if (_this.data.isFavorite) {\n        _this.removeFromFavorites();\n      } else {\n        _this.addToFavorites();\n      }\n    });\n\n    this.data = data;\n    /*\n    Пример\n     data = {\n      "id": 49568,\n      "name": "Do4a Lab Premium Whey 60% 900 гр",\n      "url": "/catalog/product/do4a_lab_premium_whey_60_900_gr/",\n      "pack_count": 0,\n      "price": 1090,\n      "price_benefit": 0,\n      "img": "/upload/resizer/ba/74192_135x135_ba7f6f9e02a029453dffa51c385bd72d.jpg?1534609372",\n      "img2x": "/upload/resizer/d8/74192_270x270_d86ce530901ce4ded23bec779e0a93d5.jpg?1534609372",\n      "review": 69,\n      "rating": 4.6,\n      "isAvailable": true,\n      "isFavorite": true,\n      "section": "Сывороточный"\n    }\n     */\n\n    this.el = el;\n    this.favoriteButtonEl = null;\n    this.removable = false;\n    this.init();\n  }\n\n  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(ProductCard, [{\n    key: "init",\n    value: function init() {\n      if (!this.el) {\n        this.initDOM();\n      } else {\n        this.favoriteButtonEl = this.el.querySelector(\'.product-control__favorites\');\n\n        if (this.favoriteButtonEl.getAttribute(\'data-toggle\') === \'product.favorites.remove\') {\n          this.removable = true;\n        }\n      }\n\n      this.favoriteButtonEl.addEventListener(\'click\', this.onClick);\n      this.el.ProductCard = this;\n    } // initVue() {\n    //   this.vm = new Vue({\n    //     store,\n    //     render: h => h(ProductCartVue, {\n    //       props: { filter: store.state.filters[this.container][this.filterSettings.name] },\n    //     }),\n    //   }).$mount();\n    //   // document.body.appendChild(this.catalogControlMobileVM.$el);\n    // }\n    // static shipingPeriod() {\n    //   const city = store.getters.currentCity;\n    //   return city && city.deliveryCountDays\n    //     ? `от ${city.deliveryCountDays[0]} ${Utils.declOfNum(city.deliveryCountDays[0], [\'дня\', \'дней\', \'дней\'])}`\n    //     : \'от 1 дня\';\n    // }\n\n  }, {\n    key: "getDeliveryLabelHTML",\n    value: function getDeliveryLabelHTML() {\n      if (!_store__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].state.isLocaleStore) {\n        return \'\';\n      }\n\n      var city = _store__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getters.currentCity;\n\n      if (!city || city.isFake) {\n        return \'\';\n      }\n\n      if (!this.data.isAvailable) {\n        return \'\';\n      }\n\n      if (this.data.isDeliveryOneDay) {\n        return "<div class=\\"product-card__badge product-card__badge_local\\">".concat(ProductCard.badgeTextLocal(), "</div>");\n      }\n\n      return "<div class=\\"product-card__badge product-card__badge_central\\">".concat(ProductCard.badgeTextCentral(), "</div>");\n    }\n  }, {\n    key: "initDOM",\n    value: function initDOM() {\n      this.el = document.createElement(\'div\');\n      this.el.classList.add(\'product-card\');\n      this.el.setAttribute(\'data-product-id\', this.data.id); // this.el.dataset.productId = this.data.id;\n\n      var wrapperEl = document.createElement(\'div\');\n      wrapperEl.classList.add(\'product-card__wrapper\');\n      wrapperEl.innerHTML = "\\n      <div class=\\"product-card__img\\">\\n        <img src=\\"".concat(this.data.img, "\\" srcset=\\"").concat(this.data.img2x, " 2x\\" alt=\\"").concat(this.data.name, "\\">\\n      </div>\\n      <div class=\\"product-card__body\\">\\n        ").concat(this.getDeliveryLabelHTML(), "\\n        <a class=\\"product-card__title stretched-link\\" href=\\"").concat(this.data.url, "\\" title=\\"\\u041F\\u0435\\u0440\\u0435\\u0439\\u0442\\u0438 \\u0432 \\u043A\\u0430\\u0440\\u0442\\u043E\\u0447\\u043A\\u0443 \\u0442\\u043E\\u0432\\u0430\\u0440\\u0430\\">").concat(this.data.name, "</a>\\n        <div class=\\"product-card__description\\">").concat(this.data.section, "</div>\\n      </div>\\n      <div class=\\"product-card__footer\\">\\n        <div class=\\"product-card__price\\">\\n          <span class=\\"small\\">").concat(this.data.pack_count ? \'от\' : \'\', "</span>\\n          <span class=\\"price\\">").concat(this.data.price, "</span>\\n          <span class=\\"currency\\">\\u20BD</span>\\n        </div>\\n        <div class=\\"product-card__sale\\">").concat(this.data.price_benefit ? "\\u042D\\u043A\\u043E\\u043D\\u043E\\u043C\\u0438\\u044F \\u0434\\u043E ".concat(this.data.price_benefit, " \\u20BD") : \'\', "</div>\\n        <div class=\\"product-card__row\\">\\n          <div class=\\"product-card__reviews\\">\\n            ").concat(ProductCard.getRatingEl(this.data.rating), "\\n            <span style=\\"").concat(this.data.review === 0 ? \'display: none\' : \'\', "\\">\\n              ").concat(this.data.review, " ").concat(_utils_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].declOfNum(this.data.review, [\'отзыв\', \'отзыва\', \'отзывов\']), "\\n            </span>\\n          </div>                \\n          <div class=\\"product-card__stock\\">\\n            <div class=\\"").concat(this.data.isAvailable ? \'green\' : \'red\', "\\">\\n              ").concat(this.data.isAvailable ? \'В наличии\' : \'Нет в наличии\', "\\n            </div>\\n            <div style=\\"").concat(this.data.pack_count === 0 ? \'display: none\' : \'\', "\\">\\n              ").concat(this.data.pack_count, " ").concat(_utils_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].declOfNum(this.data.pack_count, [\'фасовка\', \'фасовки\', \'фасовок\']), "\\n            </div>\\n          </div>\\n        </div>\\n      </div>");\n      var stickersEl = document.createElement(\'div\');\n      stickersEl.classList.add(\'product-stickers\'); // if (this.data.isDeliveryOneDay) {\n      //   stickersEl.innerHTML += \'<div class="product-stickers__item product-stickers__item_red product-stickers__item_delivery">Доставка <br>1 день</div>\';\n      // }\n\n      if (this.data.isRecommend) {\n        stickersEl.innerHTML += \'<div class="product-stickers__item product-stickers__item_yellow">Рекомендуем</div>\';\n      }\n\n      if (this.data.isNew) {\n        stickersEl.innerHTML += \'<div class="product-stickers__item product-stickers__item_green">Новинка</div>\';\n      }\n\n      if (this.data.isHit) {\n        stickersEl.innerHTML += \'<div class="product-stickers__item product-stickers__item_red">Хит!</div>\';\n      }\n\n      var controlEl = document.createElement(\'div\');\n      controlEl.classList.add(\'product-control\');\n      this.favoriteButtonEl = document.createElement(\'button\');\n      this.favoriteButtonEl.type = \'button\';\n      this.favoriteButtonEl.classList.add(\'product-control__favorites\');\n      if (this.data.isFavorite) this.favoriteButtonEl.classList.add(\'active\');\n      this.favoriteButtonEl.innerHTML = \'<svg viewBox="0 0 31 27" width="100%" height="100%"><path d="M14.107 3.817l1.106 1.182 1.094-1.193C17.63 2.364 19.555 1.5 21.667 1.5c3.997 0 7.26 3.259 7.267 7.27a7.216 7.216 0 0 1-2.136 5.152l-.002.002-11.62 11.546L3.638 13.924h0l-.004-.004A7.187 7.187 0 0 1 1.5 8.778c0-4.036 3.28-7.274 7.27-7.274a7.31 7.31 0 0 1 5.337 2.313zm1.121 21.706h0s0 0 0 0z" fill="currentColor" stroke="currentColor" stroke-width="3"></path></svg>\';\n      controlEl.appendChild(this.favoriteButtonEl);\n      this.el.appendChild(wrapperEl);\n      this.el.appendChild(stickersEl);\n      this.el.appendChild(controlEl);\n    }\n  }, {\n    key: "addToFavorites",\n\n    /**\n     * Добавить в избранное\n     * @function\n     */\n    value: function addToFavorites() {\n      var _this2 = this;\n\n      this.favoriteButtonEl.classList.add(\'active\');\n      _store__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].dispatch(\'addToFavorites\', this.data.id).then(function () {\n        _this2.data.isFavorite = true;\n      }).catch(function () {\n        _this2.favoriteButtonEl.classList.remove(\'active\');\n      });\n    }\n    /**\n     * Удалить из избранного\n     * @function\n     */\n\n  }, {\n    key: "removeFromFavorites",\n    value: function removeFromFavorites() {\n      var _this3 = this;\n\n      this.favoriteButtonEl.classList.remove(\'active\');\n\n      if (this.removable) {\n        this.el.style.display = \'none\';\n      }\n\n      _store__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].dispatch(\'removeFromFavorites\', this.data.id).then(function () {\n        _this3.data.isFavorite = false;\n\n        if (_this3.removable) {\n          _this3.el.parentNode.removeChild(_this3.el);\n        }\n      }).catch(function () {\n        _this3.favoriteButtonEl.classList.add(\'active\');\n\n        _this3.el.style.display = \'\';\n      });\n    }\n  }, {\n    key: "getElement",\n    value: function getElement() {\n      return this.el;\n    }\n  }, {\n    key: "unMount",\n    value: function unMount() {\n      this.favoriteButtonEl.removeEventListener(\'click\', this.onClick);\n      this.el.ProductCard = null;\n    }\n  }], [{\n    key: "getRatingEl",\n    value: function getRatingEl(rating) {\n      if (rating < 3) return \'\';\n      var rounded = Math.round(rating);\n      var html = \'<span class="product-card__rating">\';\n      [0, 1, 2, 3, 4].forEach(function (i) {\n        html += "<i class=\\"i i-star".concat(i < rounded ? \' red\' : \'\', "\\"></i>");\n      });\n      html += \'</span>\';\n      return html;\n    }\n  }, {\n    key: "initHtmlApi",\n    value: function initHtmlApi() {\n      this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);\n\n      if (typeof MutationObserver !== \'undefined\') {\n        this.globalObserver = new MutationObserver(function (mutations) {\n          mutations.forEach(function (mutation) {\n            Array.prototype.forEach.call(mutation.addedNodes, function (addedNode) {\n              if (addedNode.nodeType === 1) {\n                if (addedNode.classList.contains(\'product-card\') && addedNode.hasAttribute(\'data-product-id\')) {\n                  !addedNode.ProductCard && new ProductCard(ProductCard.getElOptions(addedNode), addedNode);\n                } else {\n                  Array.prototype.forEach.call(addedNode.querySelectorAll(\'.product-card[data-product-id]\'), function (el) {\n                    !el.ProductCard && new ProductCard(ProductCard.getElOptions(el), el);\n                  });\n                }\n              }\n            });\n            Array.prototype.forEach.call(mutation.removedNodes, function (removedNode) {\n              if (removedNode.nodeType === 1) {\n                if (removedNode.classList.contains(\'product-card\') && removedNode.hasAttribute(\'data-product-id\')) {\n                  removedNode.ProductCard && removedNode.ProductCard.unMount();\n                } else {\n                  Array.prototype.forEach.call(removedNode.querySelectorAll(\'.product-card[data-product-id]\'), function (el) {\n                    el.ProductCard && el.ProductCard.unMount();\n                  });\n                }\n              }\n            });\n          });\n        });\n        this.globalObserver.observe(document, {\n          childList: true,\n          subtree: true\n        });\n      } // Taken from jQuery `ready` function\n      // Instantiate elements already present on the page\n\n\n      if (document.readyState === \'complete\' || document.readyState !== \'loading\' && !document.documentElement.doScroll) {\n        // Handle it asynchronously to allow scripts the opportunity to delay init\n        window.setTimeout(this.initDOMLoadedElements);\n      } else {\n        document.addEventListener(\'DOMContentLoaded\', this.initDOMLoadedElements);\n        window.addEventListener(\'load\', this.initDOMLoadedElements);\n      }\n    }\n  }, {\n    key: "initDOMLoadedElements",\n    value: function initDOMLoadedElements() {\n      document.removeEventListener(\'DOMContentLoaded\', this.initDOMLoadedElements);\n      window.removeEventListener(\'load\', this.initDOMLoadedElements);\n      Array.prototype.forEach.call(document.querySelectorAll(\'.product-card[data-product-id]\'), function (el) {\n        if (!el.ProductCard) new ProductCard(ProductCard.getElOptions(el), el);\n      });\n    }\n  }, {\n    key: "getElOptions",\n    value: function getElOptions(el) {\n      var id = parseInt(el.getAttribute(\'data-product-id\'), 10);\n      return {\n        id: id,\n        isFavorite: _store__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].state.favorites.indexOf(id) !== -1 // isFavorite: !!store.state.favorites.find((productId) => productId === id),\n        // isFavorite: el.querySelector(\'.product-control__favorites\').classList.contains(\'active\'),\n\n      };\n    }\n  }, {\n    key: "badgeTextCentral",\n    value: function badgeTextCentral() {\n      var period = \'от 1\';\n      var unit = \'дня\';\n      var city = _store__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getters.currentCity;\n\n      if (city && city.deliveryCountDays && city.deliveryCountDays.length > 1) {\n        period = "".concat(city.deliveryCountDays[0], "-").concat(city.deliveryCountDays[1]);\n        unit = _utils_utils__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].declOfNum(city.deliveryCountDays[1], [\'дня\', \'дней\', \'дней\']);\n      }\n\n      return "\\u0421\\u043E \\u0441\\u043A\\u043B\\u0430\\u0434\\u0430 \\u0432 \\u0421\\u041F\\u0411, ".concat(period, " ").concat(unit);\n    }\n  }, {\n    key: "badgeTextLocal",\n    value: function badgeTextLocal() {\n      return \'Магазин рядом, 1 день\';\n    }\n  }]);\n\n  return ProductCard;\n}();\n\n\nProductCard.initHtmlApi();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9Qcm9kdWN0Q2FyZC5qcz8wMTI3Il0sIm5hbWVzIjpbIlByb2R1Y3RDYXJkIiwiZGF0YSIsImVsIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImlzRmF2b3JpdGUiLCJyZW1vdmVGcm9tRmF2b3JpdGVzIiwiYWRkVG9GYXZvcml0ZXMiLCJmYXZvcml0ZUJ1dHRvbkVsIiwicmVtb3ZhYmxlIiwiaW5pdCIsImluaXRET00iLCJxdWVyeVNlbGVjdG9yIiwiZ2V0QXR0cmlidXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uQ2xpY2siLCJzdG9yZSIsInN0YXRlIiwiaXNMb2NhbGVTdG9yZSIsImNpdHkiLCJnZXR0ZXJzIiwiY3VycmVudENpdHkiLCJpc0Zha2UiLCJpc0F2YWlsYWJsZSIsImlzRGVsaXZlcnlPbmVEYXkiLCJiYWRnZVRleHRMb2NhbCIsImJhZGdlVGV4dENlbnRyYWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJzZXRBdHRyaWJ1dGUiLCJpZCIsIndyYXBwZXJFbCIsImlubmVySFRNTCIsImltZyIsImltZzJ4IiwibmFtZSIsImdldERlbGl2ZXJ5TGFiZWxIVE1MIiwidXJsIiwic2VjdGlvbiIsInBhY2tfY291bnQiLCJwcmljZSIsInByaWNlX2JlbmVmaXQiLCJnZXRSYXRpbmdFbCIsInJhdGluZyIsInJldmlldyIsIlV0aWxzIiwiZGVjbE9mTnVtIiwic3RpY2tlcnNFbCIsImlzUmVjb21tZW5kIiwiaXNOZXciLCJpc0hpdCIsImNvbnRyb2xFbCIsInR5cGUiLCJhcHBlbmRDaGlsZCIsImRpc3BhdGNoIiwidGhlbiIsImNhdGNoIiwicmVtb3ZlIiwic3R5bGUiLCJkaXNwbGF5IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJvdW5kZWQiLCJNYXRoIiwicm91bmQiLCJodG1sIiwiZm9yRWFjaCIsImkiLCJpbml0RE9NTG9hZGVkRWxlbWVudHMiLCJiaW5kIiwiTXV0YXRpb25PYnNlcnZlciIsImdsb2JhbE9ic2VydmVyIiwibXV0YXRpb25zIiwibXV0YXRpb24iLCJBcnJheSIsInByb3RvdHlwZSIsImNhbGwiLCJhZGRlZE5vZGVzIiwiYWRkZWROb2RlIiwibm9kZVR5cGUiLCJjb250YWlucyIsImhhc0F0dHJpYnV0ZSIsImdldEVsT3B0aW9ucyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJyZW1vdmVkTm9kZXMiLCJyZW1vdmVkTm9kZSIsInVuTW91bnQiLCJvYnNlcnZlIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsInJlYWR5U3RhdGUiLCJkb2N1bWVudEVsZW1lbnQiLCJkb1Njcm9sbCIsIndpbmRvdyIsInNldFRpbWVvdXQiLCJwYXJzZUludCIsImZhdm9yaXRlcyIsImluZGV4T2YiLCJwZXJpb2QiLCJ1bml0IiwiZGVsaXZlcnlDb3VudERheXMiLCJsZW5ndGgiLCJpbml0SHRtbEFwaSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFFQTtDQUVBOztJQUdxQkEsVzs7O0FBQ25CLHVCQUFZQyxJQUFaLEVBQTZCO0FBQUE7O0FBQUEsUUFBWEMsRUFBVyx1RUFBTixJQUFNOztBQUFBOztBQUFBLGtHQXVSbkIsVUFBQ0MsS0FBRCxFQUFXO0FBQ25CQSxXQUFLLENBQUNDLGNBQU4sR0FEbUIsQ0FFbkI7O0FBRUEsVUFBSSxLQUFJLENBQUNILElBQUwsQ0FBVUksVUFBZCxFQUEwQjtBQUN4QixhQUFJLENBQUNDLG1CQUFMO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBSSxDQUFDQyxjQUFMO0FBQ0Q7QUFDRixLQWhTNEI7O0FBQzNCLFNBQUtOLElBQUwsR0FBWUEsSUFBWjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLFNBQUtDLEVBQUwsR0FBVUEsRUFBVjtBQUNBLFNBQUtNLGdCQUFMLEdBQXdCLElBQXhCO0FBRUEsU0FBS0MsU0FBTCxHQUFpQixLQUFqQjtBQUdBLFNBQUtDLElBQUw7QUFDRDs7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Q29GLGlCQUFMLENBQXVCLENBQXZCLENBQU4sY0FBbUNwRixJQUFJLENBQUNvRixpQkFBTCxDQUF1QixDQUF2QixDQUFuQyxDQUFOO0FBQ0FELFlBQUksR0FBR3ZELDREQUFLLENBQUNDLFNBQU4sQ0FBZ0I3QixJQUFJLENBQUNvRixpQkFBTCxDQUF1QixDQUF2QixDQUFoQixFQUEyQyxDQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCLE1BQWhCLENBQTNDLENBQVA7QUFDRDs7QUFFRCxvR0FBMkJGLE1BQTNCLGNBQXFDQyxJQUFyQztBQUNEOzs7cUNBRXVCO0FBQ3RCLGFBQU8sdUJBQVA7QUFDRDs7Ozs7OztBQWlLSHRHLFdBQVcsQ0FBQ3lHLFdBQVoiLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5cbmltcG9ydCBVdGlscyBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgc3RvcmUgZnJvbSAnLi4vc3RvcmUnO1xuLy8gaW1wb3J0IFByb2R1Y3RDYXJ0VnVlIGZyb20gJy4vUHJvZHVjdENhcmQudnVlJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9kdWN0Q2FyZCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIGVsID0gbnVsbCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAvKlxuICAgINCf0YDQuNC80LXRgFxuXG4gICAgZGF0YSA9IHtcbiAgICAgIFwiaWRcIjogNDk1NjgsXG4gICAgICBcIm5hbWVcIjogXCJEbzRhIExhYiBQcmVtaXVtIFdoZXkgNjAlIDkwMCDQs9GAXCIsXG4gICAgICBcInVybFwiOiBcIi9jYXRhbG9nL3Byb2R1Y3QvZG80YV9sYWJfcHJlbWl1bV93aGV5XzYwXzkwMF9nci9cIixcbiAgICAgIFwicGFja19jb3VudFwiOiAwLFxuICAgICAgXCJwcmljZVwiOiAxMDkwLFxuICAgICAgXCJwcmljZV9iZW5lZml0XCI6IDAsXG4gICAgICBcImltZ1wiOiBcIi91cGxvYWQvcmVzaXplci9iYS83NDE5Ml8xMzV4MTM1X2JhN2Y2ZjllMDJhMDI5NDUzZGZmYTUxYzM4NWJkNzJkLmpwZz8xNTM0NjA5MzcyXCIsXG4gICAgICBcImltZzJ4XCI6IFwiL3VwbG9hZC9yZXNpemVyL2Q4Lzc0MTkyXzI3MHgyNzBfZDg2Y2U1MzA5MDFjZTRkZWQyM2JlYzc3OWUwYTkzZDUuanBnPzE1MzQ2MDkzNzJcIixcbiAgICAgIFwicmV2aWV3XCI6IDY5LFxuICAgICAgXCJyYXRpbmdcIjogNC42LFxuICAgICAgXCJpc0F2YWlsYWJsZVwiOiB0cnVlLFxuICAgICAgXCJpc0Zhdm9yaXRlXCI6IHRydWUsXG4gICAgICBcInNlY3Rpb25cIjogXCLQodGL0LLQvtGA0L7RgtC+0YfQvdGL0LlcIlxuICAgIH1cbiAgICAgKi9cblxuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB0aGlzLmZhdm9yaXRlQnV0dG9uRWwgPSBudWxsO1xuXG4gICAgdGhpcy5yZW1vdmFibGUgPSBmYWxzZTtcblxuXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuXG4gIHN0YXRpYyBnZXRSYXRpbmdFbChyYXRpbmcpIHtcbiAgICBpZiAocmF0aW5nIDwgMykgcmV0dXJuICcnO1xuXG4gICAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQocmF0aW5nKTtcblxuICAgIGxldCBodG1sID0gJzxzcGFuIGNsYXNzPVwicHJvZHVjdC1jYXJkX19yYXRpbmdcIj4nO1xuICAgIFswLCAxLCAyLCAzLCA0XS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBodG1sICs9IGA8aSBjbGFzcz1cImkgaS1zdGFyJHtpIDwgcm91bmRlZCA/ICcgcmVkJyA6ICcnfVwiPjwvaT5gO1xuICAgIH0pO1xuICAgIGh0bWwgKz0gJzwvc3Bhbj4nO1xuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBzdGF0aWMgaW5pdEh0bWxBcGkoKSB7XG4gICAgdGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMgPSB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cy5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5nbG9iYWxPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHtcbiAgICAgICAgbXV0YXRpb25zLmZvckVhY2goKG11dGF0aW9uKSA9PiB7XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChtdXRhdGlvbi5hZGRlZE5vZGVzLCAoYWRkZWROb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWRkZWROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIGlmIChhZGRlZE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdwcm9kdWN0LWNhcmQnKVxuICAgICAgICAgICAgICAgICYmIGFkZGVkTm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtcHJvZHVjdC1pZCcpKSB7XG4gICAgICAgICAgICAgICAgIWFkZGVkTm9kZS5Qcm9kdWN0Q2FyZFxuICAgICAgICAgICAgICAgICYmIG5ldyBQcm9kdWN0Q2FyZChQcm9kdWN0Q2FyZC5nZXRFbE9wdGlvbnMoYWRkZWROb2RlKSwgYWRkZWROb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFxuICAgICAgICAgICAgICAgICAgYWRkZWROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5wcm9kdWN0LWNhcmRbZGF0YS1wcm9kdWN0LWlkXScpLFxuICAgICAgICAgICAgICAgICAgKGVsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICFlbC5Qcm9kdWN0Q2FyZFxuICAgICAgICAgICAgICAgICAgICAmJiBuZXcgUHJvZHVjdENhcmQoUHJvZHVjdENhcmQuZ2V0RWxPcHRpb25zKGVsKSwgZWwpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG11dGF0aW9uLnJlbW92ZWROb2RlcywgKHJlbW92ZWROb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlLmNsYXNzTGlzdC5jb250YWlucygncHJvZHVjdC1jYXJkJylcbiAgICAgICAgICAgICAgICAmJiByZW1vdmVkTm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtcHJvZHVjdC1pZCcpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUuUHJvZHVjdENhcmQgJiYgcmVtb3ZlZE5vZGUuUHJvZHVjdENhcmQudW5Nb3VudCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoXG4gICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcucHJvZHVjdC1jYXJkW2RhdGEtcHJvZHVjdC1pZF0nKSxcbiAgICAgICAgICAgICAgICAgIChlbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5Qcm9kdWN0Q2FyZCAmJiBlbC5Qcm9kdWN0Q2FyZC51bk1vdW50KCk7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5nbG9iYWxPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBUYWtlbiBmcm9tIGpRdWVyeSBgcmVhZHlgIGZ1bmN0aW9uXG4gICAgLy8gSW5zdGFudGlhdGUgZWxlbWVudHMgYWxyZWFkeSBwcmVzZW50IG9uIHRoZSBwYWdlXG4gICAgaWYgKFxuICAgICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJ1xuICAgICAgfHwgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdsb2FkaW5nJyAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKVxuICAgICkge1xuICAgICAgLy8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IGluaXRcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5pbml0RE9NTG9hZGVkRWxlbWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpbml0RE9NTG9hZGVkRWxlbWVudHMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICdET01Db250ZW50TG9hZGVkJyxcbiAgICAgIHRoaXMuaW5pdERPTUxvYWRlZEVsZW1lbnRzLFxuICAgICk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLmluaXRET01Mb2FkZWRFbGVtZW50cyk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnByb2R1Y3QtY2FyZFtkYXRhLXByb2R1Y3QtaWRdJyksXG4gICAgICAoZWwpID0+IHtcbiAgICAgICAgaWYgKCFlbC5Qcm9kdWN0Q2FyZCkgbmV3IFByb2R1Y3RDYXJkKFByb2R1Y3RDYXJkLmdldEVsT3B0aW9ucyhlbCksIGVsKTtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRFbE9wdGlvbnMoZWwpIHtcbiAgICBjb25zdCBpZCA9IHBhcnNlSW50KGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1wcm9kdWN0LWlkJyksIDEwKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBpc0Zhdm9yaXRlOiBzdG9yZS5zdGF0ZS5mYXZvcml0ZXMuaW5kZXhPZihpZCkgIT09IC0xLFxuICAgICAgLy8gaXNGYXZvcml0ZTogISFzdG9yZS5zdGF0ZS5mYXZvcml0ZXMuZmluZCgocHJvZHVjdElkKSA9PiBwcm9kdWN0SWQgPT09IGlkKSxcbiAgICAgIC8vIGlzRmF2b3JpdGU6IGVsLnF1ZXJ5U2VsZWN0b3IoJy5wcm9kdWN0LWNvbnRyb2xfX2Zhdm9yaXRlcycpLmNsYXNzTGlzdC5jb250YWlucygnYWN0aXZlJyksXG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmVsKSB7XG4gICAgICB0aGlzLmluaXRET00oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYXZvcml0ZUJ1dHRvbkVsID0gdGhpcy5lbC5xdWVyeVNlbGVjdG9yKCcucHJvZHVjdC1jb250cm9sX19mYXZvcml0ZXMnKTtcbiAgICAgIGlmICh0aGlzLmZhdm9yaXRlQnV0dG9uRWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZScpID09PSAncHJvZHVjdC5mYXZvcml0ZXMucmVtb3ZlJykge1xuICAgICAgICB0aGlzLnJlbW92YWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mYXZvcml0ZUJ1dHRvbkVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcblxuICAgIHRoaXMuZWwuUHJvZHVjdENhcmQgPSB0aGlzO1xuICB9XG5cbiAgLy8gaW5pdFZ1ZSgpIHtcbiAgLy8gICB0aGlzLnZtID0gbmV3IFZ1ZSh7XG4gIC8vICAgICBzdG9yZSxcbiAgLy8gICAgIHJlbmRlcjogaCA9PiBoKFByb2R1Y3RDYXJ0VnVlLCB7XG4gIC8vICAgICAgIHByb3BzOiB7IGZpbHRlcjogc3RvcmUuc3RhdGUuZmlsdGVyc1t0aGlzLmNvbnRhaW5lcl1bdGhpcy5maWx0ZXJTZXR0aW5ncy5uYW1lXSB9LFxuICAvLyAgICAgfSksXG4gIC8vICAgfSkuJG1vdW50KCk7XG4gIC8vICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhdGFsb2dDb250cm9sTW9iaWxlVk0uJGVsKTtcbiAgLy8gfVxuXG5cbiAgLy8gc3RhdGljIHNoaXBpbmdQZXJpb2QoKSB7XG4gIC8vICAgY29uc3QgY2l0eSA9IHN0b3JlLmdldHRlcnMuY3VycmVudENpdHk7XG4gIC8vICAgcmV0dXJuIGNpdHkgJiYgY2l0eS5kZWxpdmVyeUNvdW50RGF5c1xuICAvLyAgICAgPyBg0L7RgiAke2NpdHkuZGVsaXZlcnlDb3VudERheXNbMF19ICR7VXRpbHMuZGVjbE9mTnVtKGNpdHkuZGVsaXZlcnlDb3VudERheXNbMF0sIFsn0LTQvdGPJywgJ9C00L3QtdC5JywgJ9C00L3QtdC5J10pfWBcbiAgLy8gICAgIDogJ9C+0YIgMSDQtNC90Y8nO1xuICAvLyB9XG5cbiAgc3RhdGljIGJhZGdlVGV4dENlbnRyYWwoKSB7XG4gICAgbGV0IHBlcmlvZCA9ICfQvtGCIDEnO1xuICAgIGxldCB1bml0ID0gJ9C00L3Rjyc7XG5cbiAgICBjb25zdCBjaXR5ID0gc3RvcmUuZ2V0dGVycy5jdXJyZW50Q2l0eTtcblxuICAgIGlmIChjaXR5ICYmIGNpdHkuZGVsaXZlcnlDb3VudERheXMgJiYgY2l0eS5kZWxpdmVyeUNvdW50RGF5cy5sZW5ndGggPiAxKSB7XG4gICAgICBwZXJpb2QgPSBgJHtjaXR5LmRlbGl2ZXJ5Q291bnREYXlzWzBdfS0ke2NpdHkuZGVsaXZlcnlDb3VudERheXNbMV19YDtcbiAgICAgIHVuaXQgPSBVdGlscy5kZWNsT2ZOdW0oY2l0eS5kZWxpdmVyeUNvdW50RGF5c1sxXSwgWyfQtNC90Y8nLCAn0LTQvdC10LknLCAn0LTQvdC10LknXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGDQodC+INGB0LrQu9Cw0LTQsCDQsiDQodCf0JEsICR7cGVyaW9kfSAke3VuaXR9YDtcbiAgfVxuXG4gIHN0YXRpYyBiYWRnZVRleHRMb2NhbCgpIHtcbiAgICByZXR1cm4gJ9Cc0LDQs9Cw0LfQuNC9INGA0Y/QtNC+0LwsIDEg0LTQtdC90YwnO1xuICB9XG5cbiAgZ2V0RGVsaXZlcnlMYWJlbEhUTUwoKSB7XG4gICAgaWYgKCFzdG9yZS5zdGF0ZS5pc0xvY2FsZVN0b3JlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgY29uc3QgY2l0eSA9IHN0b3JlLmdldHRlcnMuY3VycmVudENpdHk7XG4gICAgaWYgKCFjaXR5IHx8IGNpdHkuaXNGYWtlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRhdGEuaXNBdmFpbGFibGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLmlzRGVsaXZlcnlPbmVEYXkpIHtcbiAgICAgIHJldHVybiBgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fYmFkZ2UgcHJvZHVjdC1jYXJkX19iYWRnZV9sb2NhbFwiPiR7UHJvZHVjdENhcmQuYmFkZ2VUZXh0TG9jYWwoKX08L2Rpdj5gO1xuICAgIH1cblxuICAgIHJldHVybiBgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fYmFkZ2UgcHJvZHVjdC1jYXJkX19iYWRnZV9jZW50cmFsXCI+JHtQcm9kdWN0Q2FyZC5iYWRnZVRleHRDZW50cmFsKCl9PC9kaXY+YDtcbiAgfVxuXG4gIGluaXRET00oKSB7XG4gICAgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuZWwuY2xhc3NMaXN0LmFkZCgncHJvZHVjdC1jYXJkJyk7XG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcHJvZHVjdC1pZCcsIHRoaXMuZGF0YS5pZCk7XG4gICAgLy8gdGhpcy5lbC5kYXRhc2V0LnByb2R1Y3RJZCA9IHRoaXMuZGF0YS5pZDtcblxuXG4gICAgY29uc3Qgd3JhcHBlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd3JhcHBlckVsLmNsYXNzTGlzdC5hZGQoJ3Byb2R1Y3QtY2FyZF9fd3JhcHBlcicpO1xuICAgIHdyYXBwZXJFbC5pbm5lckhUTUwgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwicHJvZHVjdC1jYXJkX19pbWdcIj5cbiAgICAgICAgPGltZyBzcmM9XCIke3RoaXMuZGF0YS5pbWd9XCIgc3Jjc2V0PVwiJHt0aGlzLmRhdGEuaW1nMnh9IDJ4XCIgYWx0PVwiJHt0aGlzLmRhdGEubmFtZX1cIj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fYm9keVwiPlxuICAgICAgICAke3RoaXMuZ2V0RGVsaXZlcnlMYWJlbEhUTUwoKX1cbiAgICAgICAgPGEgY2xhc3M9XCJwcm9kdWN0LWNhcmRfX3RpdGxlIHN0cmV0Y2hlZC1saW5rXCIgaHJlZj1cIiR7dGhpcy5kYXRhLnVybH1cIiB0aXRsZT1cItCf0LXRgNC10LnRgtC4INCyINC60LDRgNGC0L7Rh9C60YMg0YLQvtCy0LDRgNCwXCI+JHt0aGlzLmRhdGEubmFtZX08L2E+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwcm9kdWN0LWNhcmRfX2Rlc2NyaXB0aW9uXCI+JHt0aGlzLmRhdGEuc2VjdGlvbn08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fZm9vdGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJwcm9kdWN0LWNhcmRfX3ByaWNlXCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJzbWFsbFwiPiR7dGhpcy5kYXRhLnBhY2tfY291bnQgPyAn0L7RgicgOiAnJ308L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJwcmljZVwiPiR7dGhpcy5kYXRhLnByaWNlfTwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImN1cnJlbmN5XCI+4oK9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fc2FsZVwiPiR7dGhpcy5kYXRhLnByaWNlX2JlbmVmaXQgPyBg0K3QutC+0L3QvtC80LjRjyDQtNC+ICR7dGhpcy5kYXRhLnByaWNlX2JlbmVmaXR9IOKCvWAgOiAnJ308L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fcm93XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fcmV2aWV3c1wiPlxuICAgICAgICAgICAgJHtQcm9kdWN0Q2FyZC5nZXRSYXRpbmdFbCh0aGlzLmRhdGEucmF0aW5nKX1cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiJHt0aGlzLmRhdGEucmV2aWV3ID09PSAwID8gJ2Rpc3BsYXk6IG5vbmUnIDogJyd9XCI+XG4gICAgICAgICAgICAgICR7dGhpcy5kYXRhLnJldmlld30gJHtVdGlscy5kZWNsT2ZOdW0odGhpcy5kYXRhLnJldmlldywgWyfQvtGC0LfRi9CyJywgJ9C+0YLQt9GL0LLQsCcsICfQvtGC0LfRi9Cy0L7QsiddKX1cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cInByb2R1Y3QtY2FyZF9fc3RvY2tcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke3RoaXMuZGF0YS5pc0F2YWlsYWJsZSA/ICdncmVlbicgOiAncmVkJ31cIj5cbiAgICAgICAgICAgICAgJHt0aGlzLmRhdGEuaXNBdmFpbGFibGUgPyAn0JIg0L3QsNC70LjRh9C40LgnIDogJ9Cd0LXRgiDQsiDQvdCw0LvQuNGH0LjQuCd9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgc3R5bGU9XCIke3RoaXMuZGF0YS5wYWNrX2NvdW50ID09PSAwID8gJ2Rpc3BsYXk6IG5vbmUnIDogJyd9XCI+XG4gICAgICAgICAgICAgICR7dGhpcy5kYXRhLnBhY2tfY291bnR9ICR7VXRpbHMuZGVjbE9mTnVtKHRoaXMuZGF0YS5wYWNrX2NvdW50LCBbJ9GE0LDRgdC+0LLQutCwJywgJ9GE0LDRgdC+0LLQutC4JywgJ9GE0LDRgdC+0LLQvtC6J10pfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+YDtcblxuXG4gICAgY29uc3Qgc3RpY2tlcnNFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHN0aWNrZXJzRWwuY2xhc3NMaXN0LmFkZCgncHJvZHVjdC1zdGlja2VycycpO1xuXG4gICAgLy8gaWYgKHRoaXMuZGF0YS5pc0RlbGl2ZXJ5T25lRGF5KSB7XG4gICAgLy8gICBzdGlja2Vyc0VsLmlubmVySFRNTCArPSAnPGRpdiBjbGFzcz1cInByb2R1Y3Qtc3RpY2tlcnNfX2l0ZW0gcHJvZHVjdC1zdGlja2Vyc19faXRlbV9yZWQgcHJvZHVjdC1zdGlja2Vyc19faXRlbV9kZWxpdmVyeVwiPtCU0L7RgdGC0LDQstC60LAgPGJyPjEg0LTQtdC90Yw8L2Rpdj4nO1xuICAgIC8vIH1cbiAgICBpZiAodGhpcy5kYXRhLmlzUmVjb21tZW5kKSB7XG4gICAgICBzdGlja2Vyc0VsLmlubmVySFRNTCArPSAnPGRpdiBjbGFzcz1cInByb2R1Y3Qtc3RpY2tlcnNfX2l0ZW0gcHJvZHVjdC1zdGlja2Vyc19faXRlbV95ZWxsb3dcIj7QoNC10LrQvtC80LXQvdC00YPQtdC8PC9kaXY+JztcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YS5pc05ldykge1xuICAgICAgc3RpY2tlcnNFbC5pbm5lckhUTUwgKz0gJzxkaXYgY2xhc3M9XCJwcm9kdWN0LXN0aWNrZXJzX19pdGVtIHByb2R1Y3Qtc3RpY2tlcnNfX2l0ZW1fZ3JlZW5cIj7QndC+0LLQuNC90LrQsDwvZGl2Pic7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuaXNIaXQpIHtcbiAgICAgIHN0aWNrZXJzRWwuaW5uZXJIVE1MICs9ICc8ZGl2IGNsYXNzPVwicHJvZHVjdC1zdGlja2Vyc19faXRlbSBwcm9kdWN0LXN0aWNrZXJzX19pdGVtX3JlZFwiPtCl0LjRgiE8L2Rpdj4nO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyb2xFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRyb2xFbC5jbGFzc0xpc3QuYWRkKCdwcm9kdWN0LWNvbnRyb2wnKTtcblxuICAgIHRoaXMuZmF2b3JpdGVCdXR0b25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHRoaXMuZmF2b3JpdGVCdXR0b25FbC50eXBlID0gJ2J1dHRvbic7XG4gICAgdGhpcy5mYXZvcml0ZUJ1dHRvbkVsLmNsYXNzTGlzdC5hZGQoJ3Byb2R1Y3QtY29udHJvbF9fZmF2b3JpdGVzJyk7XG4gICAgaWYgKHRoaXMuZGF0YS5pc0Zhdm9yaXRlKSB0aGlzLmZhdm9yaXRlQnV0dG9uRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgdGhpcy5mYXZvcml0ZUJ1dHRvbkVsLmlubmVySFRNTCA9ICc8c3ZnIHZpZXdCb3g9XCIwIDAgMzEgMjdcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+PHBhdGggZD1cIk0xNC4xMDcgMy44MTdsMS4xMDYgMS4xODIgMS4wOTQtMS4xOTNDMTcuNjMgMi4zNjQgMTkuNTU1IDEuNSAyMS42NjcgMS41YzMuOTk3IDAgNy4yNiAzLjI1OSA3LjI2NyA3LjI3YTcuMjE2IDcuMjE2IDAgMCAxLTIuMTM2IDUuMTUybC0uMDAyLjAwMi0xMS42MiAxMS41NDZMMy42MzggMTMuOTI0aDBsLS4wMDQtLjAwNEE3LjE4NyA3LjE4NyAwIDAgMSAxLjUgOC43NzhjMC00LjAzNiAzLjI4LTcuMjc0IDcuMjctNy4yNzRhNy4zMSA3LjMxIDAgMCAxIDUuMzM3IDIuMzEzem0xLjEyMSAyMS43MDZoMHMwIDAgMCAwelwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIzXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgY29udHJvbEVsLmFwcGVuZENoaWxkKHRoaXMuZmF2b3JpdGVCdXR0b25FbCk7XG5cblxuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQod3JhcHBlckVsKTtcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHN0aWNrZXJzRWwpO1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoY29udHJvbEVsKTtcbiAgfVxuXG4gIG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIC8vIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5pc0Zhdm9yaXRlKSB7XG4gICAgICB0aGlzLnJlbW92ZUZyb21GYXZvcml0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRUb0Zhdm9yaXRlcygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICog0JTQvtCx0LDQstC40YLRjCDQsiDQuNC30LHRgNCw0L3QvdC+0LVcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBhZGRUb0Zhdm9yaXRlcygpIHtcbiAgICB0aGlzLmZhdm9yaXRlQnV0dG9uRWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG5cbiAgICBzdG9yZS5kaXNwYXRjaCgnYWRkVG9GYXZvcml0ZXMnLCB0aGlzLmRhdGEuaWQpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGF0YS5pc0Zhdm9yaXRlID0gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICB0aGlzLmZhdm9yaXRlQnV0dG9uRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiDQo9C00LDQu9C40YLRjCDQuNC3INC40LfQsdGA0LDQvdC90L7Qs9C+XG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgcmVtb3ZlRnJvbUZhdm9yaXRlcygpIHtcbiAgICB0aGlzLmZhdm9yaXRlQnV0dG9uRWwuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG5cbiAgICBpZiAodGhpcy5yZW1vdmFibGUpIHtcbiAgICAgIHRoaXMuZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cbiAgICBzdG9yZS5kaXNwYXRjaCgncmVtb3ZlRnJvbUZhdm9yaXRlcycsIHRoaXMuZGF0YS5pZClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5kYXRhLmlzRmF2b3JpdGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucmVtb3ZhYmxlKSB7XG4gICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgdGhpcy5mYXZvcml0ZUJ1dHRvbkVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLmVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIH0pO1xuICB9XG5cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbDtcbiAgfVxuXG4gIHVuTW91bnQoKSB7XG4gICAgdGhpcy5mYXZvcml0ZUJ1dHRvbkVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICB0aGlzLmVsLlByb2R1Y3RDYXJkID0gbnVsbDtcbiAgfVxufVxuXG5cblByb2R1Y3RDYXJkLmluaXRIdG1sQXBpKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///54\n')},55:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/classCallCheck.js\nvar classCallCheck = __webpack_require__(7);\nvar classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/createClass.js\nvar createClass = __webpack_require__(8);\nvar createClass_default = /*#__PURE__*/__webpack_require__.n(createClass);\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/defineProperty.js\nvar defineProperty = __webpack_require__(2);\nvar defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);\n\n// EXTERNAL MODULE: ./node_modules/vue/dist/vue.runtime.esm.js\nvar vue_runtime_esm = __webpack_require__(6);\n\n// EXTERNAL MODULE: ./node_modules/lodash.debounce/index.js\nvar lodash_debounce = __webpack_require__(27);\nvar lodash_debounce_default = /*#__PURE__*/__webpack_require__.n(lodash_debounce);\n\n// EXTERNAL MODULE: ./src/js/utils/utils.js\nvar utils = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./src/js/api/index.js\nvar api = __webpack_require__(18);\n\n// EXTERNAL MODULE: ./src/js/components/ProductCard.js\nvar ProductCard = __webpack_require__(54);\n\n// EXTERNAL MODULE: ./src/js/components/Multifilter.js\nvar Multifilter = __webpack_require__(15);\n\n// EXTERNAL MODULE: ./src/js/store/index.js\nvar store = __webpack_require__(3);\n\n// EXTERNAL MODULE: ./node_modules/body-scroll-lock/lib/bodyScrollLock.min.js\nvar bodyScrollLock_min = __webpack_require__(31);\n\n// CONCATENATED MODULE: ./src/js/store/modules/catalogControlMobile.js\n // initial state\n\nvar catalogControlMobile_state = {\n  defaultContainer: 'filters',\n  defaultTitle: 'Фильтр',\n  title: 'Фильтр',\n  isActive: false,\n  isParent: true,\n  parentName: null,\n  contentType: null\n}; // getters\n\nvar getters = {\n  visibleBottomContent: function visibleBottomContent(state, getters, rootState) {\n    if (state.defaultContainer === 'sort' && state.isParent) {\n      return getters.visibleContent.filter(function (item) {\n        return item.name !== 'Sort';\n      });\n    }\n\n    return false;\n  },\n  visibleContent: function visibleContent(state, getters, rootState) {\n    var filters = rootState.filters[state.defaultContainer];\n\n    if (!state.parentName) {\n      return Object.keys(filters).reduce(function (arr, key) {\n        if (key !== 'Type' && key !== 'Category') {\n          if (key === 'Sort') {\n            arr.push(filters[key]);\n          } else {\n            var opt = {\n              type: 'multifilter',\n              name: key,\n              label: filters[key].label,\n              childType: filters[key].type,\n              activeChildren: []\n            };\n\n            if (opt.childType === 'checkbox') {\n              opt.activeChildren = filters[key].data.filter(function (item) {\n                return item.checked;\n              }).map(function (item) {\n                return item.label;\n              }) || [];\n              opt.replaceTitle = filters[key].replaceTitle && (opt.activeChildren.length > 0 ? opt.activeChildren.join(', ') : filters[key].labelEmpty);\n            }\n\n            arr.push(opt);\n          }\n        }\n\n        return arr;\n      }, []);\n    }\n\n    return filters[state.parentName].data;\n  } // canReset: (state, getters, rootState) => {\n  //\n  //   if (state.contentType === 'checkbox') {\n  //     return rootState.filters[state.defaultContainer][state.parentName].data.filter(item => item.checked).length > 0;\n  //   }\n  //   // if (state.isParent) {\n  //   //   return rootState.filters[state.defaultContainer][state.parentName].data.filter(item => item.checked).length > 0;\n  //   // }\n  //   return true;\n  // },\n\n}; // actions\n\nvar actions = {\n  // showMenu({ commit }, { name, title }) {\n  //   const offsetTop = document.querySelector('.h-navbar-fixed').getBoundingClientRect().top;\n  //\n  //   if (offsetTop > 0) {\n  //     $('html, body').animate({\n  //       scrollTop: offsetTop + window.pageYOffset,\n  //     });\n  //   }\n  //   disableBodyScroll(document.querySelector('.catalog-menu-mob'));\n  //   // document.body.style.overflow = 'hidden';\n  //\n  //   commit('SET_DEFAULT_CONTAINER', name);\n  //   commit('SET_DEFAULT_TITLE', title);\n  //   commit('SET_CONTENT_TYPE', null);\n  //   commit('SET_PARENT_NAME', null);\n  //   commit('SET_IS_PARENT', true);\n  //   commit('SET_TITLE', title);\n  //\n  //   commit('SET_IS_ACTIVE', true);\n  // },\n  // hideMenu({ commit, dispatch }) {\n  //   // document.body.style.overflow = '';\n  //   // enableBodyScroll(document.querySelector('.catalog-menu-mob'));\n  //   commit('SET_IS_ACTIVE', false);\n  //\n  //   dispatch('filters/onChange', null, { root: true });\n  // },\n  showParents: function showParents(_ref) {\n    var commit = _ref.commit,\n        state = _ref.state;\n    commit('SET_CONTENT_TYPE', null);\n    commit('SET_PARENT_NAME', null);\n    commit('SET_IS_PARENT', true);\n    commit('SET_TITLE', state.defaultTitle);\n  },\n  showChildrens: function showChildrens(_ref2, item) {\n    var commit = _ref2.commit;\n    commit('SET_PARENT_NAME', item.name);\n    commit('SET_CONTENT_TYPE', item.childType);\n    commit('SET_IS_PARENT', false);\n    commit('SET_TITLE', item.label);\n  } // reset({ commit }, { type, name }) {\n  //   if (type === 'checkbox') {\n  //     commit('RESET_CHECKBOX', name);\n  //   }\n  // },\n\n}; // mutations\n\nvar mutations = {\n  SET_DEFAULT_CONTAINER: function SET_DEFAULT_CONTAINER(state, name) {\n    state.defaultContainer = name;\n  },\n  SET_DEFAULT_TITLE: function SET_DEFAULT_TITLE(state, title) {\n    state.defaultTitle = title;\n  },\n  SET_IS_ACTIVE: function SET_IS_ACTIVE(state, status) {\n    state.isActive = status;\n  },\n  SET_IS_PARENT: function SET_IS_PARENT(state, status) {\n    state.isParent = status;\n  },\n  SET_PARENT_NAME: function SET_PARENT_NAME(state, parentName) {\n    state.parentName = parentName;\n  },\n  SET_CONTENT_TYPE: function SET_CONTENT_TYPE(state, type) {\n    state.contentType = type;\n  },\n  SET_TITLE: function SET_TITLE(state, title) {\n    state.title = title;\n  }\n};\n/* harmony default export */ var catalogControlMobile = ({\n  namespaced: true,\n  state: catalogControlMobile_state,\n  getters: getters,\n  actions: actions,\n  mutations: mutations\n});\n// CONCATENATED MODULE: ./src/js/store/modules/catalogControl.js\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n // initial state\n\nvar catalogControl_state = {\n  items: [],\n  filters: {},\n  sort: {}\n}; // getters\n\nvar catalogControl_getters = {\n  // filterByName: state => name => state.items.find(item => item.name === name),\n  // horizontalFilters: state => state.items.filter(item => item.name === 'Type' || item.name === 'Category'),\n  // modalFilters: state => state.items.filter(item => item.name !== 'Type' && item.name !== 'Category'),\n  checkedItemsByName: function checkedItemsByName(state) {\n    return function (name) {\n      return state.filters[name].data.filter(function (item) {\n        return item.checked;\n      });\n    };\n  },\n  checkedItemIdsByName: function checkedItemIdsByName(state, getters) {\n    return function (name) {\n      return getters.checkedItemsByName(name).map(function (item) {\n        return item.value;\n      });\n    };\n  }\n}; // actions\n\nvar catalogControl_actions = {\n  resetAll: function resetAll(_ref) {\n    var state = _ref.state,\n        commit = _ref.commit;\n    Object.keys(state.filters).forEach(function (key) {\n      if (state.filters[key].type === 'checkbox') {\n        commit('RESET_CHECKBOX_BY_NAME', {\n          container: 'filters',\n          name: key\n        });\n      }\n    }); // callback();\n  },\n  filterReset: function filterReset(_ref2, _ref3) {\n    var commit = _ref2.commit;\n    var type = _ref3.type,\n        container = _ref3.container,\n        name = _ref3.name;\n\n    if (type === 'checkbox') {\n      commit('RESET_CHECKBOX_BY_NAME', {\n        container: container,\n        name: name\n      });\n    }\n  },\n  onChange: function onChange() {},\n  // changeParentItems()\n  // activatedVariants\n  // TODO: Переделать это говно к чертовой матери\n  updateActivatedVariants: function updateActivatedVariants(_ref4, _ref5) {\n    var state = _ref4.state,\n        commit = _ref4.commit;\n    var activatedVariants = _ref5.activatedVariants;\n    Object.keys(activatedVariants).forEach(function (key) {\n      if ({}.hasOwnProperty.call(state.filters, key) && state.filters[key].type === 'checkbox') {\n        state.filters[key].data.forEach(function (item, index) {\n          commit('SET_AVAILABLE_STATUS_BY_NAME', {\n            name: key,\n            index: index,\n            status: {}.hasOwnProperty.call(activatedVariants[key], item.value)\n          });\n        });\n      }\n    });\n  },\n  // hiddenVariants\n  // TODO: И эту херню в том числе\n  updateHiddenVariants: function updateHiddenVariants(_ref6, _ref7) {\n    var state = _ref6.state,\n        commit = _ref6.commit;\n    var hiddenVariants = _ref7.hiddenVariants;\n    Object.keys(hiddenVariants).forEach(function (key) {\n      if ({}.hasOwnProperty.call(state.filters, key) && state.filters[key].type === 'checkbox') {\n        state.filters[key].data.forEach(function (item, index) {\n          commit('SET_HIDDEN_STATUS_BY_NAME', {\n            name: key,\n            index: index,\n            status: {}.hasOwnProperty.call(hiddenVariants[key], item.value)\n          });\n        });\n      }\n    });\n  }\n}; // mutations\n\nvar catalogControl_mutations = {\n  RESET_CHECKBOX_BY_NAME: function RESET_CHECKBOX_BY_NAME(state, _ref8) {\n    var container = _ref8.container,\n        name = _ref8.name;\n    state[container][name].data.forEach(function (item) {\n      item.checked = false;\n    });\n  },\n  SET_AVAILABLE_STATUS_BY_NAME: function SET_AVAILABLE_STATUS_BY_NAME(state, _ref9) {\n    var name = _ref9.name,\n        index = _ref9.index,\n        status = _ref9.status;\n    state.filters[name].data[index].available = status;\n  },\n  SET_HIDDEN_STATUS_BY_NAME: function SET_HIDDEN_STATUS_BY_NAME(state, _ref10) {\n    var name = _ref10.name,\n        index = _ref10.index,\n        status = _ref10.status;\n    state.filters[name].data[index].hidden = status;\n  },\n  // setCallback(state, callback) {\n  //   state.callback = callback;\n  // },\n  setFilter: function setFilter(state, filter) {\n    state.filters = _objectSpread({}, state.filters, defineProperty_default()({}, filter.name, filter)); // Vue.set(state.list, filter.name, filter);\n  },\n  setFilters: function setFilters(state, filters) {\n    state.filters = filters;\n  },\n  pushFilterToContainer: function pushFilterToContainer(state, _ref11) {\n    var container = _ref11.container,\n        filter = _ref11.filter;\n    state[container] = _objectSpread({}, state[container], defineProperty_default()({}, filter.name, filter));\n    state.items.push(filter);\n  } // filterReset() {\n  //   console.log('reset');\n  // },\n  // filterChange() {\n  //   console.log('change');\n  // },\n\n};\n/* harmony default export */ var catalogControl = ({\n  namespaced: true,\n  state: catalogControl_state,\n  getters: catalogControl_getters,\n  actions: catalogControl_actions,\n  mutations: catalogControl_mutations,\n  modules: {\n    mobile: catalogControlMobile\n  }\n});\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CategoryListMobile.vue?vue&type=template&id=47b300fa&\nvar CategoryListMobilevue_type_template_id_47b300fa_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"catalog-control__mobile\"},[(_vm.typeFilter)?[_c('CatalogFilterMobileHorizontal',{attrs:{\"filter\":_vm.typeFilter}})]:_vm._e(),_vm._v(\" \"),(_vm.categoryFilter)?[_c('CatalogFilterMobileHorizontal',{attrs:{\"filter\":_vm.categoryFilter}})]:_vm._e()],2)}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/CategoryListMobile.vue?vue&type=template&id=47b300fa&\n\n// EXTERNAL MODULE: ./node_modules/vuex/dist/vuex.esm.js\nvar vuex_esm = __webpack_require__(4);\n\n// EXTERNAL MODULE: ./src/js/components/CatalogFilterMobileHorizontal.vue + 4 modules\nvar CatalogFilterMobileHorizontal = __webpack_require__(44);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CategoryListMobile.vue?vue&type=script&lang=js&\n\n\nfunction CategoryListMobilevue_type_script_lang_js_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction CategoryListMobilevue_type_script_lang_js_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CategoryListMobilevue_type_script_lang_js_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CategoryListMobilevue_type_script_lang_js_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ var CategoryListMobilevue_type_script_lang_js_ = ({\n  name: \"CategoryListMobile\",\n  components: {\n    CatalogFilterMobileHorizontal: CatalogFilterMobileHorizontal[\"a\" /* default */]\n  },\n  computed: CategoryListMobilevue_type_script_lang_js_objectSpread({}, Object(vuex_esm[\"d\" /* mapState */])('filters', {\n    // filters: state => state.filters,\n    typeFilter: function typeFilter(state) {\n      return state.filters['Type'];\n    },\n    categoryFilter: function categoryFilter(state) {\n      return state.filters['Category'];\n    }\n  }))\n});\n// CONCATENATED MODULE: ./src/js/components/CategoryListMobile.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CategoryListMobilevue_type_script_lang_js_ = (CategoryListMobilevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./src/js/components/CategoryListMobile.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer[\"a\" /* default */])(\n  components_CategoryListMobilevue_type_script_lang_js_,\n  CategoryListMobilevue_type_template_id_47b300fa_render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var CategoryListMobile = (component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilterMobile.vue?vue&type=template&id=466e5360&\nvar CatalogFilterMobilevue_type_template_id_466e5360_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"catalog-menu-mob\",class:{active: _vm.isActive}},[_c('div',{staticClass:\"catalog-menu-mob__header\"},[(!_vm.isParent)?_c('button',{staticClass:\"catalog-menu-mob__btn-back\",on:{\"click\":function($event){$event.preventDefault();return _vm.back($event)}}}):_vm._e(),_vm._v(\" \"),_c('span',{staticClass:\"catalog-menu-mob__title\"},[_vm._v(_vm._s(_vm.title))]),_vm._v(\" \"),(_vm.isParent)?_c('button',{staticClass:\"catalog-menu-mob__btn-close\",on:{\"click\":function($event){$event.preventDefault();return _vm.close($event)}}}):_vm._e()]),_vm._v(\" \"),_c('div',{staticClass:\"catalog-menu-mob__wrapper\"},[(_vm.contentType === 'range')?_c('MultifilterPrice',{attrs:{\"slider\":_vm.content},on:{\"change\":_vm.onChange}}):(_vm.contentType === 'checkbox')?_c('MultifilterCheckboxList',{attrs:{\"items\":_vm.content,\"search\":false},on:{\"change\":_vm.onChange}}):[_vm._l((_vm.content),function(item){return [(item.type === 'multifilter' && !_vm.bottomContent)?_c('div',{staticClass:\"multifilter\",class:{active: item.activeChildren.length > 0}},[_c('button',{staticClass:\"multifilter__content multifilter__content_parent\",on:{\"click\":function($event){$event.preventDefault();return _vm.next(item)}}},[(!item.replaceTitle)?_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(item.label))]):[_c('span',{staticClass:\"multifilter__label\"},[_vm._v(_vm._s(item.label))]),_vm._v(\" \"),_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(item.replaceTitle))])],_vm._v(\" \"),_c('span',{directives:[{name:\"show\",rawName:\"v-show\",value:(item.activeChildren.length > 0),expression:\"item.activeChildren.length > 0\"}],staticClass:\"multifilter__total\"},[_vm._v(_vm._s(item.activeChildren.length))])],2),_vm._v(\" \"),_c('button',{directives:[{name:\"show\",rawName:\"v-show\",value:(item.activeChildren.length > 0),expression:\"item.activeChildren.length > 0\"}],staticClass:\"multifilter__btn-clear\",on:{\"click\":function($event){$event.preventDefault();return _vm.onResetRow(item.name, item.childType)}}},[_vm._v(\"Сбросить\")])]):(item.type === 'radio')?_vm._l((item.data),function(radio){return _c('label',{staticClass:\"multifilter-radio\"},[_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(item.selected),expression:\"item.selected\"}],staticClass:\"multifilter-radio__input\",attrs:{\"type\":\"radio\",\"name\":radio.name},domProps:{\"value\":radio.value,\"checked\":_vm._q(item.selected,radio.value)},on:{\"change\":[function($event){return _vm.$set(item, \"selected\", radio.value)},_vm.onChange]}}),_vm._v(\" \"),_c('span',{staticClass:\"multifilter-radio__label\"},[_vm._v(_vm._s(radio.label))])])}):_vm._e()]})]],2),_vm._v(\" \"),(_vm.bottomContent.length)?_c('div',{staticClass:\"catalog-menu-mob__wrapper\",staticStyle:{\"overflow\":\"hidden\",\"flex\":\"0 0 auto\"}},[_vm._l((_vm.bottomContent),function(item){return [(item.type === 'multifilter')?_c('div',{staticClass:\"multifilter\",class:{active: item.activeChildren.length > 0}},[_c('button',{staticClass:\"multifilter__content multifilter__content_parent\",on:{\"click\":function($event){$event.preventDefault();return _vm.next(item)}}},[(item.replaceTitle)?_c('span',{staticClass:\"multifilter__label\"},[_vm._v(_vm._s(item.label))]):_vm._e(),_vm._v(\" \"),(item.replaceTitle)?_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(item.replaceTitle))]):_c('span',{staticClass:\"multifilter__value\"},[_vm._v(_vm._s(item.label))]),_vm._v(\" \"),_c('span',{directives:[{name:\"show\",rawName:\"v-show\",value:(item.activeChildren.length > 0),expression:\"item.activeChildren.length > 0\"}],staticClass:\"multifilter__total\"},[_vm._v(_vm._s(item.activeChildren.length))])]),_vm._v(\" \"),_c('button',{directives:[{name:\"show\",rawName:\"v-show\",value:(item.activeChildren.length > 0),expression:\"item.activeChildren.length > 0\"}],staticClass:\"multifilter__btn-clear\",on:{\"click\":function($event){$event.preventDefault();return _vm.onResetRow(item.name, item.childType)}}},[_vm._v(\"Сбросить\")])]):_vm._e()]})],2):_vm._e(),_vm._v(\" \"),_c('div',{staticClass:\"catalog-menu-mob__footer\"},[(_vm.type === 'filters' || !_vm.isParent)?_c('button',{staticClass:\"catalog-menu-mob__btn-footer btn btn-gray-2\",attrs:{\"disabled\":!_vm.canReset},on:{\"click\":function($event){$event.preventDefault();return _vm.onResetFooter(_vm.parentName, _vm.contentType)}}},[_c('svg',{staticClass:\"btn-icon\",attrs:{\"width\":\"12\",\"height\":\"12\",\"viewBox\":\"0 0 12 12\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\"}},[_c('path',{attrs:{\"fill-rule\":\"evenodd\",\"clip-rule\":\"evenodd\",\"d\":\"M2.17851 0.821777L0.822472 2.1777L4.64429 5.99984L0.822266 9.82187L2.17825 11.1779L6.00022 7.35588L9.82195 11.1779L11.178 9.82201L7.3562 5.9999L11.1781 2.178L9.82212 0.822014L6.00027 4.64386L2.17851 0.821777Z\",\"fill\":\"currentColor\"}})]),_vm._v(\"\\n      Сбросить\\n    \")]):_vm._e(),_vm._v(\" \"),(_vm.isParent)?_c('button',{staticClass:\"catalog-menu-mob__btn-footer btn btn-red\",attrs:{\"disabled\":!_vm.canReset},on:{\"click\":function($event){$event.preventDefault();return _vm.close($event)}}},[_vm._v(\"Применить\")]):_vm._e()])])}\nvar CatalogFilterMobilevue_type_template_id_466e5360_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobile.vue?vue&type=template&id=466e5360&\n\n// EXTERNAL MODULE: ./src/js/components/catalog/MultifilterCheckboxList.vue + 9 modules\nvar MultifilterCheckboxList = __webpack_require__(25);\n\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterRadio.vue?vue&type=template&id=253e4540&\nvar MultifilterRadiovue_type_template_id_253e4540_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{staticClass:\"multifilter-radio\"},[_c('input',_vm._b({staticClass:\"multifilter-radio__input\",attrs:{\"type\":\"radio\"},domProps:{\"checked\":_vm.checked},on:{\"change\":_vm.onChange}},'input',_vm.$attrs,false)),_vm._v(\" \"),_c('span',{staticClass:\"multifilter-radio__label\"},[_vm._t(\"default\")],2)])}\nvar MultifilterRadiovue_type_template_id_253e4540_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterRadio.vue?vue&type=template&id=253e4540&\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/catalog/MultifilterRadio.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var MultifilterRadiovue_type_script_lang_js_ = ({\n  name: \"MultifilterRadio\",\n  inheritAttrs: false,\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: {\n      default: false,\n      type: Boolean\n    }\n  },\n  methods: {\n    onChange: function onChange(event) {\n      console.log(event.target.checked);\n      this.$emit('change', event.target.checked);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterRadio.vue?vue&type=script&lang=js&\n /* harmony default export */ var catalog_MultifilterRadiovue_type_script_lang_js_ = (MultifilterRadiovue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/catalog/MultifilterRadio.vue\n\n\n\n\n\n/* normalize component */\n\nvar MultifilterRadio_component = Object(componentNormalizer[\"a\" /* default */])(\n  catalog_MultifilterRadiovue_type_script_lang_js_,\n  MultifilterRadiovue_type_template_id_253e4540_render,\n  MultifilterRadiovue_type_template_id_253e4540_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var MultifilterRadio = (MultifilterRadio_component.exports);\n// EXTERNAL MODULE: ./src/js/components/catalog/MultifilterPrice.vue + 4 modules\nvar MultifilterPrice = __webpack_require__(26);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilterMobile.vue?vue&type=script&lang=js&\n\n\nfunction CatalogFilterMobilevue_type_script_lang_js_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction CatalogFilterMobilevue_type_script_lang_js_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CatalogFilterMobilevue_type_script_lang_js_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CatalogFilterMobilevue_type_script_lang_js_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n/* harmony default export */ var CatalogFilterMobilevue_type_script_lang_js_ = ({\n  name: \"CatalogFilterMobile\",\n  components: {\n    MultifilterCheckboxList: MultifilterCheckboxList[\"a\" /* default */],\n    MultifilterRadio: MultifilterRadio,\n    MultifilterPrice: MultifilterPrice[\"a\" /* default */]\n  },\n  data: function data() {\n    return {\n      isActive: false\n    };\n  },\n  computed: CatalogFilterMobilevue_type_script_lang_js_objectSpread({}, Object(vuex_esm[\"d\" /* mapState */])('filters/mobile', {\n    isParent: function isParent(state) {\n      return state.isParent;\n    },\n    parentName: function parentName(state) {\n      return state.parentName;\n    },\n    title: function title(state) {\n      return state.title;\n    },\n    contentType: function contentType(state) {\n      return state.contentType;\n    },\n    type: function type(state) {\n      return state.defaultContainer;\n    }\n  }), {}, Object(vuex_esm[\"c\" /* mapGetters */])('filters/mobile', {\n    content: 'visibleContent',\n    bottomContent: 'visibleBottomContent' // canReset: 'canReset',\n\n  }), {\n    /**\n     * Показывать ли кнопку \"Сбросить\"\n     * @returns {boolean}\n     */\n    canReset: function canReset() {\n      if (this.isParent) {\n        return !!this.content.find(function (item) {\n          return item.childType === 'checkbox' && item.activeChildren.length > 0;\n        });\n      }\n\n      if (this.contentType === 'checkbox') {\n        return !!this.content.find(function (item) {\n          return item.checked;\n        });\n      }\n\n      return true;\n    }\n  }),\n  methods: {\n    onChange: function onChange() {\n      this.hasChanges = true;\n      console.log('mobile change');\n    },\n\n    /**\n     * Кнопка сброса в списке фильтров\n     * @param name\n     * @param type\n     */\n    onResetRow: function onResetRow(name, type) {\n      this.$store.dispatch('filters/filterReset', {\n        container: this.type,\n        name: name,\n        type: type\n      });\n      this.onChange();\n    },\n\n    /**\n     * Кнопка сброса в нижней части\n     * @param name\n     * @param type\n     */\n    onResetFooter: function onResetFooter(name, type) {\n      if (this.isParent) {\n        this.$store.dispatch('filters/resetAll');\n      } else {\n        this.$store.dispatch('filters/filterReset', {\n          container: this.type,\n          name: name,\n          type: type\n        });\n      }\n\n      this.onChange();\n    },\n    open: function open(_ref) {\n      var name = _ref.name,\n          title = _ref.title;\n      var offsetTop = document.querySelector('.h-navbar-fixed').getBoundingClientRect().top;\n\n      if (offsetTop > 0) {\n        window.scrollTo(0, offsetTop + window.pageYOffset); // $('html, body').animate({\n        //   scrollTop: offsetTop + window.pageYOffset,\n        // });\n      }\n\n      Object(bodyScrollLock_min[\"disableBodyScroll\"])(this.$el);\n      this.$store.commit('filters/mobile/SET_DEFAULT_CONTAINER', name);\n      this.$store.commit('filters/mobile/SET_DEFAULT_TITLE', title);\n      this.$store.commit('filters/mobile/SET_CONTENT_TYPE', null);\n      this.$store.commit('filters/mobile/SET_PARENT_NAME', null);\n      this.$store.commit('filters/mobile/SET_IS_PARENT', true);\n      this.$store.commit('filters/mobile/SET_TITLE', title); // this.$store.commit('filters/mobile/SET_IS_ACTIVE', true);\n\n      this.isActive = true;\n    },\n    close: function close() {\n      Object(bodyScrollLock_min[\"enableBodyScroll\"])(this.$el); // this.$store.commit('filters/mobile/SET_IS_ACTIVE', false);\n\n      this.isActive = false;\n\n      if (this.hasChanges) {\n        this.$store.dispatch('filters/onChange');\n        this.hasChanges = false;\n      }\n    },\n    back: function back() {\n      this.$store.dispatch('filters/mobile/showParents');\n    },\n    next: function next(item) {\n      this.$store.dispatch('filters/mobile/showChildrens', item);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobile.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CatalogFilterMobilevue_type_script_lang_js_ = (CatalogFilterMobilevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/CatalogFilterMobile.vue\n\n\n\n\n\n/* normalize component */\n\nvar CatalogFilterMobile_component = Object(componentNormalizer[\"a\" /* default */])(\n  components_CatalogFilterMobilevue_type_script_lang_js_,\n  CatalogFilterMobilevue_type_template_id_466e5360_render,\n  CatalogFilterMobilevue_type_template_id_466e5360_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var CatalogFilterMobile = (CatalogFilterMobile_component.exports);\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilter.vue?vue&type=template&id=901b8770&scoped=true&\nvar CatalogFiltervue_type_template_id_901b8770_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"filter\"},[_c('div',{staticClass:\"filter__list\"},[_vm._l((_vm.filters),function(filter){return [(filter.type === 'checkbox')?_c('FilterCheckbox',{attrs:{\"filter\":filter}}):(filter.type === 'radio')?_c('FilterSelect',{attrs:{\"filter\":filter}}):(filter.type === 'range')?_c('FilterPrice',{attrs:{\"filter\":filter}}):_vm._e()]})],2),_vm._v(\" \"),_c('button',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.canReset),expression:\"canReset\"}],staticClass:\"filter__btn-reset\",attrs:{\"type\":\"reset\"},on:{\"click\":function($event){$event.preventDefault();return _vm.onReset($event)}}},[_vm._v(\"Сбросить\")])])}\nvar CatalogFiltervue_type_template_id_901b8770_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/js/components/CatalogFilter.vue?vue&type=template&id=901b8770&scoped=true&\n\n// EXTERNAL MODULE: ./src/js/components/catalog/FilterCheckbox.vue + 4 modules\nvar FilterCheckbox = __webpack_require__(22);\n\n// EXTERNAL MODULE: ./src/js/components/catalog/FilterSelect.vue + 4 modules\nvar FilterSelect = __webpack_require__(23);\n\n// EXTERNAL MODULE: ./src/js/components/catalog/FilterPrice.vue + 4 modules\nvar FilterPrice = __webpack_require__(24);\n\n// CONCATENATED MODULE: ./node_modules/babel-loader/lib??ref--3-0!./node_modules/vue-loader/lib??vue-loader-options!./src/js/components/CatalogFilter.vue?vue&type=script&lang=js&\n\n\nfunction CatalogFiltervue_type_script_lang_js_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction CatalogFiltervue_type_script_lang_js_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { CatalogFiltervue_type_script_lang_js_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { CatalogFiltervue_type_script_lang_js_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n// import Dropdown from './Dropdown.vue';\n// import MultifilterPrice from './catalog/MultifilterPrice.vue';\n// import MultifilterCheckboxList from './catalog/MultifilterCheckboxList.vue';\n\n\n\n\n/* harmony default export */ var CatalogFiltervue_type_script_lang_js_ = ({\n  name: \"CatalogFilter\",\n  components: {\n    FilterCheckbox: FilterCheckbox[\"a\" /* default */],\n    FilterSelect: FilterSelect[\"a\" /* default */],\n    FilterPrice: FilterPrice[\"a\" /* default */]\n  },\n  // mounted() {\n  //   this.$root.$on('change', () => {\n  //     this.onChange();\n  //   });\n  // },\n  computed: CatalogFiltervue_type_script_lang_js_objectSpread({}, Object(vuex_esm[\"d\" /* mapState */])('filters', {\n    filters: function filters(state) {\n      return state.filters;\n    }\n  }), {\n    /**\n     * Показывать ли кнопку \"Сбросить\"\n     * @returns {boolean}\n     */\n    canReset: function canReset() {\n      return !!Object.values(this.filters).find(function (item) {\n        if (item.type === 'checkbox') {\n          return item.data.find(function (c) {\n            return c.checked;\n          });\n        } else if (item.type === 'range') {\n          return item.data.minRange || item.data.maxRange;\n        }\n      });\n    }\n  }),\n  methods: {\n    onReset: function onReset() {\n      this.$root.$emit('filter:reset');\n      this.$store.dispatch('filters/onChange'); // this.onChange();\n    } // onChange() {\n    //   this.$root.$emit('filter:change');\n    // }\n\n  }\n});\n// CONCATENATED MODULE: ./src/js/components/CatalogFilter.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_CatalogFiltervue_type_script_lang_js_ = (CatalogFiltervue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/js/components/CatalogFilter.vue\n\n\n\n\n\n/* normalize component */\n\nvar CatalogFilter_component = Object(componentNormalizer[\"a\" /* default */])(\n  components_CatalogFiltervue_type_script_lang_js_,\n  CatalogFiltervue_type_template_id_901b8770_scoped_true_render,\n  CatalogFiltervue_type_template_id_901b8770_scoped_true_staticRenderFns,\n  false,\n  null,\n  \"901b8770\",\n  null\n  \n)\n\n/* harmony default export */ var CatalogFilter = (CatalogFilter_component.exports);\n// EXTERNAL MODULE: ./src/js/components/ProductCard.vue + 4 modules\nvar components_ProductCard = __webpack_require__(49);\n\n// CONCATENATED MODULE: ./src/js/page/catalog.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return catalog_CatalogControl; });\n\n\n\n\nfunction catalog_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction catalog_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { catalog_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { catalog_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n // import throttle from 'lodash.throttle';\n\n\n\n\n\n\n\n\n\n\n\nvar ProductCartVue = vue_runtime_esm[\"a\" /* default */].extend(components_ProductCard[\"a\" /* default */]);\n/**\n * Сворачивание строк\n */\n\nfunction initCollapse() {\n  var maxLineCount = 5;\n\n  if (document.documentElement.clientWidth >= 768) {\n    maxLineCount = 8;\n  }\n\n  if (document.documentElement.clientWidth >= 1240) {\n    maxLineCount = 10;\n  }\n\n  [].forEach.call(document.querySelectorAll('.p-collapse'), function (item) {\n    var lineHeight = parseInt(getComputedStyle(item).lineHeight, 10);\n\n    if (item.clientHeight > lineHeight * maxLineCount) {\n      var container = document.createElement('div');\n      container.classList.add('p-collapse__text');\n      container.innerHTML = item.innerHTML.trim();\n      container.style.height = \"\".concat(lineHeight * maxLineCount, \"px\");\n      var button = document.createElement('button');\n      button.classList.add('p-collapse__button');\n      button.innerHTML = 'Читать далее';\n      button.innerHTML += '<svg width=\"10\" height=\"14\" viewBox=\"0 0 10 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\\n' + '<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.99274 6.63951L1.67626 1.85444L4.14194 0.145508L9.00728 7.16531L1.97121 13.1431L0.0288086 10.8568L4.99274 6.63951Z\" fill=\"#F4412D\"/>\\n' + '</svg>\\n';\n      button.addEventListener('click', function (event) {\n        event.preventDefault();\n        button.style.display = 'none';\n        container.style.height = 'auto';\n      });\n      item.innerHTML = '';\n      item.appendChild(container);\n      item.appendChild(button);\n    }\n  });\n}\n\nvar catalog_CatalogControl =\n/*#__PURE__*/\nfunction () {\n  function CatalogControl() {\n    var _this = this;\n\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      form: null,\n      filter: null,\n      sorting: null,\n      quantity: null,\n      container: null\n    };\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    classCallCheck_default()(this, CatalogControl);\n\n    defineProperty_default()(this, \"onReset\", function (event) {\n      event.preventDefault();\n      store[\"a\" /* default */].dispatch('filters/resetAll').then(function () {\n        _this.update();\n      });\n    });\n\n    defineProperty_default()(this, \"change\", function () {\n      _this.containerEl.classList.add(_this.classNames.cardListLoading);\n\n      _this.debouncedUpdate();\n    });\n\n    defineProperty_default()(this, \"update\", function () {\n      utils[\"a\" /* default */].log('Каталог', 'Обновление по фильтру');\n\n      try {\n        _this.containerEl.classList.add(_this.classNames.cardListLoading);\n\n        if (!_this.options.ajax) {\n          _this.formEl.submit();\n        } else {\n          _this.reloadPage(1);\n        }\n      } catch (e) {\n        _this.containerEl.classList.remove(_this.classNames.cardListLoading);\n\n        alert('Ошибка');\n        console.error(e);\n      }\n    });\n\n    store[\"a\" /* default */].registerModule('filters', catalogControl);\n    this.filterEl = elements.filter || document.querySelector('.filter');\n    this.filterList = {};\n    this.sortingEl = elements.sorting || document.querySelector('.sorting');\n    this.sortingList = [];\n    this.formEl = elements.form || document.getElementById('catalog-filter');\n    this.quantityEl = elements.quantity || document.querySelector('[data-total-find]');\n    this.containerEl = elements.container || document.querySelector('.card-list'); // this.Container = null;\n\n    this.breadcumps = document.querySelector('.mr-breadcumps');\n    this.title = document.querySelector('.page-header__title');\n    this.showMoreEl = null;\n    this.showMoreButtonEl = null;\n    this.showMoreTextEl = null;\n    this.currentPage = 1;\n    this.shownCards = 0;\n    this.totalCards = 0;\n    this.options = catalog_objectSpread({}, CatalogControl.defaultOptions, {}, options); // this.options.method = this.formEl.method;\n    // this.options.action = this.formEl.action;\n\n    this.classNames = catalog_objectSpread({}, CatalogControl.defaultOptions.classNames, {}, this.options.classNames);\n    this.debouncedUpdate = lodash_debounce_default()(this.update, 500);\n    initCollapse();\n    this.arrow = [];\n    this.init();\n    this.initVue();\n  }\n\n  createClass_default()(CatalogControl, [{\n    key: \"initVue\",\n    value: function initVue() {\n      var _this2 = this;\n\n      store[\"a\" /* default */].subscribeAction(function (action, state) {\n        if (action.type === 'filters/onChange') {\n          _this2.change();\n        }\n      }); // Фильтр на десктопе\n\n      this.filterVM = new vue_runtime_esm[\"a\" /* default */]({\n        store: store[\"a\" /* default */],\n        render: function render(h) {\n          return h(CatalogFilter);\n        }\n      }).$mount(this.filterEl); // Управление каталогом для мобилок\n\n      this.catalogControlMobileVM = new vue_runtime_esm[\"a\" /* default */]({\n        store: store[\"a\" /* default */],\n        render: function render(h) {\n          return h(CatalogFilterMobile);\n        }\n      }).$mount();\n      document.body.appendChild(this.catalogControlMobileVM.$el);\n      [].forEach.call(document.querySelectorAll('[data-toggle=\"m-filter\"]'), function (button) {\n        button.addEventListener('click', function (event) {\n          event.preventDefault();\n\n          if (event.currentTarget.dataset.target === '#mobile-filter') {\n            _this2.catalogControlMobileVM.$children[0].open({\n              name: 'filters',\n              title: 'Фильтр'\n            }); // store.dispatch('filters/mobile/showMenu', { name: 'filters', title: 'Фильтр' });\n\n          } else {\n            _this2.catalogControlMobileVM.$children[0].open({\n              name: 'sort',\n              title: 'Сортировка'\n            }); // store.dispatch('filters/mobile/showMenu', { name: 'sort', title: 'Сортировка' });\n\n          }\n        });\n      }); // Список категорий для мобилок\n\n      this.categoryListMobileVM = new vue_runtime_esm[\"a\" /* default */]({\n        store: store[\"a\" /* default */],\n        render: function render(h) {\n          return h(CategoryListMobile);\n        }\n      }).$mount();\n      var catalogControlEl = document.querySelector('.catalog-control');\n\n      if (catalogControlEl) {\n        catalogControlEl.insertBefore(this.categoryListMobileVM.$el, catalogControlEl.firstChild);\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this3 = this;\n\n      this.shownCards = document.querySelectorAll('[data-product-id]').length;\n\n      if (this.formEl) {\n        this.options.method = this.formEl.method;\n        this.options.action = this.formEl.action; // this.formEl.addEventListener('submit', this.update);\n\n        this.formEl.addEventListener('reset', this.onReset);\n      }\n\n      if (this.sortingEl) {\n        this.sortingList = [].map.call(this.sortingEl.querySelectorAll('fieldset.multifilter'), function (filter) {\n          if (filter.querySelector('.multifilter-checkbox')) return new Multifilter[\"a\" /* CheckboxFilter */](filter, 'sort'); // if (filter.querySelector('.multifilter-radio')) return new RadioFilter(filter, this.change);\n\n          if (filter.querySelector('.multifilter-radio')) return new Multifilter[\"d\" /* SelectFilter */](filter, 'sort');\n          return new Multifilter[\"b\" /* Multifilter */](filter, _this3.change);\n        });\n      } // if (this.filterEl) {\n      //   this.filterList = [].map.call(this.filterEl.querySelectorAll('fieldset.multifilter'), (filter) => {\n      //     if (filter.querySelector('.multifilter-checkbox')) return new CheckboxFilter(filter, 'filters');\n      //     // if (filter.querySelector('.multifilter-radio')) return new RadioFilter(filter, this.change);\n      //     if (filter.querySelector('.multifilter-radio')) return new SelectFilter(filter, 'filters');\n      //     if (filter.querySelector('.multifilter-price')) return new PriceFilter(filter, 'filters');\n      //     return new Multifilter(filter, this.change);\n      //   });\n      // }\n\n\n      if (this.filterEl) {\n        [].forEach.call(this.filterEl.querySelectorAll('fieldset.multifilter'), function (filter) {\n          if (filter.querySelector('.multifilter-checkbox')) {\n            store[\"a\" /* default */].commit('filters/pushFilterToContainer', {\n              container: 'filters',\n              filter: Multifilter[\"a\" /* CheckboxFilter */].parseSettings(filter)\n            });\n          }\n\n          if (filter.querySelector('.multifilter-radio')) {\n            store[\"a\" /* default */].commit('filters/pushFilterToContainer', {\n              container: 'filters',\n              filter: Multifilter[\"d\" /* SelectFilter */].parseSettings(filter)\n            });\n          }\n\n          if (filter.querySelector('.multifilter-price')) {\n            store[\"a\" /* default */].commit('filters/pushFilterToContainer', {\n              container: 'filters',\n              filter: Multifilter[\"c\" /* PriceFilter */].parseSettings(filter)\n            });\n          } // new Multifilter(filter, this.change);\n\n        });\n      }\n\n      this.showMoreEl = document.querySelector(\".\".concat(this.classNames.showMore));\n\n      if (this.showMoreEl) {\n        this.showMoreButtonEl = this.showMoreEl.querySelector(\".\".concat(this.classNames.showMoreLink));\n        this.showMoreTextEl = this.showMoreEl.querySelector(\".\".concat(this.classNames.showMoreValue));\n        this.showMoreButtonEl.addEventListener('click', function (event) {\n          event.preventDefault();\n\n          _this3.nextPage();\n        });\n      }\n    }\n  }, {\n    key: \"nextPage\",\n    value: function nextPage() {\n      var _this4 = this;\n\n      var formData = new FormData(this.formEl);\n      var page = this.currentPage + 1;\n      formData.append('page', page.toString());\n      this.showMoreEl.classList.add(this.classNames.showMoreLoading);\n      Object(api[\"g\" /* getFiltredCatalog */])(this.options.action, formData).then(function (data) {\n        _this4.currentPage = page;\n\n        _this4.add(data);\n      }).catch(function (error) {\n        alert(error.message);\n        console.error(error);\n      }).finally(function () {\n        _this4.showMoreEl.classList.remove(_this4.classNames.showMoreLoading);\n      });\n    }\n  }, {\n    key: \"updateQuantity\",\n    value: function updateQuantity() {\n      if (this.quantityEl) {\n        this.quantityEl.textContent = \"\".concat(this.totalCards, \" \").concat(utils[\"a\" /* default */].declOfNum(this.totalCards, ['товар', 'товара', 'товаров']));\n      }\n\n      if (this.showMoreEl) {\n        this.showMoreEl.style.display = this.shownCards < this.totalCards ? '' : 'none';\n      }\n\n      if (this.showMoreTextEl) {\n        this.showMoreTextEl.textContent = \"\\u041F\\u043E\\u043A\\u0430\\u0437\\u0430\\u043D\\u043E \".concat(this.shownCards, \" \\u0438\\u0437 \").concat(this.totalCards);\n      }\n    }\n    /**\n     * Обновить хлебные крошки\n     * @param {Array} array - Массив \"крошек\"\n     * @param {String} title - Заголовок страницы\n     * @param {String} h1 - Заголовок страницы\n     */\n\n  }, {\n    key: \"setBreadcumps\",\n    value: function setBreadcumps(array) {\n      var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var h1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var html = ''; // Новая версия\n\n      html += '<ol class=\"mr-breadcumps__list\" itemscope itemtype=\"https://schema.org/BreadcrumbList\">';\n      array.forEach(function (item, i) {\n        html += '<li class=\"mr-breadcumps__item\" itemprop=\"itemListElement\" itemscope itemtype=\"https://schema.org/ListItem\">';\n\n        if (i === 0) {\n          html += \"<a itemprop=\\\"item\\\" href=\\\"\".concat(item.url, \"\\\"><span itemprop=\\\"name\\\" class=\\\"red\\\">\").concat(item.name, \"</span></a>\");\n        } else if (i === array.length - 1) {\n          html += \"<span itemprop=\\\"name\\\" class=\\\"gray\\\">\".concat(item.name, \"</span>\");\n        } else {\n          html += \"<a itemprop=\\\"item\\\" href=\\\"\".concat(item.url, \"\\\"><span itemprop=\\\"name\\\">\").concat(item.name, \"</span></a>\");\n        }\n\n        html += \"<meta itemprop=\\\"position\\\" content=\\\"\".concat(i + 1, \"\\\"/></li>\");\n      });\n      html += '</ol>';\n      this.breadcumps.innerHTML = html;\n\n      if (title !== '') {\n        document.title = title;\n      }\n\n      if (h1 !== '' && this.title) {\n        this.title.textContent = h1;\n      }\n    } //\n    // onChange = (event) => {\n    //   event.preventDefault();\n    //\n    //   this.change();\n    // };\n\n  }, {\n    key: \"appendItems\",\n    value: function appendItems(items) {\n      var _this5 = this;\n\n      items.forEach(function (item) {\n        if (item.type === 'product') {\n          _this5.shownCards += 1; // Понятия не имею, на сколько это адекватное решение\n\n          var vm = new ProductCartVue({\n            store: store[\"a\" /* default */],\n            propsData: {\n              product: item.options\n            }\n          }).$mount();\n\n          _this5.arrow.push(vm);\n\n          _this5.containerEl.appendChild(vm.$el); // this.containerEl.appendChild(new ProductCard(item.options).getElement());\n\n        } else {\n          _this5.containerEl.appendChild(utils[\"a\" /* default */].htmlToElement(item.html));\n        }\n      });\n      this.updateQuantity();\n    }\n    /**\n     * Заменить карточки товаров\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"reload\",\n    value: function reload(data) {\n      this.currentPage = 1;\n      this.shownCards = 0;\n      this.totalCards = data.count;\n      this.arrow.forEach(function (vm) {\n        vm.$destroy();\n        vm = null;\n      });\n      this.arrow = [];\n      this.containerEl.innerHTML = '';\n      this.appendItems(data.items); // this.shownCards = this.parse(items);\n      // this.listEl.style.height = `${this.listEl.scrollHeight}px`;\n      // return this.shownCards;\n    }\n    /**\n     * Добавить карточки товаров\n     * @param {Object} data\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      this.totalCards = data.count;\n      this.appendItems(data.items); // this.shownCards += this.parse(items);\n      // this.listEl.style.height = `${this.listEl.scrollHeight}px`;\n      // return this.shownCards;\n    } // TODO: Вынести в api\n\n  }, {\n    key: \"reloadPage\",\n    value: function reloadPage() {\n      var _this6 = this;\n\n      // Api.catalog.send(this.options.action, new FormData(this.formEl), page);\n      var formData = new FormData(this.formEl);\n      formData.append('page', 1);\n      return Object(api[\"g\" /* getFiltredCatalog */])(this.options.action, formData).then(function (data) {\n        _this6.reload(data);\n\n        if (data.url) {\n          window.history.replaceState(null, null, data.url);\n        }\n\n        if (data.tags && _this6.breadcumps) {\n          _this6.setBreadcumps(data.tags.breadcrump, data.tags.title, data.tags.h1);\n        }\n\n        if ({}.hasOwnProperty.call(data, 'activatedVariants')) {\n          store[\"a\" /* default */].dispatch('filters/updateActivatedVariants', data);\n        }\n\n        if ({}.hasOwnProperty.call(data, 'hiddenVariants')) {\n          store[\"a\" /* default */].dispatch('filters/updateHiddenVariants', data);\n        }\n      }).catch(function (error) {\n        alert(error.message);\n        console.error(error);\n      }).finally(function () {\n        _this6.containerEl.classList.remove(_this6.classNames.cardListLoading);\n      });\n    }\n  }]);\n\n  return CatalogControl;\n}();\n\ndefineProperty_default()(catalog_CatalogControl, \"defaultOptions\", {\n  ajax: true,\n  method: 'post',\n  action: '/local/public/catalog.php',\n  classNames: {\n    showMore: 'load-more-block',\n    showMoreLoading: 'loading',\n    showMoreLink: 'load-more-block__link',\n    showMoreValue: 'load-more-block__value',\n    cardList: 'card-list',\n    cardListLoading: 'card-list_loading'\n  }\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvc3RvcmUvbW9kdWxlcy9jYXRhbG9nQ29udHJvbE1vYmlsZS5qcz8wODM4Iiwid2VicGFjazovLy8uL3NyYy9qcy9zdG9yZS9tb2R1bGVzL2NhdGFsb2dDb250cm9sLmpzPzY1NzgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0ZWdvcnlMaXN0TW9iaWxlLnZ1ZT9hNDBiIiwid2VicGFjazovLy9zcmMvanMvY29tcG9uZW50cy9DYXRlZ29yeUxpc3RNb2JpbGUudnVlPzMyOTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0ZWdvcnlMaXN0TW9iaWxlLnZ1ZT9mOThkIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL0NhdGVnb3J5TGlzdE1vYmlsZS52dWU/ZGM5NiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9DYXRhbG9nRmlsdGVyTW9iaWxlLnZ1ZT82NDk0Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJSYWRpby52dWU/MWI4YSIsIndlYnBhY2s6Ly8vc3JjL2pzL2NvbXBvbmVudHMvY2F0YWxvZy9NdWx0aWZpbHRlclJhZGlvLnZ1ZT9kZTFlIiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL2NhdGFsb2cvTXVsdGlmaWx0ZXJSYWRpby52dWU/MDk1NCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9jYXRhbG9nL011bHRpZmlsdGVyUmFkaW8udnVlPzFkN2IiLCJ3ZWJwYWNrOi8vL3NyYy9qcy9jb21wb25lbnRzL0NhdGFsb2dGaWx0ZXJNb2JpbGUudnVlP2NkNzAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZS52dWU/ZmJmOCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9DYXRhbG9nRmlsdGVyTW9iaWxlLnZ1ZT9jYTU2Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb21wb25lbnRzL0NhdGFsb2dGaWx0ZXIudnVlP2I3MTQiLCJ3ZWJwYWNrOi8vL3NyYy9qcy9jb21wb25lbnRzL0NhdGFsb2dGaWx0ZXIudnVlPzgzYTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlci52dWU/YmZkNiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29tcG9uZW50cy9DYXRhbG9nRmlsdGVyLnZ1ZT80ZGZjIiwid2VicGFjazovLy8uL3NyYy9qcy9wYWdlL2NhdGFsb2cuanM/NTYyNCJdLCJuYW1lcyI6WyJzdGF0ZSIsImRlZmF1bHRDb250YWluZXIiLCJkZWZhdWx0VGl0bGUiLCJ0aXRsZSIsImlzQWN0aXZlIiwiaXNQYXJlbnQiLCJwYXJlbnROYW1lIiwiY29udGVudFR5cGUiLCJnZXR0ZXJzIiwidmlzaWJsZUJvdHRvbUNvbnRlbnQiLCJyb290U3RhdGUiLCJ2aXNpYmxlQ29udGVudCIsImZpbHRlciIsIml0ZW0iLCJuYW1lIiwiZmlsdGVycyIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhcnIiLCJrZXkiLCJwdXNoIiwib3B0IiwidHlwZSIsImxhYmVsIiwiY2hpbGRUeXBlIiwiYWN0aXZlQ2hpbGRyZW4iLCJkYXRhIiwiY2hlY2tlZCIsIm1hcCIsInJlcGxhY2VUaXRsZSIsImxlbmd0aCIsImpvaW4iLCJsYWJlbEVtcHR5IiwiYWN0aW9ucyIsInNob3dQYXJlbnRzIiwiY29tbWl0Iiwic2hvd0NoaWxkcmVucyIsIm11dGF0aW9ucyIsIlNFVF9ERUZBVUxUX0NPTlRBSU5FUiIsIlNFVF9ERUZBVUxUX1RJVExFIiwiU0VUX0lTX0FDVElWRSIsInN0YXR1cyIsIlNFVF9JU19QQVJFTlQiLCJTRVRfUEFSRU5UX05BTUUiLCJTRVRfQ09OVEVOVF9UWVBFIiwiU0VUX1RJVExFIiwibmFtZXNwYWNlZCIsIml0ZW1zIiwic29ydCIsImNoZWNrZWRJdGVtc0J5TmFtZSIsImNoZWNrZWRJdGVtSWRzQnlOYW1lIiwidmFsdWUiLCJyZXNldEFsbCIsImZvckVhY2giLCJjb250YWluZXIiLCJmaWx0ZXJSZXNldCIsIm9uQ2hhbmdlIiwidXBkYXRlQWN0aXZhdGVkVmFyaWFudHMiLCJhY3RpdmF0ZWRWYXJpYW50cyIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4IiwidXBkYXRlSGlkZGVuVmFyaWFudHMiLCJoaWRkZW5WYXJpYW50cyIsIlJFU0VUX0NIRUNLQk9YX0JZX05BTUUiLCJTRVRfQVZBSUxBQkxFX1NUQVRVU19CWV9OQU1FIiwiYXZhaWxhYmxlIiwiU0VUX0hJRERFTl9TVEFUVVNfQllfTkFNRSIsImhpZGRlbiIsInNldEZpbHRlciIsInNldEZpbHRlcnMiLCJwdXNoRmlsdGVyVG9Db250YWluZXIiLCJtb2R1bGVzIiwibW9iaWxlIiwiY2F0YWxvZ0NvbnRyb2xNb2JpbGUiLCJQcm9kdWN0Q2FydFZ1ZSIsIlZ1ZSIsImV4dGVuZCIsIlByb2R1Y3RDYXJ0IiwiaW5pdENvbGxhcHNlIiwibWF4TGluZUNvdW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJsaW5lSGVpZ2h0IiwicGFyc2VJbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiY2xpZW50SGVpZ2h0IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTGlzdCIsImFkZCIsImlubmVySFRNTCIsInRyaW0iLCJzdHlsZSIsImhlaWdodCIsImJ1dHRvbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwiQ2F0YWxvZ0NvbnRyb2wiLCJlbGVtZW50cyIsImZvcm0iLCJzb3J0aW5nIiwicXVhbnRpdHkiLCJvcHRpb25zIiwic3RvcmUiLCJkaXNwYXRjaCIsInRoZW4iLCJ1cGRhdGUiLCJjb250YWluZXJFbCIsImNsYXNzTmFtZXMiLCJjYXJkTGlzdExvYWRpbmciLCJkZWJvdW5jZWRVcGRhdGUiLCJVdGlscyIsImxvZyIsImFqYXgiLCJmb3JtRWwiLCJzdWJtaXQiLCJyZWxvYWRQYWdlIiwiZSIsInJlbW92ZSIsImFsZXJ0IiwiY29uc29sZSIsImVycm9yIiwicmVnaXN0ZXJNb2R1bGUiLCJjYXRhbG9nQ29udHJvbCIsImZpbHRlckVsIiwicXVlcnlTZWxlY3RvciIsImZpbHRlckxpc3QiLCJzb3J0aW5nRWwiLCJzb3J0aW5nTGlzdCIsImdldEVsZW1lbnRCeUlkIiwicXVhbnRpdHlFbCIsImJyZWFkY3VtcHMiLCJzaG93TW9yZUVsIiwic2hvd01vcmVCdXR0b25FbCIsInNob3dNb3JlVGV4dEVsIiwiY3VycmVudFBhZ2UiLCJzaG93bkNhcmRzIiwidG90YWxDYXJkcyIsImRlZmF1bHRPcHRpb25zIiwiZGVib3VuY2UiLCJhcnJvdyIsImluaXQiLCJpbml0VnVlIiwic3Vic2NyaWJlQWN0aW9uIiwiYWN0aW9uIiwiY2hhbmdlIiwiZmlsdGVyVk0iLCJyZW5kZXIiLCJoIiwiQ2F0YWxvZ0ZpbHRlciIsIiRtb3VudCIsImNhdGFsb2dDb250cm9sTW9iaWxlVk0iLCJDYXRhbG9nRmlsdGVyTW9iaWxlIiwiYm9keSIsIiRlbCIsImN1cnJlbnRUYXJnZXQiLCJkYXRhc2V0IiwidGFyZ2V0IiwiJGNoaWxkcmVuIiwib3BlbiIsImNhdGVnb3J5TGlzdE1vYmlsZVZNIiwiQ2F0ZWdvcnlMaXN0TW9iaWxlIiwiY2F0YWxvZ0NvbnRyb2xFbCIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJtZXRob2QiLCJvblJlc2V0IiwiQ2hlY2tib3hGaWx0ZXIiLCJTZWxlY3RGaWx0ZXIiLCJNdWx0aWZpbHRlciIsInBhcnNlU2V0dGluZ3MiLCJQcmljZUZpbHRlciIsInNob3dNb3JlIiwic2hvd01vcmVMaW5rIiwic2hvd01vcmVWYWx1ZSIsIm5leHRQYWdlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsInBhZ2UiLCJhcHBlbmQiLCJ0b1N0cmluZyIsInNob3dNb3JlTG9hZGluZyIsImdldEZpbHRyZWRDYXRhbG9nIiwiY2F0Y2giLCJtZXNzYWdlIiwiZmluYWxseSIsInRleHRDb250ZW50IiwiZGVjbE9mTnVtIiwiYXJyYXkiLCJoMSIsImh0bWwiLCJpIiwidXJsIiwidm0iLCJwcm9wc0RhdGEiLCJwcm9kdWN0IiwiaHRtbFRvRWxlbWVudCIsInVwZGF0ZVF1YW50aXR5IiwiY291bnQiLCIkZGVzdHJveSIsImFwcGVuZEl0ZW1zIiwicmVsb2FkIiwid2luZG93IiwiaGlzdG9yeSIsInJlcGxhY2VTdGF0ZSIsInRhZ3MiLCJzZXRCcmVhZGN1bXBzIiwiYnJlYWRjcnVtcCIsImNhcmRMaXN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FFQTs7QUFDQSxJQUFNQSwwQkFBSyxHQUFHO0FBQ1pDLGtCQUFnQixFQUFFLFNBRE47QUFFWkMsY0FBWSxFQUFFLFFBRkY7QUFHWkMsT0FBSyxFQUFFLFFBSEs7QUFJWkMsVUFBUSxFQUFFLEtBSkU7QUFLWkMsVUFBUSxFQUFFLElBTEU7QUFNWkMsWUFBVSxFQUFFLElBTkE7QUFPWkMsYUFBVyxFQUFFO0FBUEQsQ0FBZCxDLENBVUE7O0FBQ0EsSUFBTUMsT0FBTyxHQUFHO0FBQ2RDLHNCQUFvQixFQUFFLDhCQUFDVCxLQUFELEVBQVFRLE9BQVIsRUFBaUJFLFNBQWpCLEVBQStCO0FBQ25ELFFBQUlWLEtBQUssQ0FBQ0MsZ0JBQU4sS0FBMkIsTUFBM0IsSUFBcUNELEtBQUssQ0FBQ0ssUUFBL0MsRUFBeUQ7QUFDdkQsYUFBT0csT0FBTyxDQUFDRyxjQUFSLENBQXVCQyxNQUF2QixDQUE4QixVQUFBQyxJQUFJO0FBQUEsZUFBSUEsSUFBSSxDQUFDQyxJQUFMLEtBQWMsTUFBbEI7QUFBQSxPQUFsQyxDQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxLQUFQO0FBQ0QsR0FOYTtBQVFkSCxnQkFBYyxFQUFFLHdCQUFDWCxLQUFELEVBQVFRLE9BQVIsRUFBaUJFLFNBQWpCLEVBQStCO0FBQzdDLFFBQU1LLE9BQU8sR0FBR0wsU0FBUyxDQUFDSyxPQUFWLENBQWtCZixLQUFL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SSxDQXdCSSxZQUFNO0FBQ2IsY0FBSSxDQUFDOUUsV0FBTCxDQUFpQnRCLFNBQWpCLENBQTJCaUMsTUFBM0IsQ0FBa0MsTUFBSSxDQUFDVixVQUFMLENBQWdCQyxlQUFsRDtBQUNELE9BMUJJLENBQVA7QUEyQkQ7Ozs7Ozt5QkFyWmtCWixzQixvQkE4REs7QUFDdEJnQixNQUFJLEVBQUUsSUFEZ0I7QUFFdEJvRCxRQUFNLEVBQUUsTUFGYztBQUd0QnJCLFFBQU0sRUFBRSwyQkFIYztBQUt0QnBDLFlBQVUsRUFBRTtBQUNWZ0UsWUFBUSxFQUFFLGlCQURBO0FBRVZTLG1CQUFlLEVBQUUsU0FGUDtBQUdWUixnQkFBWSxFQUFFLHVCQUhKO0FBSVZDLGlCQUFhLEVBQUUsd0JBSkw7QUFNVmtDLFlBQVEsRUFBRSxXQU5BO0FBT1ZuRyxtQkFBZSxFQUFFO0FBUFA7QUFMVSxDIiwiZmlsZSI6IjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGlzYWJsZUJvZHlTY3JvbGwsIGVuYWJsZUJvZHlTY3JvbGwgfSBmcm9tICdib2R5LXNjcm9sbC1sb2NrJztcblxuLy8gaW5pdGlhbCBzdGF0ZVxuY29uc3Qgc3RhdGUgPSB7XG4gIGRlZmF1bHRDb250YWluZXI6ICdmaWx0ZXJzJyxcbiAgZGVmYXVsdFRpdGxlOiAn0KTQuNC70YzRgtGAJyxcbiAgdGl0bGU6ICfQpNC40LvRjNGC0YAnLFxuICBpc0FjdGl2ZTogZmFsc2UsXG4gIGlzUGFyZW50OiB0cnVlLFxuICBwYXJlbnROYW1lOiBudWxsLFxuICBjb250ZW50VHlwZTogbnVsbCxcbn07XG5cbi8vIGdldHRlcnNcbmNvbnN0IGdldHRlcnMgPSB7XG4gIHZpc2libGVCb3R0b21Db250ZW50OiAoc3RhdGUsIGdldHRlcnMsIHJvb3RTdGF0ZSkgPT4ge1xuICAgIGlmIChzdGF0ZS5kZWZhdWx0Q29udGFpbmVyID09PSAnc29ydCcgJiYgc3RhdGUuaXNQYXJlbnQpIHtcbiAgICAgIHJldHVybiBnZXR0ZXJzLnZpc2libGVDb250ZW50LmZpbHRlcihpdGVtID0+IGl0ZW0ubmFtZSAhPT0gJ1NvcnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIHZpc2libGVDb250ZW50OiAoc3RhdGUsIGdldHRlcnMsIHJvb3RTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGZpbHRlcnMgPSByb290U3RhdGUuZmlsdGVyc1tzdGF0ZS5kZWZhdWx0Q29udGFpbmVyXTtcbiAgICBpZiAoIXN0YXRlLnBhcmVudE5hbWUpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmaWx0ZXJzKS5yZWR1Y2UoKGFyciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChrZXkgIT09ICdUeXBlJyAmJiBrZXkgIT09ICdDYXRlZ29yeScpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSAnU29ydCcpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKGZpbHRlcnNba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogJ211bHRpZmlsdGVyJyxcbiAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICBsYWJlbDogZmlsdGVyc1trZXldLmxhYmVsLFxuICAgICAgICAgICAgICBjaGlsZFR5cGU6IGZpbHRlcnNba2V5XS50eXBlLFxuICAgICAgICAgICAgICBhY3RpdmVDaGlsZHJlbjogW10sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAob3B0LmNoaWxkVHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgICBvcHQuYWN0aXZlQ2hpbGRyZW4gPSBmaWx0ZXJzW2tleV0uZGF0YS5maWx0ZXIoaXRlbSA9PiBpdGVtLmNoZWNrZWQpLm1hcChpdGVtID0+IGl0ZW0ubGFiZWwpIHx8IFtdO1xuXG4gICAgICAgICAgICAgIG9wdC5yZXBsYWNlVGl0bGUgPSBmaWx0ZXJzW2tleV0ucmVwbGFjZVRpdGxlXG4gICAgICAgICAgICAgICAgJiYgKG9wdC5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwID8gb3B0LmFjdGl2ZUNoaWxkcmVuLmpvaW4oJywgJykgOiBmaWx0ZXJzW2tleV0ubGFiZWxFbXB0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcnIucHVzaChvcHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyc1tzdGF0ZS5wYXJlbnROYW1lXS5kYXRhO1xuICB9LFxuXG4gIC8vIGNhblJlc2V0OiAoc3RhdGUsIGdldHRlcnMsIHJvb3RTdGF0ZSkgPT4ge1xuICAvL1xuICAvLyAgIGlmIChzdGF0ZS5jb250ZW50VHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAvLyAgICAgcmV0dXJuIHJvb3RTdGF0ZS5maWx0ZXJzW3N0YXRlLmRlZmF1bHRDb250YWluZXJdW3N0YXRlLnBhcmVudE5hbWVdLmRhdGEuZmlsdGVyKGl0ZW0gPT4gaXRlbS5jaGVja2VkKS5sZW5ndGggPiAwO1xuICAvLyAgIH1cbiAgLy8gICAvLyBpZiAoc3RhdGUuaXNQYXJlbnQpIHtcbiAgLy8gICAvLyAgIHJldHVybiByb290U3RhdGUuZmlsdGVyc1tzdGF0ZS5kZWZhdWx0Q29udGFpbmVyXVtzdGF0ZS5wYXJlbnROYW1lXS5kYXRhLmZpbHRlcihpdGVtID0+IGl0ZW0uY2hlY2tlZCkubGVuZ3RoID4gMDtcbiAgLy8gICAvLyB9XG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH0sXG59O1xuXG4vLyBhY3Rpb25zXG5jb25zdCBhY3Rpb25zID0ge1xuICAvLyBzaG93TWVudSh7IGNvbW1pdCB9LCB7IG5hbWUsIHRpdGxlIH0pIHtcbiAgLy8gICBjb25zdCBvZmZzZXRUb3AgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaC1uYXZiYXItZml4ZWQnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gIC8vXG4gIC8vICAgaWYgKG9mZnNldFRvcCA+IDApIHtcbiAgLy8gICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtcbiAgLy8gICAgICAgc2Nyb2xsVG9wOiBvZmZzZXRUb3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gIC8vICAgICB9KTtcbiAgLy8gICB9XG4gIC8vICAgZGlzYWJsZUJvZHlTY3JvbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhdGFsb2ctbWVudS1tb2InKSk7XG4gIC8vICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAvL1xuICAvLyAgIGNvbW1pdCgnU0VUX0RFRkFVTFRfQ09OVEFJTkVSJywgbmFtZSk7XG4gIC8vICAgY29tbWl0KCdTRVRfREVGQVVMVF9USVRMRScsIHRpdGxlKTtcbiAgLy8gICBjb21taXQoJ1NFVF9DT05URU5UX1RZUEUnLCBudWxsKTtcbiAgLy8gICBjb21taXQoJ1NFVF9QQVJFTlRfTkFNRScsIG51bGwpO1xuICAvLyAgIGNvbW1pdCgnU0VUX0lTX1BBUkVOVCcsIHRydWUpO1xuICAvLyAgIGNvbW1pdCgnU0VUX1RJVExFJywgdGl0bGUpO1xuICAvL1xuICAvLyAgIGNvbW1pdCgnU0VUX0lTX0FDVElWRScsIHRydWUpO1xuICAvLyB9LFxuICAvLyBoaWRlTWVudSh7IGNvbW1pdCwgZGlzcGF0Y2ggfSkge1xuICAvLyAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgLy8gICAvLyBlbmFibGVCb2R5U2Nyb2xsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXRhbG9nLW1lbnUtbW9iJykpO1xuICAvLyAgIGNvbW1pdCgnU0VUX0lTX0FDVElWRScsIGZhbHNlKTtcbiAgLy9cbiAgLy8gICBkaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScsIG51bGwsIHsgcm9vdDogdHJ1ZSB9KTtcbiAgLy8gfSxcbiAgc2hvd1BhcmVudHMoeyBjb21taXQsIHN0YXRlIH0pIHtcbiAgICBjb21taXQoJ1NFVF9DT05URU5UX1RZUEUnLCBudWxsKTtcbiAgICBjb21taXQoJ1NFVF9QQVJFTlRfTkFNRScsIG51bGwpO1xuICAgIGNvbW1pdCgnU0VUX0lTX1BBUkVOVCcsIHRydWUpO1xuICAgIGNvbW1pdCgnU0VUX1RJVExFJywgc3RhdGUuZGVmYXVsdFRpdGxlKTtcbiAgfSxcbiAgc2hvd0NoaWxkcmVucyh7IGNvbW1pdCB9LCBpdGVtKSB7XG4gICAgY29tbWl0KCdTRVRfUEFSRU5UX05BTUUnLCBpdGVtLm5hbWUpO1xuICAgIGNvbW1pdCgnU0VUX0NPTlRFTlRfVFlQRScsIGl0ZW0uY2hpbGRUeXBlKTtcbiAgICBjb21taXQoJ1NFVF9JU19QQVJFTlQnLCBmYWxzZSk7XG4gICAgY29tbWl0KCdTRVRfVElUTEUnLCBpdGVtLmxhYmVsKTtcbiAgfSxcbiAgLy8gcmVzZXQoeyBjb21taXQgfSwgeyB0eXBlLCBuYW1lIH0pIHtcbiAgLy8gICBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAvLyAgICAgY29tbWl0KCdSRVNFVF9DSEVDS0JPWCcsIG5hbWUpO1xuICAvLyAgIH1cbiAgLy8gfSxcbn07XG5cbi8vIG11dGF0aW9uc1xuY29uc3QgbXV0YXRpb25zID0ge1xuICBTRVRfREVGQVVMVF9DT05UQUlORVIoc3RhdGUsIG5hbWUpIHtcbiAgICBzdGF0ZS5kZWZhdWx0Q29udGFpbmVyID0gbmFtZTtcbiAgfSxcbiAgU0VUX0RFRkFVTFRfVElUTEUoc3RhdGUsIHRpdGxlKSB7XG4gICAgc3RhdGUuZGVmYXVsdFRpdGxlID0gdGl0bGU7XG4gIH0sXG4gIFNFVF9JU19BQ1RJVkUoc3RhdGUsIHN0YXR1cykge1xuICAgIHN0YXRlLmlzQWN0aXZlID0gc3RhdHVzO1xuICB9LFxuICBTRVRfSVNfUEFSRU5UKHN0YXRlLCBzdGF0dXMpIHtcbiAgICBzdGF0ZS5pc1BhcmVudCA9IHN0YXR1cztcbiAgfSxcbiAgU0VUX1BBUkVOVF9OQU1FKHN0YXRlLCBwYXJlbnROYW1lKSB7XG4gICAgc3RhdGUucGFyZW50TmFtZSA9IHBhcmVudE5hbWU7XG4gIH0sXG4gIFNFVF9DT05URU5UX1RZUEUoc3RhdGUsIHR5cGUpIHtcbiAgICBzdGF0ZS5jb250ZW50VHlwZSA9IHR5cGU7XG4gIH0sXG4gIFNFVF9USVRMRShzdGF0ZSwgdGl0bGUpIHtcbiAgICBzdGF0ZS50aXRsZSA9IHRpdGxlO1xuICB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lc3BhY2VkOiB0cnVlLFxuICBzdGF0ZSxcbiAgZ2V0dGVycyxcbiAgYWN0aW9ucyxcbiAgbXV0YXRpb25zLFxufTtcbiIsImltcG9ydCBjYXRhbG9nQ29udHJvbE1vYmlsZSBmcm9tICcuL2NhdGFsb2dDb250cm9sTW9iaWxlJztcblxuLy8gaW5pdGlhbCBzdGF0ZVxuY29uc3Qgc3RhdGUgPSB7XG4gIGl0ZW1zOiBbXSxcbiAgZmlsdGVyczoge30sXG4gIHNvcnQ6IHt9LFxufTtcblxuLy8gZ2V0dGVyc1xuY29uc3QgZ2V0dGVycyA9IHtcbiAgLy8gZmlsdGVyQnlOYW1lOiBzdGF0ZSA9PiBuYW1lID0+IHN0YXRlLml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpLFxuICAvLyBob3Jpem9udGFsRmlsdGVyczogc3RhdGUgPT4gc3RhdGUuaXRlbXMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5uYW1lID09PSAnVHlwZScgfHwgaXRlbS5uYW1lID09PSAnQ2F0ZWdvcnknKSxcbiAgLy8gbW9kYWxGaWx0ZXJzOiBzdGF0ZSA9PiBzdGF0ZS5pdGVtcy5maWx0ZXIoaXRlbSA9PiBpdGVtLm5hbWUgIT09ICdUeXBlJyAmJiBpdGVtLm5hbWUgIT09ICdDYXRlZ29yeScpLFxuICBjaGVja2VkSXRlbXNCeU5hbWU6IHN0YXRlID0+IG5hbWUgPT4gc3RhdGUuZmlsdGVyc1tuYW1lXS5kYXRhLmZpbHRlcihpdGVtID0+IGl0ZW0uY2hlY2tlZCksXG4gIGNoZWNrZWRJdGVtSWRzQnlOYW1lOiAoc3RhdGUsIGdldHRlcnMpID0+IG5hbWUgPT4gZ2V0dGVycy5jaGVja2VkSXRlbXNCeU5hbWUobmFtZSkubWFwKGl0ZW0gPT4gaXRlbS52YWx1ZSksXG59O1xuXG4vLyBhY3Rpb25zXG5jb25zdCBhY3Rpb25zID0ge1xuICByZXNldEFsbCh7IHN0YXRlLCBjb21taXQgfSkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmZpbHRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmZpbHRlcnNba2V5XS50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIGNvbW1pdCgnUkVTRVRfQ0hFQ0tCT1hfQllfTkFNRScsIHsgY29udGFpbmVyOiAnZmlsdGVycycsIG5hbWU6IGtleSB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBjYWxsYmFjaygpO1xuICB9LFxuXG4gIGZpbHRlclJlc2V0KHsgY29tbWl0IH0sIHsgdHlwZSwgY29udGFpbmVyLCBuYW1lIH0pIHtcbiAgICBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgY29tbWl0KCdSRVNFVF9DSEVDS0JPWF9CWV9OQU1FJywgeyBjb250YWluZXIsIG5hbWUgfSk7XG4gICAgfVxuICB9LFxuICBvbkNoYW5nZSgpIHtcbiAgfSxcblxuICAvLyBjaGFuZ2VQYXJlbnRJdGVtcygpXG5cbiAgLy8gYWN0aXZhdGVkVmFyaWFudHNcbiAgLy8gVE9ETzog0J/QtdGA0LXQtNC10LvQsNGC0Ywg0Y3RgtC+INCz0L7QstC90L4g0Log0YfQtdGA0YLQvtCy0L7QuSDQvNCw0YLQtdGA0LhcbiAgdXBkYXRlQWN0aXZhdGVkVmFyaWFudHMoeyBzdGF0ZSwgY29tbWl0IH0sIHsgYWN0aXZhdGVkVmFyaWFudHMgfSkge1xuICAgIE9iamVjdC5rZXlzKGFjdGl2YXRlZFZhcmlhbnRzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLmZpbHRlcnMsIGtleSkgJiYgc3RhdGUuZmlsdGVyc1trZXldLnR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgc3RhdGUuZmlsdGVyc1trZXldLmRhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb21taXQoJ1NFVF9BVkFJTEFCTEVfU1RBVFVTX0JZX05BTUUnLCB7XG4gICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHN0YXR1czoge30uaGFzT3duUHJvcGVydHkuY2FsbChhY3RpdmF0ZWRWYXJpYW50c1trZXldLCBpdGVtLnZhbHVlKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8vIGhpZGRlblZhcmlhbnRzXG4gIC8vIFRPRE86INCYINGN0YLRgyDRhdC10YDQvdGOINCyINGC0L7QvCDRh9C40YHQu9C1XG4gIHVwZGF0ZUhpZGRlblZhcmlhbnRzKHsgc3RhdGUsIGNvbW1pdCB9LCB7IGhpZGRlblZhcmlhbnRzIH0pIHtcbiAgICBPYmplY3Qua2V5cyhoaWRkZW5WYXJpYW50cykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5maWx0ZXJzLCBrZXkpICYmIHN0YXRlLmZpbHRlcnNba2V5XS50eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIHN0YXRlLmZpbHRlcnNba2V5XS5kYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29tbWl0KCdTRVRfSElEREVOX1NUQVRVU19CWV9OQU1FJywge1xuICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBzdGF0dXM6IHt9Lmhhc093blByb3BlcnR5LmNhbGwoaGlkZGVuVmFyaWFudHNba2V5XSwgaXRlbS52YWx1ZSksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufTtcblxuLy8gbXV0YXRpb25zXG5jb25zdCBtdXRhdGlvbnMgPSB7XG4gIFJFU0VUX0NIRUNLQk9YX0JZX05BTUUoc3RhdGUsIHsgY29udGFpbmVyLCBuYW1lIH0pIHtcbiAgICBzdGF0ZVtjb250YWluZXJdW25hbWVdLmRhdGEuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaXRlbS5jaGVja2VkID0gZmFsc2U7XG4gICAgfSk7XG4gIH0sXG4gIFNFVF9BVkFJTEFCTEVfU1RBVFVTX0JZX05BTUUoc3RhdGUsIHsgbmFtZSwgaW5kZXgsIHN0YXR1cyB9KSB7XG4gICAgc3RhdGUuZmlsdGVyc1tuYW1lXS5kYXRhW2luZGV4XS5hdmFpbGFibGUgPSBzdGF0dXM7XG4gIH0sXG4gIFNFVF9ISURERU5fU1RBVFVTX0JZX05BTUUoc3RhdGUsIHsgbmFtZSwgaW5kZXgsIHN0YXR1cyB9KSB7XG4gICAgc3RhdGUuZmlsdGVyc1tuYW1lXS5kYXRhW2luZGV4XS5oaWRkZW4gPSBzdGF0dXM7XG4gIH0sXG4gIC8vIHNldENhbGxiYWNrKHN0YXRlLCBjYWxsYmFjaykge1xuICAvLyAgIHN0YXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIC8vIH0sXG4gIHNldEZpbHRlcihzdGF0ZSwgZmlsdGVyKSB7XG4gICAgc3RhdGUuZmlsdGVycyA9IHtcbiAgICAgIC4uLnN0YXRlLmZpbHRlcnMsXG4gICAgICBbZmlsdGVyLm5hbWVdOiBmaWx0ZXIsXG4gICAgfTtcbiAgICAvLyBWdWUuc2V0KHN0YXRlLmxpc3QsIGZpbHRlci5uYW1lLCBmaWx0ZXIpO1xuICB9LFxuICBzZXRGaWx0ZXJzKHN0YXRlLCBmaWx0ZXJzKSB7XG4gICAgc3RhdGUuZmlsdGVycyA9IGZpbHRlcnM7XG4gIH0sXG4gIHB1c2hGaWx0ZXJUb0NvbnRhaW5lcihzdGF0ZSwgeyBjb250YWluZXIsIGZpbHRlciB9KSB7XG4gICAgc3RhdGVbY29udGFpbmVyXSA9IHtcbiAgICAgIC4uLnN0YXRlW2NvbnRhaW5lcl0sXG4gICAgICBbZmlsdGVyLm5hbWVdOiBmaWx0ZXIsXG4gICAgfTtcbiAgICBzdGF0ZS5pdGVtcy5wdXNoKGZpbHRlcik7XG4gIH0sXG4gIC8vIGZpbHRlclJlc2V0KCkge1xuICAvLyAgIGNvbnNvbGUubG9nKCdyZXNldCcpO1xuICAvLyB9LFxuICAvLyBmaWx0ZXJDaGFuZ2UoKSB7XG4gIC8vICAgY29uc29sZS5sb2coJ2NoYW5nZScpO1xuICAvLyB9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lc3BhY2VkOiB0cnVlLFxuICBzdGF0ZSxcbiAgZ2V0dGVycyxcbiAgYWN0aW9ucyxcbiAgbXV0YXRpb25zLFxuICBtb2R1bGVzOiB7XG4gICAgbW9iaWxlOiBjYXRhbG9nQ29udHJvbE1vYmlsZSxcbiAgfSxcbn07XG4iLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nLWNvbnRyb2xfX21vYmlsZVwifSxbKF92bS50eXBlRmlsdGVyKT9bX2MoJ0NhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsJyx7YXR0cnM6e1wiZmlsdGVyXCI6X3ZtLnR5cGVGaWx0ZXJ9fSldOl92bS5fZSgpLF92bS5fdihcIiBcIiksKF92bS5jYXRlZ29yeUZpbHRlcik/W19jKCdDYXRhbG9nRmlsdGVyTW9iaWxlSG9yaXpvbnRhbCcse2F0dHJzOntcImZpbHRlclwiOl92bS5jYXRlZ29yeUZpbHRlcn19KV06X3ZtLl9lKCldLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJjYXRhbG9nLWNvbnRyb2xfX21vYmlsZVwiPlxuICAgIDx0ZW1wbGF0ZSB2LWlmPVwidHlwZUZpbHRlclwiPlxuICAgICAgPENhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsIDpmaWx0ZXI9XCJ0eXBlRmlsdGVyXCIvPlxuICAgIDwvdGVtcGxhdGU+XG4gICAgPHRlbXBsYXRlIHYtaWY9XCJjYXRlZ29yeUZpbHRlclwiPlxuICAgICAgPENhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsIDpmaWx0ZXI9XCJjYXRlZ29yeUZpbHRlclwiLz5cbiAgICA8L3RlbXBsYXRlPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IG1hcEdldHRlcnMsIG1hcFN0YXRlLCBtYXBBY3Rpb25zIH0gZnJvbSAndnVleCc7XG4gIGltcG9ydCBDYXRhbG9nRmlsdGVyTW9iaWxlSG9yaXpvbnRhbCBmcm9tICcuL0NhdGFsb2dGaWx0ZXJNb2JpbGVIb3Jpem9udGFsLnZ1ZSc7XG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiQ2F0ZWdvcnlMaXN0TW9iaWxlXCIsXG4gICAgY29tcG9uZW50czoge1xuICAgICAgQ2F0YWxvZ0ZpbHRlck1vYmlsZUhvcml6b250YWxcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAuLi5tYXBTdGF0ZSgnZmlsdGVycycsIHtcbiAgICAgICAgLy8gZmlsdGVyczogc3RhdGUgPT4gc3RhdGUuZmlsdGVycyxcbiAgICAgICAgdHlwZUZpbHRlcjogc3RhdGUgPT4gc3RhdGUuZmlsdGVyc1snVHlwZSddLFxuICAgICAgICBjYXRlZ29yeUZpbHRlcjogc3RhdGUgPT4gc3RhdGUuZmlsdGVyc1snQ2F0ZWdvcnknXSxcbiAgICAgIH0pLFxuICAgICAgLy8gLi4ubWFwR2V0dGVycygnZmlsdGVycycsIHtcbiAgICAgIC8vICAgY2hlY2tlZEl0ZW1JZHNCeU5hbWU6ICdjaGVja2VkSXRlbUlkc0J5TmFtZScsXG4gICAgICAvLyAgIC8vIGZpbHRlcnM6ICdob3Jpem9udGFsRmlsdGVycydcbiAgICAgIC8vIH0pXG4gICAgfSxcblxuICB9XG48L3NjcmlwdD5cblxuPCEtLTxzdHlsZSBzY29wZWQ+LS0+XG5cbjwhLS08L3N0eWxlPi0tPlxuIiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/cmVmLS0zLTAhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9DYXRlZ29yeUxpc3RNb2JpbGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTMtMCEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0NhdGVnb3J5TGlzdE1vYmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0NhdGVnb3J5TGlzdE1vYmlsZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NDdiMzAwZmEmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQ2F0ZWdvcnlMaXN0TW9iaWxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQ2F0ZWdvcnlMaXN0TW9iaWxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY2F0YWxvZy1tZW51LW1vYlwiLGNsYXNzOnthY3RpdmU6IF92bS5pc0FjdGl2ZX19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nLW1lbnUtbW9iX19oZWFkZXJcIn0sWyghX3ZtLmlzUGFyZW50KT9fYygnYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nLW1lbnUtbW9iX19idG4tYmFja1wiLG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLmJhY2soJGV2ZW50KX19fSk6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiY2F0YWxvZy1tZW51LW1vYl9fdGl0bGVcIn0sW192bS5fdihfdm0uX3MoX3ZtLnRpdGxlKSldKSxfdm0uX3YoXCIgXCIpLChfdm0uaXNQYXJlbnQpP19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcImNhdGFsb2ctbWVudS1tb2JfX2J0bi1jbG9zZVwiLG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLmNsb3NlKCRldmVudCl9fX0pOl92bS5fZSgpXSksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nLW1lbnUtbW9iX193cmFwcGVyXCJ9LFsoX3ZtLmNvbnRlbnRUeXBlID09PSAncmFuZ2UnKT9fYygnTXVsdGlmaWx0ZXJQcmljZScse2F0dHJzOntcInNsaWRlclwiOl92bS5jb250ZW50fSxvbjp7XCJjaGFuZ2VcIjpfdm0ub25DaGFuZ2V9fSk6KF92bS5jb250ZW50VHlwZSA9PT0gJ2NoZWNrYm94Jyk/X2MoJ011bHRpZmlsdGVyQ2hlY2tib3hMaXN0Jyx7YXR0cnM6e1wiaXRlbXNcIjpfdm0uY29udGVudCxcInNlYXJjaFwiOmZhbHNlfSxvbjp7XCJjaGFuZ2VcIjpfdm0ub25DaGFuZ2V9fSk6W192bS5fbCgoX3ZtLmNvbnRlbnQpLGZ1bmN0aW9uKGl0ZW0pe3JldHVybiBbKGl0ZW0udHlwZSA9PT0gJ211bHRpZmlsdGVyJyAmJiAhX3ZtLmJvdHRvbUNvbnRlbnQpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyXCIsY2xhc3M6e2FjdGl2ZTogaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwfX0sW19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19jb250ZW50IG11bHRpZmlsdGVyX19jb250ZW50X3BhcmVudFwiLG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLm5leHQoaXRlbSl9fX0sWyghaXRlbS5yZXBsYWNlVGl0bGUpP19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fdmFsdWVcIn0sW192bS5fdihfdm0uX3MoaXRlbS5sYWJlbCkpXSk6W19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlcl9fbGFiZWxcIn0sW192bS5fdihfdm0uX3MoaXRlbS5sYWJlbCkpXSksX3ZtLl92KFwiIFwiKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX3ZhbHVlXCJ9LFtfdm0uX3YoX3ZtLl9zKGl0ZW0ucmVwbGFjZVRpdGxlKSldKV0sX3ZtLl92KFwiIFwiKSxfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwKSxleHByZXNzaW9uOlwiaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwXCJ9XSxzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX190b3RhbFwifSxbX3ZtLl92KF92bS5fcyhpdGVtLmFjdGl2ZUNoaWxkcmVuLmxlbmd0aCkpXSldLDIpLF92bS5fdihcIiBcIiksX2MoJ2J1dHRvbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwKSxleHByZXNzaW9uOlwiaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwXCJ9XSxzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19idG4tY2xlYXJcIixvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS5vblJlc2V0Um93KGl0ZW0ubmFtZSwgaXRlbS5jaGlsZFR5cGUpfX19LFtfdm0uX3YoXCLQodCx0YDQvtGB0LjRgtGMXCIpXSldKTooaXRlbS50eXBlID09PSAncmFkaW8nKT9fdm0uX2woKGl0ZW0uZGF0YSksZnVuY3Rpb24ocmFkaW8pe3JldHVybiBfYygnbGFiZWwnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXJhZGlvXCJ9LFtfYygnaW5wdXQnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooaXRlbS5zZWxlY3RlZCksZXhwcmVzc2lvbjpcIml0ZW0uc2VsZWN0ZWRcIn1dLHN0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcmFkaW9fX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwicmFkaW9cIixcIm5hbWVcIjpyYWRpby5uYW1lfSxkb21Qcm9wczp7XCJ2YWx1ZVwiOnJhZGlvLnZhbHVlLFwiY2hlY2tlZFwiOl92bS5fcShpdGVtLnNlbGVjdGVkLHJhZGlvLnZhbHVlKX0sb246e1wiY2hhbmdlXCI6W2Z1bmN0aW9uKCRldmVudCl7cmV0dXJuIF92bS4kc2V0KGl0ZW0sIFwic2VsZWN0ZWRcIiwgcmFkaW8udmFsdWUpfSxfdm0ub25DaGFuZ2VdfX0pLF92bS5fdihcIiBcIiksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyLXJhZGlvX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhyYWRpby5sYWJlbCkpXSldKX0pOl92bS5fZSgpXX0pXV0sMiksX3ZtLl92KFwiIFwiKSwoX3ZtLmJvdHRvbUNvbnRlbnQubGVuZ3RoKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nLW1lbnUtbW9iX193cmFwcGVyXCIsc3RhdGljU3R5bGU6e1wib3ZlcmZsb3dcIjpcImhpZGRlblwiLFwiZmxleFwiOlwiMCAwIGF1dG9cIn19LFtfdm0uX2woKF92bS5ib3R0b21Db250ZW50KSxmdW5jdGlvbihpdGVtKXtyZXR1cm4gWyhpdGVtLnR5cGUgPT09ICdtdWx0aWZpbHRlcicpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyXCIsY2xhc3M6e2FjdGl2ZTogaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwfX0sW19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19jb250ZW50IG11bHRpZmlsdGVyX19jb250ZW50X3BhcmVudFwiLG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLm5leHQoaXRlbSl9fX0sWyhpdGVtLnJlcGxhY2VUaXRsZSk/X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhpdGVtLmxhYmVsKSldKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLChpdGVtLnJlcGxhY2VUaXRsZSk/X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX192YWx1ZVwifSxbX3ZtLl92KF92bS5fcyhpdGVtLnJlcGxhY2VUaXRsZSkpXSk6X2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX192YWx1ZVwifSxbX3ZtLl92KF92bS5fcyhpdGVtLmxhYmVsKSldKSxfdm0uX3YoXCIgXCIpLF9jKCdzcGFuJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOihpdGVtLmFjdGl2ZUNoaWxkcmVuLmxlbmd0aCA+IDApLGV4cHJlc3Npb246XCJpdGVtLmFjdGl2ZUNoaWxkcmVuLmxlbmd0aCA+IDBcIn1dLHN0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXJfX3RvdGFsXCJ9LFtfdm0uX3YoX3ZtLl9zKGl0ZW0uYWN0aXZlQ2hpbGRyZW4ubGVuZ3RoKSldKV0pLF92bS5fdihcIiBcIiksX2MoJ2J1dHRvbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwKSxleHByZXNzaW9uOlwiaXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGggPiAwXCJ9XSxzdGF0aWNDbGFzczpcIm11bHRpZmlsdGVyX19idG4tY2xlYXJcIixvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS5vblJlc2V0Um93KGl0ZW0ubmFtZSwgaXRlbS5jaGlsZFR5cGUpfX19LFtfdm0uX3YoXCLQodCx0YDQvtGB0LjRgtGMXCIpXSldKTpfdm0uX2UoKV19KV0sMik6X3ZtLl9lKCksX3ZtLl92KFwiIFwiKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjYXRhbG9nLW1lbnUtbW9iX19mb290ZXJcIn0sWyhfdm0udHlwZSA9PT0gJ2ZpbHRlcnMnIHx8ICFfdm0uaXNQYXJlbnQpP19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcImNhdGFsb2ctbWVudS1tb2JfX2J0bi1mb290ZXIgYnRuIGJ0bi1ncmF5LTJcIixhdHRyczp7XCJkaXNhYmxlZFwiOiFfdm0uY2FuUmVzZXR9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLm9uUmVzZXRGb290ZXIoX3ZtLnBhcmVudE5hbWUsIF92bS5jb250ZW50VHlwZSl9fX0sW19jKCdzdmcnLHtzdGF0aWNDbGFzczpcImJ0bi1pY29uXCIsYXR0cnM6e1wid2lkdGhcIjpcIjEyXCIsXCJoZWlnaHRcIjpcIjEyXCIsXCJ2aWV3Qm94XCI6XCIwIDAgMTIgMTJcIixcImZpbGxcIjpcIm5vbmVcIixcInhtbG5zXCI6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wifX0sW19jKCdwYXRoJyx7YXR0cnM6e1wiZmlsbC1ydWxlXCI6XCJldmVub2RkXCIsXCJjbGlwLXJ1bGVcIjpcImV2ZW5vZGRcIixcImRcIjpcIk0yLjE3ODUxIDAuODIxNzc3TDAuODIyNDcyIDIuMTc3N0w0LjY0NDI5IDUuOTk5ODRMMC44MjIyNjYgOS44MjE4N0wyLjE3ODI1IDExLjE3NzlMNi4wMDAyMiA3LjM1NTg4TDkuODIxOTUgMTEuMTc3OUwxMS4xNzggOS44MjIwMUw3LjM1NjIgNS45OTk5TDExLjE3ODEgMi4xNzhMOS44MjIxMiAwLjgyMjAxNEw2LjAwMDI3IDQuNjQzODZMMi4xNzg1MSAwLjgyMTc3N1pcIixcImZpbGxcIjpcImN1cnJlbnRDb2xvclwifX0pXSksX3ZtLl92KFwiXFxuICAgICAg0KHQsdGA0L7RgdC40YLRjFxcbiAgICBcIildKTpfdm0uX2UoKSxfdm0uX3YoXCIgXCIpLChfdm0uaXNQYXJlbnQpP19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcImNhdGFsb2ctbWVudS1tb2JfX2J0bi1mb290ZXIgYnRuIGJ0bi1yZWRcIixhdHRyczp7XCJkaXNhYmxlZFwiOiFfdm0uY2FuUmVzZXR9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTtyZXR1cm4gX3ZtLmNsb3NlKCRldmVudCl9fX0sW192bS5fdihcItCf0YDQuNC80LXQvdC40YLRjFwiKV0pOl92bS5fZSgpXSldKX1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2xhYmVsJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1yYWRpb1wifSxbX2MoJ2lucHV0Jyxfdm0uX2Ioe3N0YXRpY0NsYXNzOlwibXVsdGlmaWx0ZXItcmFkaW9fX2lucHV0XCIsYXR0cnM6e1widHlwZVwiOlwicmFkaW9cIn0sZG9tUHJvcHM6e1wiY2hlY2tlZFwiOl92bS5jaGVja2VkfSxvbjp7XCJjaGFuZ2VcIjpfdm0ub25DaGFuZ2V9fSwnaW5wdXQnLF92bS4kYXR0cnMsZmFsc2UpKSxfdm0uX3YoXCIgXCIpLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJtdWx0aWZpbHRlci1yYWRpb19fbGFiZWxcIn0sW192bS5fdChcImRlZmF1bHRcIildLDIpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cbiAgPGxhYmVsIGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9cIj5cbiAgICA8aW5wdXQgY2xhc3M9XCJtdWx0aWZpbHRlci1yYWRpb19faW5wdXRcIlxuICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICAgICAgICA6Y2hlY2tlZD1cImNoZWNrZWRcIlxuICAgICAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJtdWx0aWZpbHRlci1yYWRpb19fbGFiZWxcIj48c2xvdD48L3Nsb3Q+PC9zcGFuPlxuICA8L2xhYmVsPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIG5hbWU6IFwiTXVsdGlmaWx0ZXJSYWRpb1wiLFxuICAgIGluaGVyaXRBdHRyczogZmFsc2UsXG4gICAgbW9kZWw6IHtcbiAgICAgIHByb3A6ICdjaGVja2VkJyxcbiAgICAgIGV2ZW50OiAnY2hhbmdlJ1xuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGNoZWNrZWQ6IHtcbiAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB9LFxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudC50YXJnZXQuY2hlY2tlZClcbiAgICAgIH1cbiAgICB9LFxuICB9XG48L3NjcmlwdD5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJSYWRpby52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTXVsdGlmaWx0ZXJSYWRpby52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL011bHRpZmlsdGVyUmFkaW8udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI1M2U0NTQwJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL011bHRpZmlsdGVyUmFkaW8udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9NdWx0aWZpbHRlclJhZGlvLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiY2F0YWxvZy1tZW51LW1vYlwiXG4gICAgICAgOmNsYXNzPVwie2FjdGl2ZTogaXNBY3RpdmV9XCI+XG4gICAgPGRpdiBjbGFzcz1cImNhdGFsb2ctbWVudS1tb2JfX2hlYWRlclwiPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImNhdGFsb2ctbWVudS1tb2JfX2J0bi1iYWNrXCIgdi1pZj1cIiFpc1BhcmVudFwiIEBjbGljay5wcmV2ZW50PVwiYmFja1wiPjwvYnV0dG9uPlxuICAgICAgPHNwYW4gY2xhc3M9XCJjYXRhbG9nLW1lbnUtbW9iX190aXRsZVwiPnt7dGl0bGV9fTwvc3Bhbj5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJjYXRhbG9nLW1lbnUtbW9iX19idG4tY2xvc2VcIiB2LWlmPVwiaXNQYXJlbnRcIiBAY2xpY2sucHJldmVudD1cImNsb3NlXCI+PC9idXR0b24+XG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdiBjbGFzcz1cImNhdGFsb2ctbWVudS1tb2JfX3dyYXBwZXJcIj5cbiAgICAgIDxNdWx0aWZpbHRlclByaWNlXG4gICAgICAgIHYtaWY9XCJjb250ZW50VHlwZSA9PT0gJ3JhbmdlJ1wiXG4gICAgICAgIDpzbGlkZXI9XCJjb250ZW50XCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgICAgIC8+XG4gICAgICA8TXVsdGlmaWx0ZXJDaGVja2JveExpc3RcbiAgICAgICAgdi1lbHNlLWlmPVwiY29udGVudFR5cGUgPT09ICdjaGVja2JveCdcIlxuICAgICAgICA6aXRlbXM9XCJjb250ZW50XCJcbiAgICAgICAgOnNlYXJjaD1cImZhbHNlXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgICAgIC8+XG4gICAgICA8dGVtcGxhdGUgdi1lbHNlPlxuICAgICAgICA8dGVtcGxhdGUgdi1mb3I9XCJpdGVtIGluIGNvbnRlbnRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibXVsdGlmaWx0ZXJcIlxuICAgICAgICAgICAgICAgdi1pZj1cIml0ZW0udHlwZSA9PT0gJ211bHRpZmlsdGVyJyAmJiAhYm90dG9tQ29udGVudFwiXG4gICAgICAgICAgICAgICA6Y2xhc3M9XCJ7YWN0aXZlOiBpdGVtLmFjdGl2ZUNoaWxkcmVuLmxlbmd0aCA+IDB9XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2NvbnRlbnQgbXVsdGlmaWx0ZXJfX2NvbnRlbnRfcGFyZW50XCIgQGNsaWNrLnByZXZlbnQ9XCJuZXh0KGl0ZW0pXCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXJfX3ZhbHVlXCIgdi1pZj1cIiFpdGVtLnJlcGxhY2VUaXRsZVwiPnt7aXRlbS5sYWJlbH19PC9zcGFuPlxuICAgICAgICAgICAgICA8dGVtcGxhdGUgdi1lbHNlPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2xhYmVsXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+IDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXJfX3ZhbHVlXCI+e3tpdGVtLnJlcGxhY2VUaXRsZX19PC9zcGFuPlxuICAgICAgICAgICAgICA8L3RlbXBsYXRlPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm11bHRpZmlsdGVyX190b3RhbFwiIHYtc2hvdz1cIml0ZW0uYWN0aXZlQ2hpbGRyZW4ubGVuZ3RoID4gMFwiPnt7aXRlbS5hY3RpdmVDaGlsZHJlbi5sZW5ndGh9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2J0bi1jbGVhclwiXG4gICAgICAgICAgICAgIHYtc2hvdz1cIml0ZW0uYWN0aXZlQ2hpbGRyZW4ubGVuZ3RoID4gMFwiXG4gICAgICAgICAgICAgIEBjbGljay5wcmV2ZW50PVwib25SZXNldFJvdyhpdGVtLm5hbWUsIGl0ZW0uY2hpbGRUeXBlKVwiXG4gICAgICAgICAgICA+0KHQsdGA0L7RgdC40YLRjDwvYnV0dG9uPlxuICAgICAgICAgIFxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIFxuICAgICAgICAgIDx0ZW1wbGF0ZSB2LWVsc2UtaWY9XCJpdGVtLnR5cGUgPT09ICdyYWRpbydcIj5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cIm11bHRpZmlsdGVyLXJhZGlvXCIgdi1mb3I9XCJyYWRpbyBpbiBpdGVtLmRhdGFcIj5cbiAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9fX2lucHV0XCIgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgICAgICAgICAgIDpuYW1lPVwicmFkaW8ubmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICA6dmFsdWU9XCJyYWRpby52YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICB2LW1vZGVsPVwiaXRlbS5zZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgICBAY2hhbmdlPVwib25DaGFuZ2VcIlxuICAgICAgICAgICAgICA+IDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXItcmFkaW9fX2xhYmVsXCI+e3tyYWRpby5sYWJlbH19PC9zcGFuPiA8L2xhYmVsPlxuICAgICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICA8L3RlbXBsYXRlPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjYXRhbG9nLW1lbnUtbW9iX193cmFwcGVyXCIgc3R5bGU9XCJvdmVyZmxvdzogaGlkZGVuO2ZsZXg6IDAgMCBhdXRvO1wiIHYtaWY9XCJib3R0b21Db250ZW50Lmxlbmd0aFwiPlxuICAgICAgPHRlbXBsYXRlIHYtZm9yPVwiaXRlbSBpbiBib3R0b21Db250ZW50XCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzcz1cIm11bHRpZmlsdGVyXCJcbiAgICAgICAgICB2LWlmPVwiaXRlbS50eXBlID09PSAnbXVsdGlmaWx0ZXInXCJcbiAgICAgICAgICA6Y2xhc3M9XCJ7YWN0aXZlOiBpdGVtLmFjdGl2ZUNoaWxkcmVuLmxlbmd0aCA+IDB9XCJcbiAgICAgICAgPlxuICAgICAgICAgIFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJtdWx0aWZpbHRlcl9fY29udGVudCBtdWx0aWZpbHRlcl9fY29udGVudF9wYXJlbnRcIiBAY2xpY2sucHJldmVudD1cIm5leHQoaXRlbSlcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXJfX2xhYmVsXCIgdi1pZj1cIml0ZW0ucmVwbGFjZVRpdGxlXCI+e3tpdGVtLmxhYmVsfX08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm11bHRpZmlsdGVyX192YWx1ZVwiIHYtaWY9XCJpdGVtLnJlcGxhY2VUaXRsZVwiPnt7aXRlbS5yZXBsYWNlVGl0bGV9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibXVsdGlmaWx0ZXJfX3ZhbHVlXCIgdi1lbHNlPnt7aXRlbS5sYWJlbH19PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtdWx0aWZpbHRlcl9fdG90YWxcIiB2LXNob3c9XCJpdGVtLmFjdGl2ZUNoaWxkcmVuLmxlbmd0aCA+IDBcIj57e2l0ZW0uYWN0aXZlQ2hpbGRyZW4ubGVuZ3RofX08L3NwYW4+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgY2xhc3M9XCJtdWx0aWZpbHRlcl9fYnRuLWNsZWFyXCJcbiAgICAgICAgICAgIHYtc2hvdz1cIml0ZW0uYWN0aXZlQ2hpbGRyZW4ubGVuZ3RoID4gMFwiXG4gICAgICAgICAgICBAY2xpY2sucHJldmVudD1cIm9uUmVzZXRSb3coaXRlbS5uYW1lLCBpdGVtLmNoaWxkVHlwZSlcIlxuICAgICAgICAgID7QodCx0YDQvtGB0LjRgtGMPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC90ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgICBcbiAgICA8ZGl2IGNsYXNzPVwiY2F0YWxvZy1tZW51LW1vYl9fZm9vdGVyXCI+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzPVwiY2F0YWxvZy1tZW51LW1vYl9fYnRuLWZvb3RlciBidG4gYnRuLWdyYXktMlwiXG4gICAgICAgIHYtaWY9XCJ0eXBlID09PSAnZmlsdGVycycgfHwgIWlzUGFyZW50XCJcbiAgICAgICAgOmRpc2FibGVkPVwiIWNhblJlc2V0XCJcbiAgICAgICAgQGNsaWNrLnByZXZlbnQ9XCJvblJlc2V0Rm9vdGVyKHBhcmVudE5hbWUsIGNvbnRlbnRUeXBlKVwiXG4gICAgICA+XG4gICAgICAgIDxzdmcgY2xhc3M9XCJidG4taWNvblwiIHdpZHRoPVwiMTJcIiBoZWlnaHQ9XCIxMlwiIHZpZXdCb3g9XCIwIDAgMTIgMTJcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj5cbiAgICAgICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNMi4xNzg1MSAwLjgyMTc3N0wwLjgyMjQ3MiAyLjE3NzdMNC42NDQyOSA1Ljk5OTg0TDAuODIyMjY2IDkuODIxODdMMi4xNzgyNSAxMS4xNzc5TDYuMDAwMjIgNy4zNTU4OEw5LjgyMTk1IDExLjE3NzlMMTEuMTc4IDkuODIyMDFMNy4zNTYyIDUuOTk5OUwxMS4xNzgxIDIuMTc4TDkuODIyMTIgMC44MjIwMTRMNi4wMDAyNyA0LjY0Mzg2TDIuMTc4NTEgMC44MjE3NzdaXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiLz5cbiAgICAgICAgPC9zdmc+XG4gICAgICAgINCh0LHRgNC+0YHQuNGC0YxcbiAgICAgIDwvYnV0dG9uPlxuICAgICAgXG4gICAgICA8YnV0dG9uXG4gICAgICAgIGNsYXNzPVwiY2F0YWxvZy1tZW51LW1vYl9fYnRuLWZvb3RlciBidG4gYnRuLXJlZFwiXG4gICAgICAgIHYtaWY9XCJpc1BhcmVudFwiXG4gICAgICAgIDpkaXNhYmxlZD1cIiFjYW5SZXNldFwiXG4gICAgICAgIEBjbGljay5wcmV2ZW50PVwiY2xvc2VcIlxuICAgICAgPtCf0YDQuNC80LXQvdC40YLRjDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gIGltcG9ydCB7IGRpc2FibGVCb2R5U2Nyb2xsLCBlbmFibGVCb2R5U2Nyb2xsIH0gZnJvbSAnYm9keS1zY3JvbGwtbG9jayc7XG4gIGltcG9ydCB7IG1hcEdldHRlcnMsIG1hcFN0YXRlLCBtYXBBY3Rpb25zIH0gZnJvbSAndnVleCc7XG4gIGltcG9ydCBNdWx0aWZpbHRlckNoZWNrYm94TGlzdCBmcm9tICcuL2NhdGFsb2cvTXVsdGlmaWx0ZXJDaGVja2JveExpc3QudnVlJztcbiAgaW1wb3J0IE11bHRpZmlsdGVyUmFkaW8gZnJvbSAnLi9jYXRhbG9nL011bHRpZmlsdGVyUmFkaW8udnVlJztcbiAgaW1wb3J0IE11bHRpZmlsdGVyUHJpY2UgZnJvbSAnLi9jYXRhbG9nL011bHRpZmlsdGVyUHJpY2UudnVlJztcblxuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiBcIkNhdGFsb2dGaWx0ZXJNb2JpbGVcIixcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBNdWx0aWZpbHRlckNoZWNrYm94TGlzdCxcbiAgICAgIE11bHRpZmlsdGVyUmFkaW8sXG4gICAgICBNdWx0aWZpbHRlclByaWNlXG4gICAgfSxcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIC4uLm1hcFN0YXRlKCdmaWx0ZXJzL21vYmlsZScsIHtcbiAgICAgICAgaXNQYXJlbnQ6IHN0YXRlID0+IHN0YXRlLmlzUGFyZW50LFxuICAgICAgICBwYXJlbnROYW1lOiBzdGF0ZSA9PiBzdGF0ZS5wYXJlbnROYW1lLFxuICAgICAgICB0aXRsZTogc3RhdGUgPT4gc3RhdGUudGl0bGUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBzdGF0ZSA9PiBzdGF0ZS5jb250ZW50VHlwZSxcbiAgICAgICAgdHlwZTogc3RhdGUgPT4gc3RhdGUuZGVmYXVsdENvbnRhaW5lcixcbiAgICAgIH0pLFxuXG4gICAgICAuLi5tYXBHZXR0ZXJzKCdmaWx0ZXJzL21vYmlsZScsIHtcbiAgICAgICAgY29udGVudDogJ3Zpc2libGVDb250ZW50JyxcbiAgICAgICAgYm90dG9tQ29udGVudDogJ3Zpc2libGVCb3R0b21Db250ZW50JyxcbiAgICAgICAgLy8gY2FuUmVzZXQ6ICdjYW5SZXNldCcsXG4gICAgICB9KSxcblxuXG4gICAgICAvKipcbiAgICAgICAqINCf0L7QutCw0LfRi9Cy0LDRgtGMINC70Lgg0LrQvdC+0L/QutGDIFwi0KHQsdGA0L7RgdC40YLRjFwiXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgY2FuUmVzZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy5jb250ZW50LmZpbmQoaXRlbSA9PiBpdGVtLmNoaWxkVHlwZSA9PT0gJ2NoZWNrYm94JyAmJiBpdGVtLmFjdGl2ZUNoaWxkcmVuLmxlbmd0aCA+IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudFR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICByZXR1cm4gISF0aGlzLmNvbnRlbnQuZmluZChpdGVtID0+IGl0ZW0uY2hlY2tlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIG9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLmhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZygnbW9iaWxlIGNoYW5nZScpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICog0JrQvdC+0L/QutCwINGB0LHRgNC+0YHQsCDQsiDRgdC/0LjRgdC60LUg0YTQuNC70YzRgtGA0L7QslxuICAgICAgICogQHBhcmFtIG5hbWVcbiAgICAgICAqIEBwYXJhbSB0eXBlXG4gICAgICAgKi9cbiAgICAgIG9uUmVzZXRSb3cobmFtZSwgdHlwZSkge1xuICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9maWx0ZXJSZXNldCcsIHsgY29udGFpbmVyOiB0aGlzLnR5cGUsIG5hbWUsIHR5cGUgfSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqINCa0L3QvtC/0LrQsCDRgdCx0YDQvtGB0LAg0LIg0L3QuNC20L3QtdC5INGH0LDRgdGC0LhcbiAgICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAgICovXG4gICAgICBvblJlc2V0Rm9vdGVyKG5hbWUsIHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9yZXNldEFsbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL2ZpbHRlclJlc2V0JywgeyBjb250YWluZXI6IHRoaXMudHlwZSwgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ2hhbmdlKCk7XG4gICAgICB9LFxuICAgICAgb3Blbih7IG5hbWUsIHRpdGxlIH0pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmgtbmF2YmFyLWZpeGVkJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuXG4gICAgICAgIGlmIChvZmZzZXRUb3AgPiAwKSB7XG4gICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIG9mZnNldFRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCk7XG4gICAgICAgICAgLy8gJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe1xuICAgICAgICAgIC8vICAgc2Nyb2xsVG9wOiBvZmZzZXRUb3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgICAgICAgLy8gfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXNhYmxlQm9keVNjcm9sbCh0aGlzLiRlbCk7XG5cbiAgICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCdmaWx0ZXJzL21vYmlsZS9TRVRfREVGQVVMVF9DT05UQUlORVInLCBuYW1lKTtcbiAgICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCdmaWx0ZXJzL21vYmlsZS9TRVRfREVGQVVMVF9USVRMRScsIHRpdGxlKTtcbiAgICAgICAgdGhpcy4kc3RvcmUuY29tbWl0KCdmaWx0ZXJzL21vYmlsZS9TRVRfQ09OVEVOVF9UWVBFJywgbnVsbCk7XG4gICAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnZmlsdGVycy9tb2JpbGUvU0VUX1BBUkVOVF9OQU1FJywgbnVsbCk7XG4gICAgICAgIHRoaXMuJHN0b3JlLmNvbW1pdCgnZmlsdGVycy9tb2JpbGUvU0VUX0lTX1BBUkVOVCcsIHRydWUpO1xuICAgICAgICB0aGlzLiRzdG9yZS5jb21taXQoJ2ZpbHRlcnMvbW9iaWxlL1NFVF9USVRMRScsIHRpdGxlKTtcblxuICAgICAgICAvLyB0aGlzLiRzdG9yZS5jb21taXQoJ2ZpbHRlcnMvbW9iaWxlL1NFVF9JU19BQ1RJVkUnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICB9LFxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIGVuYWJsZUJvZHlTY3JvbGwodGhpcy4kZWwpO1xuXG4gICAgICAgIC8vIHRoaXMuJHN0b3JlLmNvbW1pdCgnZmlsdGVycy9tb2JpbGUvU0VUX0lTX0FDVElWRScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0NoYW5nZXMpIHtcbiAgICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9vbkNoYW5nZScpO1xuICAgICAgICAgIHRoaXMuaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmFjaygpIHtcbiAgICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvbW9iaWxlL3Nob3dQYXJlbnRzJyk7XG4gICAgICB9LFxuICAgICAgbmV4dChpdGVtKSB7XG4gICAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL21vYmlsZS9zaG93Q2hpbGRyZW5zJywgaXRlbSk7XG4gICAgICB9LFxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG5cbjwhLS08c3R5bGUgc2NvcGVkPi0tPlxuXG48IS0tPC9zdHlsZT4tLT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ2F0YWxvZ0ZpbHRlck1vYmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ2F0YWxvZ0ZpbHRlck1vYmlsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0NhdGFsb2dGaWx0ZXJNb2JpbGUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTQ2NmU1MzYwJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0NhdGFsb2dGaWx0ZXJNb2JpbGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9DYXRhbG9nRmlsdGVyTW9iaWxlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiZmlsdGVyXCJ9LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmaWx0ZXJfX2xpc3RcIn0sW192bS5fbCgoX3ZtLmZpbHRlcnMpLGZ1bmN0aW9uKGZpbHRlcil7cmV0dXJuIFsoZmlsdGVyLnR5cGUgPT09ICdjaGVja2JveCcpP19jKCdGaWx0ZXJDaGVja2JveCcse2F0dHJzOntcImZpbHRlclwiOmZpbHRlcn19KTooZmlsdGVyLnR5cGUgPT09ICdyYWRpbycpP19jKCdGaWx0ZXJTZWxlY3QnLHthdHRyczp7XCJmaWx0ZXJcIjpmaWx0ZXJ9fSk6KGZpbHRlci50eXBlID09PSAncmFuZ2UnKT9fYygnRmlsdGVyUHJpY2UnLHthdHRyczp7XCJmaWx0ZXJcIjpmaWx0ZXJ9fSk6X3ZtLl9lKCldfSldLDIpLF92bS5fdihcIiBcIiksX2MoJ2J1dHRvbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLmNhblJlc2V0KSxleHByZXNzaW9uOlwiY2FuUmVzZXRcIn1dLHN0YXRpY0NsYXNzOlwiZmlsdGVyX19idG4tcmVzZXRcIixhdHRyczp7XCJ0eXBlXCI6XCJyZXNldFwifSxvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS5vblJlc2V0KCRldmVudCl9fX0sW192bS5fdihcItCh0LHRgNC+0YHQuNGC0YxcIildKV0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJmaWx0ZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwiZmlsdGVyX19saXN0XCI+XG4gICAgICA8dGVtcGxhdGUgdi1mb3I9XCJmaWx0ZXIgaW4gZmlsdGVyc1wiPlxuICAgICAgICA8RmlsdGVyQ2hlY2tib3hcbiAgICAgICAgICB2LWlmPVwiZmlsdGVyLnR5cGUgPT09ICdjaGVja2JveCdcIlxuICAgICAgICAgIDpmaWx0ZXI9XCJmaWx0ZXJcIi8+XG4gICAgICAgIDxGaWx0ZXJTZWxlY3RcbiAgICAgICAgICB2LWVsc2UtaWY9XCJmaWx0ZXIudHlwZSA9PT0gJ3JhZGlvJ1wiXG4gICAgICAgICAgOmZpbHRlcj1cImZpbHRlclwiLz5cbiAgICAgICAgPEZpbHRlclByaWNlXG4gICAgICAgICAgdi1lbHNlLWlmPVwiZmlsdGVyLnR5cGUgPT09ICdyYW5nZSdcIlxuICAgICAgICAgIDpmaWx0ZXI9XCJmaWx0ZXJcIi8+XG4gICAgICA8L3RlbXBsYXRlPlxuICAgIDwvZGl2PlxuICAgIDxidXR0b25cbiAgICAgIGNsYXNzPVwiZmlsdGVyX19idG4tcmVzZXRcIlxuICAgICAgdi1zaG93PVwiY2FuUmVzZXRcIlxuICAgICAgdHlwZT1cInJlc2V0XCJcbiAgICAgIEBjbGljay5wcmV2ZW50PVwib25SZXNldFwiPtCh0LHRgNC+0YHQuNGC0Yw8L2J1dHRvbj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAvLyBpbXBvcnQgRHJvcGRvd24gZnJvbSAnLi9Ecm9wZG93bi52dWUnO1xuICAvLyBpbXBvcnQgTXVsdGlmaWx0ZXJQcmljZSBmcm9tICcuL2NhdGFsb2cvTXVsdGlmaWx0ZXJQcmljZS52dWUnO1xuICAvLyBpbXBvcnQgTXVsdGlmaWx0ZXJDaGVja2JveExpc3QgZnJvbSAnLi9jYXRhbG9nL011bHRpZmlsdGVyQ2hlY2tib3hMaXN0LnZ1ZSc7XG5cblxuICBpbXBvcnQgRmlsdGVyQ2hlY2tib3ggZnJvbSAnLi9jYXRhbG9nL0ZpbHRlckNoZWNrYm94LnZ1ZSc7XG4gIGltcG9ydCBGaWx0ZXJTZWxlY3QgZnJvbSAnLi9jYXRhbG9nL0ZpbHRlclNlbGVjdC52dWUnO1xuICBpbXBvcnQgRmlsdGVyUHJpY2UgZnJvbSAnLi9jYXRhbG9nL0ZpbHRlclByaWNlLnZ1ZSc7XG5cbiAgaW1wb3J0IHsgbWFwR2V0dGVycywgbWFwU3RhdGUsIG1hcEFjdGlvbnMgfSBmcm9tICd2dWV4JztcblxuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBuYW1lOiBcIkNhdGFsb2dGaWx0ZXJcIixcbiAgICBjb21wb25lbnRzOiB7XG4gICAgICBGaWx0ZXJDaGVja2JveCxcbiAgICAgIEZpbHRlclNlbGVjdCxcbiAgICAgIEZpbHRlclByaWNlLFxuICAgIH0sXG4gICAgLy8gbW91bnRlZCgpIHtcbiAgICAvLyAgIHRoaXMuJHJvb3QuJG9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgLy8gICAgIHRoaXMub25DaGFuZ2UoKTtcbiAgICAvLyAgIH0pO1xuICAgIC8vIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIC4uLm1hcFN0YXRlKCdmaWx0ZXJzJywge1xuICAgICAgICBmaWx0ZXJzOiBzdGF0ZSA9PiBzdGF0ZS5maWx0ZXJzLFxuICAgICAgfSksXG5cbiAgICAgIC8qKlxuICAgICAgICog0J/QvtC60LDQt9GL0LLQsNGC0Ywg0LvQuCDQutC90L7Qv9C60YMgXCLQodCx0YDQvtGB0LjRgtGMXCJcbiAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICovXG4gICAgICBjYW5SZXNldCgpIHtcbiAgICAgICAgcmV0dXJuICEhT2JqZWN0LnZhbHVlcyh0aGlzLmZpbHRlcnMpLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5maW5kKGMgPT4gYy5jaGVja2VkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udHlwZSA9PT0gJ3JhbmdlJykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YS5taW5SYW5nZSB8fCBpdGVtLmRhdGEubWF4UmFuZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICBvblJlc2V0KCkge1xuICAgICAgICB0aGlzLiRyb290LiRlbWl0KCdmaWx0ZXI6cmVzZXQnKTtcbiAgICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goJ2ZpbHRlcnMvb25DaGFuZ2UnKTtcbiAgICAgICAgLy8gdGhpcy5vbkNoYW5nZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIG9uQ2hhbmdlKCkge1xuICAgICAgLy8gICB0aGlzLiRyb290LiRlbWl0KCdmaWx0ZXI6Y2hhbmdlJyk7XG4gICAgICAvLyB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblxuPC9zdHlsZT5cbiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ2F0YWxvZ0ZpbHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMy0wIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ2F0YWxvZ0ZpbHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0NhdGFsb2dGaWx0ZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTkwMWI4NzcwJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0NhdGFsb2dGaWx0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9DYXRhbG9nRmlsdGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiOTAxYjg3NzBcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSAnbG9kYXNoLmRlYm91bmNlJztcbi8vIGltcG9ydCB0aHJvdHRsZSBmcm9tICdsb2Rhc2gudGhyb3R0bGUnO1xuXG5cbmltcG9ydCBVdGlscyBmcm9tICdAL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IGdldEZpbHRyZWRDYXRhbG9nIH0gZnJvbSAnQC9hcGknO1xuXG5pbXBvcnQgJ0AvY29tcG9uZW50cy9Qcm9kdWN0Q2FyZCc7XG5cbmltcG9ydCB7XG4gIE11bHRpZmlsdGVyLFxuICBQcmljZUZpbHRlcixcbiAgQ2hlY2tib3hGaWx0ZXIsXG4gIFJhZGlvRmlsdGVyLFxuICBTZWxlY3RGaWx0ZXIsXG59IGZyb20gJ0AvY29tcG9uZW50cy9NdWx0aWZpbHRlcic7XG5cbmltcG9ydCBzdG9yZSBmcm9tICdAL3N0b3JlJztcbmltcG9ydCBjYXRhbG9nQ29udHJvbCBmcm9tICdAL3N0b3JlL21vZHVsZXMvY2F0YWxvZ0NvbnRyb2wnO1xuaW1wb3J0IENhdGVnb3J5TGlzdE1vYmlsZSBmcm9tICdAL2NvbXBvbmVudHMvQ2F0ZWdvcnlMaXN0TW9iaWxlLnZ1ZSc7XG5pbXBvcnQgQ2F0YWxvZ0ZpbHRlck1vYmlsZSBmcm9tICdAL2NvbXBvbmVudHMvQ2F0YWxvZ0ZpbHRlck1vYmlsZS52dWUnO1xuaW1wb3J0IENhdGFsb2dGaWx0ZXIgZnJvbSAnQC9jb21wb25lbnRzL0NhdGFsb2dGaWx0ZXIudnVlJztcblxuaW1wb3J0IFByb2R1Y3RDYXJ0IGZyb20gJ0AvY29tcG9uZW50cy9Qcm9kdWN0Q2FyZC52dWUnO1xuXG5cbmNvbnN0IFByb2R1Y3RDYXJ0VnVlID0gVnVlLmV4dGVuZChQcm9kdWN0Q2FydCk7XG5cbi8qKlxuICog0KHQstC+0YDQsNGH0LjQstCw0L3QuNC1INGB0YLRgNC+0LpcbiAqL1xuZnVuY3Rpb24gaW5pdENvbGxhcHNlKCkge1xuICBsZXQgbWF4TGluZUNvdW50ID0gNTtcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCA+PSA3NjgpIHtcbiAgICBtYXhMaW5lQ291bnQgPSA4O1xuICB9XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggPj0gMTI0MCkge1xuICAgIG1heExpbmVDb3VudCA9IDEwO1xuICB9XG5cbiAgW10uZm9yRWFjaC5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5wLWNvbGxhcHNlJyksIChpdGVtKSA9PiB7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoaXRlbSkubGluZUhlaWdodCwgMTApO1xuXG4gICAgaWYgKGl0ZW0uY2xpZW50SGVpZ2h0ID4gbGluZUhlaWdodCAqIG1heExpbmVDb3VudCkge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgncC1jb2xsYXBzZV9fdGV4dCcpO1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGl0ZW0uaW5uZXJIVE1MLnRyaW0oKTtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHtsaW5lSGVpZ2h0ICogbWF4TGluZUNvdW50fXB4YDtcblxuICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgncC1jb2xsYXBzZV9fYnV0dG9uJyk7XG5cbiAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAn0KfQuNGC0LDRgtGMINC00LDQu9C10LUnO1xuICAgICAgYnV0dG9uLmlubmVySFRNTCArPSAnPHN2ZyB3aWR0aD1cIjEwXCIgaGVpZ2h0PVwiMTRcIiB2aWV3Qm94PVwiMCAwIDEwIDE0XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XFxuJ1xuICAgICAgICArICc8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNC45OTI3NCA2LjYzOTUxTDEuNjc2MjYgMS44NTQ0NEw0LjE0MTk0IDAuMTQ1NTA4TDkuMDA3MjggNy4xNjUzMUwxLjk3MTIxIDEzLjE0MzFMMC4wMjg4MDg2IDEwLjg1NjhMNC45OTI3NCA2LjYzOTUxWlwiIGZpbGw9XCIjRjQ0MTJEXCIvPlxcbidcbiAgICAgICAgKyAnPC9zdmc+XFxuJztcblxuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgfSk7XG5cbiAgICAgIGl0ZW0uaW5uZXJIVE1MID0gJyc7XG4gICAgICBpdGVtLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICBpdGVtLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgfVxuICB9KTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXRhbG9nQ29udHJvbCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGVsZW1lbnRzID0ge1xuICAgICAgZm9ybTogbnVsbCxcbiAgICAgIGZpbHRlcjogbnVsbCxcbiAgICAgIHNvcnRpbmc6IG51bGwsXG4gICAgICBxdWFudGl0eTogbnVsbCxcbiAgICAgIGNvbnRhaW5lcjogbnVsbCxcbiAgICB9LFxuICAgIG9wdGlvbnMgPSB7fSxcbiAgKSB7XG4gICAgc3RvcmUucmVnaXN0ZXJNb2R1bGUoJ2ZpbHRlcnMnLCBjYXRhbG9nQ29udHJvbCk7XG5cblxuICAgIHRoaXMuZmlsdGVyRWwgPSBlbGVtZW50cy5maWx0ZXIgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmZpbHRlcicpO1xuICAgIHRoaXMuZmlsdGVyTGlzdCA9IHt9O1xuXG4gICAgdGhpcy5zb3J0aW5nRWwgPSBlbGVtZW50cy5zb3J0aW5nIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zb3J0aW5nJyk7XG4gICAgdGhpcy5zb3J0aW5nTGlzdCA9IFtdO1xuXG4gICAgdGhpcy5mb3JtRWwgPSBlbGVtZW50cy5mb3JtIHx8IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXRhbG9nLWZpbHRlcicpO1xuICAgIHRoaXMucXVhbnRpdHlFbCA9IGVsZW1lbnRzLnF1YW50aXR5IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXRvdGFsLWZpbmRdJyk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckVsID0gZWxlbWVudHMuY29udGFpbmVyIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYXJkLWxpc3QnKTtcbiAgICAvLyB0aGlzLkNvbnRhaW5lciA9IG51bGw7XG5cbiAgICB0aGlzLmJyZWFkY3VtcHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubXItYnJlYWRjdW1wcycpO1xuICAgIHRoaXMudGl0bGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGFnZS1oZWFkZXJfX3RpdGxlJyk7XG5cblxuICAgIHRoaXMuc2hvd01vcmVFbCA9IG51bGw7XG4gICAgdGhpcy5zaG93TW9yZUJ1dHRvbkVsID0gbnVsbDtcbiAgICB0aGlzLnNob3dNb3JlVGV4dEVsID0gbnVsbDtcblxuICAgIHRoaXMuY3VycmVudFBhZ2UgPSAxO1xuICAgIHRoaXMuc2hvd25DYXJkcyA9IDA7XG4gICAgdGhpcy50b3RhbENhcmRzID0gMDtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLkNhdGFsb2dDb250cm9sLmRlZmF1bHRPcHRpb25zLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuXG4gICAgLy8gdGhpcy5vcHRpb25zLm1ldGhvZCA9IHRoaXMuZm9ybUVsLm1ldGhvZDtcbiAgICAvLyB0aGlzLm9wdGlvbnMuYWN0aW9uID0gdGhpcy5mb3JtRWwuYWN0aW9uO1xuXG4gICAgdGhpcy5jbGFzc05hbWVzID0ge1xuICAgICAgLi4uQ2F0YWxvZ0NvbnRyb2wuZGVmYXVsdE9wdGlvbnMuY2xhc3NOYW1lcyxcbiAgICAgIC4uLnRoaXMub3B0aW9ucy5jbGFzc05hbWVzLFxuICAgIH07XG5cblxuICAgIHRoaXMuZGVib3VuY2VkVXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUsIDUwMCk7XG5cbiAgICBpbml0Q29sbGFwc2UoKTtcblxuICAgIHRoaXMuYXJyb3cgPSBbXTtcblxuICAgIHRoaXMuaW5pdCgpO1xuICAgIHRoaXMuaW5pdFZ1ZSgpO1xuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGFqYXg6IHRydWUsXG4gICAgbWV0aG9kOiAncG9zdCcsXG4gICAgYWN0aW9uOiAnL2xvY2FsL3B1YmxpYy9jYXRhbG9nLnBocCcsXG5cbiAgICBjbGFzc05hbWVzOiB7XG4gICAgICBzaG93TW9yZTogJ2xvYWQtbW9yZS1ibG9jaycsXG4gICAgICBzaG93TW9yZUxvYWRpbmc6ICdsb2FkaW5nJyxcbiAgICAgIHNob3dNb3JlTGluazogJ2xvYWQtbW9yZS1ibG9ja19fbGluaycsXG4gICAgICBzaG93TW9yZVZhbHVlOiAnbG9hZC1tb3JlLWJsb2NrX192YWx1ZScsXG5cbiAgICAgIGNhcmRMaXN0OiAnY2FyZC1saXN0JyxcbiAgICAgIGNhcmRMaXN0TG9hZGluZzogJ2NhcmQtbGlzdF9sb2FkaW5nJyxcbiAgICB9LFxuICB9O1xuXG4gIGluaXRWdWUoKSB7XG4gICAgc3RvcmUuc3Vic2NyaWJlQWN0aW9uKChhY3Rpb24sIHN0YXRlKSA9PiB7XG4gICAgICBpZiAoYWN0aW9uLnR5cGUgPT09ICdmaWx0ZXJzL29uQ2hhbmdlJykge1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvLyDQpNC40LvRjNGC0YAg0L3QsCDQtNC10YHQutGC0L7Qv9C1XG4gICAgdGhpcy5maWx0ZXJWTSA9IG5ldyBWdWUoe1xuICAgICAgc3RvcmUsXG4gICAgICByZW5kZXI6IGggPT4gaChDYXRhbG9nRmlsdGVyKSxcbiAgICB9KS4kbW91bnQodGhpcy5maWx0ZXJFbCk7XG5cblxuICAgIC8vINCj0L/RgNCw0LLQu9C10L3QuNC1INC60LDRgtCw0LvQvtCz0L7QvCDQtNC70Y8g0LzQvtCx0LjQu9C+0LpcbiAgICB0aGlzLmNhdGFsb2dDb250cm9sTW9iaWxlVk0gPSBuZXcgVnVlKHtcbiAgICAgIHN0b3JlLFxuICAgICAgcmVuZGVyOiBoID0+IGgoQ2F0YWxvZ0ZpbHRlck1vYmlsZSksXG4gICAgfSkuJG1vdW50KCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhdGFsb2dDb250cm9sTW9iaWxlVk0uJGVsKTtcblxuICAgIFtdLmZvckVhY2guY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10b2dnbGU9XCJtLWZpbHRlclwiXScpLCAoYnV0dG9uKSA9PiB7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldC5kYXRhc2V0LnRhcmdldCA9PT0gJyNtb2JpbGUtZmlsdGVyJykge1xuICAgICAgICAgIHRoaXMuY2F0YWxvZ0NvbnRyb2xNb2JpbGVWTS4kY2hpbGRyZW5bMF0ub3Blbih7IG5hbWU6ICdmaWx0ZXJzJywgdGl0bGU6ICfQpNC40LvRjNGC0YAnIH0pO1xuICAgICAgICAgIC8vIHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL21vYmlsZS9zaG93TWVudScsIHsgbmFtZTogJ2ZpbHRlcnMnLCB0aXRsZTogJ9Ck0LjQu9GM0YLRgCcgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYXRhbG9nQ29udHJvbE1vYmlsZVZNLiRjaGlsZHJlblswXS5vcGVuKHsgbmFtZTogJ3NvcnQnLCB0aXRsZTogJ9Ch0L7RgNGC0LjRgNC+0LLQutCwJyB9KTtcbiAgICAgICAgICAvLyBzdG9yZS5kaXNwYXRjaCgnZmlsdGVycy9tb2JpbGUvc2hvd01lbnUnLCB7IG5hbWU6ICdzb3J0JywgdGl0bGU6ICfQodC+0YDRgtC40YDQvtCy0LrQsCcgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG5cbiAgICAvLyDQodC/0LjRgdC+0Log0LrQsNGC0LXQs9C+0YDQuNC5INC00LvRjyDQvNC+0LHQuNC70L7QulxuICAgIHRoaXMuY2F0ZWdvcnlMaXN0TW9iaWxlVk0gPSBuZXcgVnVlKHtcbiAgICAgIHN0b3JlLFxuICAgICAgcmVuZGVyOiBoID0+IGgoQ2F0ZWdvcnlMaXN0TW9iaWxlKSxcbiAgICB9KS4kbW91bnQoKTtcblxuICAgIGNvbnN0IGNhdGFsb2dDb250cm9sRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2F0YWxvZy1jb250cm9sJyk7XG4gICAgaWYgKGNhdGFsb2dDb250cm9sRWwpIHtcbiAgICAgIGNhdGFsb2dDb250cm9sRWwuaW5zZXJ0QmVmb3JlKHRoaXMuY2F0ZWdvcnlMaXN0TW9iaWxlVk0uJGVsLCBjYXRhbG9nQ29udHJvbEVsLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5zaG93bkNhcmRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtcHJvZHVjdC1pZF0nKS5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5mb3JtRWwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5tZXRob2QgPSB0aGlzLmZvcm1FbC5tZXRob2Q7XG4gICAgICB0aGlzLm9wdGlvbnMuYWN0aW9uID0gdGhpcy5mb3JtRWwuYWN0aW9uO1xuXG4gICAgICAvLyB0aGlzLmZvcm1FbC5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCB0aGlzLnVwZGF0ZSk7XG4gICAgICB0aGlzLmZvcm1FbC5hZGRFdmVudExpc3RlbmVyKCdyZXNldCcsIHRoaXMub25SZXNldCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc29ydGluZ0VsKSB7XG4gICAgICB0aGlzLnNvcnRpbmdMaXN0ID0gW10ubWFwLmNhbGwodGhpcy5zb3J0aW5nRWwucXVlcnlTZWxlY3RvckFsbCgnZmllbGRzZXQubXVsdGlmaWx0ZXInKSwgKGZpbHRlcikgPT4ge1xuICAgICAgICBpZiAoZmlsdGVyLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlci1jaGVja2JveCcpKSByZXR1cm4gbmV3IENoZWNrYm94RmlsdGVyKGZpbHRlciwgJ3NvcnQnKTtcbiAgICAgICAgLy8gaWYgKGZpbHRlci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcmFkaW8nKSkgcmV0dXJuIG5ldyBSYWRpb0ZpbHRlcihmaWx0ZXIsIHRoaXMuY2hhbmdlKTtcbiAgICAgICAgaWYgKGZpbHRlci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcmFkaW8nKSkgcmV0dXJuIG5ldyBTZWxlY3RGaWx0ZXIoZmlsdGVyLCAnc29ydCcpO1xuICAgICAgICByZXR1cm4gbmV3IE11bHRpZmlsdGVyKGZpbHRlciwgdGhpcy5jaGFuZ2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaWYgKHRoaXMuZmlsdGVyRWwpIHtcbiAgICAvLyAgIHRoaXMuZmlsdGVyTGlzdCA9IFtdLm1hcC5jYWxsKHRoaXMuZmlsdGVyRWwucXVlcnlTZWxlY3RvckFsbCgnZmllbGRzZXQubXVsdGlmaWx0ZXInKSwgKGZpbHRlcikgPT4ge1xuICAgIC8vICAgICBpZiAoZmlsdGVyLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlci1jaGVja2JveCcpKSByZXR1cm4gbmV3IENoZWNrYm94RmlsdGVyKGZpbHRlciwgJ2ZpbHRlcnMnKTtcbiAgICAvLyAgICAgLy8gaWYgKGZpbHRlci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcmFkaW8nKSkgcmV0dXJuIG5ldyBSYWRpb0ZpbHRlcihmaWx0ZXIsIHRoaXMuY2hhbmdlKTtcbiAgICAvLyAgICAgaWYgKGZpbHRlci5xdWVyeVNlbGVjdG9yKCcubXVsdGlmaWx0ZXItcmFkaW8nKSkgcmV0dXJuIG5ldyBTZWxlY3RGaWx0ZXIoZmlsdGVyLCAnZmlsdGVycycpO1xuICAgIC8vICAgICBpZiAoZmlsdGVyLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlci1wcmljZScpKSByZXR1cm4gbmV3IFByaWNlRmlsdGVyKGZpbHRlciwgJ2ZpbHRlcnMnKTtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBNdWx0aWZpbHRlcihmaWx0ZXIsIHRoaXMuY2hhbmdlKTtcbiAgICAvLyAgIH0pO1xuICAgIC8vIH1cblxuICAgIGlmICh0aGlzLmZpbHRlckVsKSB7XG4gICAgICBbXS5mb3JFYWNoLmNhbGwodGhpcy5maWx0ZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCdmaWVsZHNldC5tdWx0aWZpbHRlcicpLCAoZmlsdGVyKSA9PiB7XG4gICAgICAgIGlmIChmaWx0ZXIucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLWNoZWNrYm94JykpIHtcbiAgICAgICAgICBzdG9yZS5jb21taXQoJ2ZpbHRlcnMvcHVzaEZpbHRlclRvQ29udGFpbmVyJywge1xuICAgICAgICAgICAgY29udGFpbmVyOiAnZmlsdGVycycsXG4gICAgICAgICAgICBmaWx0ZXI6IENoZWNrYm94RmlsdGVyLnBhcnNlU2V0dGluZ3MoZmlsdGVyKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyLnF1ZXJ5U2VsZWN0b3IoJy5tdWx0aWZpbHRlci1yYWRpbycpKSB7XG4gICAgICAgICAgc3RvcmUuY29tbWl0KCdmaWx0ZXJzL3B1c2hGaWx0ZXJUb0NvbnRhaW5lcicsIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogJ2ZpbHRlcnMnLFxuICAgICAgICAgICAgZmlsdGVyOiBTZWxlY3RGaWx0ZXIucGFyc2VTZXR0aW5ncyhmaWx0ZXIpLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIucXVlcnlTZWxlY3RvcignLm11bHRpZmlsdGVyLXByaWNlJykpIHtcbiAgICAgICAgICBzdG9yZS5jb21taXQoJ2ZpbHRlcnMvcHVzaEZpbHRlclRvQ29udGFpbmVyJywge1xuICAgICAgICAgICAgY29udGFpbmVyOiAnZmlsdGVycycsXG4gICAgICAgICAgICBmaWx0ZXI6IFByaWNlRmlsdGVyLnBhcnNlU2V0dGluZ3MoZmlsdGVyKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZXcgTXVsdGlmaWx0ZXIoZmlsdGVyLCB0aGlzLmNoYW5nZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNob3dNb3JlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLmNsYXNzTmFtZXMuc2hvd01vcmV9YCk7XG4gICAgaWYgKHRoaXMuc2hvd01vcmVFbCkge1xuICAgICAgdGhpcy5zaG93TW9yZUJ1dHRvbkVsID0gdGhpcy5zaG93TW9yZUVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuY2xhc3NOYW1lcy5zaG93TW9yZUxpbmt9YCk7XG4gICAgICB0aGlzLnNob3dNb3JlVGV4dEVsID0gdGhpcy5zaG93TW9yZUVsLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuY2xhc3NOYW1lcy5zaG93TW9yZVZhbHVlfWApO1xuXG4gICAgICB0aGlzLnNob3dNb3JlQnV0dG9uRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5uZXh0UGFnZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgbmV4dFBhZ2UoKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGhpcy5mb3JtRWwpO1xuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLmN1cnJlbnRQYWdlICsgMTtcblxuICAgIGZvcm1EYXRhLmFwcGVuZCgncGFnZScsIHBhZ2UudG9TdHJpbmcoKSk7XG5cbiAgICB0aGlzLnNob3dNb3JlRWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuc2hvd01vcmVMb2FkaW5nKTtcblxuICAgIGdldEZpbHRyZWRDYXRhbG9nKHRoaXMub3B0aW9ucy5hY3Rpb24sIGZvcm1EYXRhKVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGFnZSA9IHBhZ2U7XG4gICAgICAgIHRoaXMuYWRkKGRhdGEpO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgYWxlcnQoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfSlcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgdGhpcy5zaG93TW9yZUVsLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jbGFzc05hbWVzLnNob3dNb3JlTG9hZGluZyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZVF1YW50aXR5KCkge1xuICAgIGlmICh0aGlzLnF1YW50aXR5RWwpIHtcbiAgICAgIHRoaXMucXVhbnRpdHlFbC50ZXh0Q29udGVudCA9IGAke3RoaXMudG90YWxDYXJkc30gJHtVdGlscy5kZWNsT2ZOdW0odGhpcy50b3RhbENhcmRzLCBbXG4gICAgICAgICfRgtC+0LLQsNGAJyxcbiAgICAgICAgJ9GC0L7QstCw0YDQsCcsXG4gICAgICAgICfRgtC+0LLQsNGA0L7QsicsXG4gICAgICBdKX1gO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3dNb3JlRWwpIHtcbiAgICAgIHRoaXMuc2hvd01vcmVFbC5zdHlsZS5kaXNwbGF5ID0gdGhpcy5zaG93bkNhcmRzIDwgdGhpcy50b3RhbENhcmRzID8gJycgOiAnbm9uZSc7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hvd01vcmVUZXh0RWwpIHtcbiAgICAgIHRoaXMuc2hvd01vcmVUZXh0RWwudGV4dENvbnRlbnQgPSBg0J/QvtC60LDQt9Cw0L3QviAke3RoaXMuc2hvd25DYXJkc30g0LjQtyAke3RoaXMudG90YWxDYXJkc31gO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiDQntCx0L3QvtCy0LjRgtGMINGF0LvQtdCx0L3Ri9C1INC60YDQvtGI0LrQuFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSAtINCc0LDRgdGB0LjQsiBcItC60YDQvtGI0LXQulwiXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSAtINCX0LDQs9C+0LvQvtCy0L7QuiDRgdGC0YDQsNC90LjRhtGLXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBoMSAtINCX0LDQs9C+0LvQvtCy0L7QuiDRgdGC0YDQsNC90LjRhtGLXG4gICAqL1xuICBzZXRCcmVhZGN1bXBzKGFycmF5LCB0aXRsZSA9ICcnLCBoMSA9ICcnKSB7XG4gICAgbGV0IGh0bWwgPSAnJztcblxuICAgIC8vINCd0L7QstCw0Y8g0LLQtdGA0YHQuNGPXG4gICAgaHRtbCArPSAnPG9sIGNsYXNzPVwibXItYnJlYWRjdW1wc19fbGlzdFwiIGl0ZW1zY29wZSBpdGVtdHlwZT1cImh0dHBzOi8vc2NoZW1hLm9yZy9CcmVhZGNydW1iTGlzdFwiPic7XG4gICAgYXJyYXkuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgaHRtbCArPSAnPGxpIGNsYXNzPVwibXItYnJlYWRjdW1wc19faXRlbVwiIGl0ZW1wcm9wPVwiaXRlbUxpc3RFbGVtZW50XCIgaXRlbXNjb3BlIGl0ZW10eXBlPVwiaHR0cHM6Ly9zY2hlbWEub3JnL0xpc3RJdGVtXCI+JztcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGh0bWwgKz0gYDxhIGl0ZW1wcm9wPVwiaXRlbVwiIGhyZWY9XCIke2l0ZW0udXJsfVwiPjxzcGFuIGl0ZW1wcm9wPVwibmFtZVwiIGNsYXNzPVwicmVkXCI+JHtpdGVtLm5hbWV9PC9zcGFuPjwvYT5gO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBhcnJheS5sZW5ndGggLSAxKSB7XG4gICAgICAgIGh0bWwgKz0gYDxzcGFuIGl0ZW1wcm9wPVwibmFtZVwiIGNsYXNzPVwiZ3JheVwiPiR7aXRlbS5uYW1lfTwvc3Bhbj5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCArPSBgPGEgaXRlbXByb3A9XCJpdGVtXCIgaHJlZj1cIiR7aXRlbS51cmx9XCI+PHNwYW4gaXRlbXByb3A9XCJuYW1lXCI+JHtpdGVtLm5hbWV9PC9zcGFuPjwvYT5gO1xuICAgICAgfVxuICAgICAgaHRtbCArPSBgPG1ldGEgaXRlbXByb3A9XCJwb3NpdGlvblwiIGNvbnRlbnQ9XCIke2kgKyAxfVwiLz48L2xpPmA7XG4gICAgfSk7XG4gICAgaHRtbCArPSAnPC9vbD4nO1xuXG4gICAgdGhpcy5icmVhZGN1bXBzLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICBpZiAodGl0bGUgIT09ICcnKSB7XG4gICAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuICAgIH1cblxuICAgIGlmIChoMSAhPT0gJycgJiYgdGhpcy50aXRsZSkge1xuICAgICAgdGhpcy50aXRsZS50ZXh0Q29udGVudCA9IGgxO1xuICAgIH1cbiAgfVxuXG4gIC8vXG4gIC8vIG9uQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gIC8vICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgLy9cbiAgLy8gICB0aGlzLmNoYW5nZSgpO1xuICAvLyB9O1xuXG4gIG9uUmVzZXQgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL3Jlc2V0QWxsJykudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIC8qKlxuICAvLyAgKiDQntCx0L3QvtCy0LvQtdC90LjQtSDRgdC/0LjRgdC60LAgKNGBINC30LDQtNC10YDQttC60L7QuSlcbiAgLy8gICovXG4gIC8vIG9uVXBkYXRlID0gKCkgPT4ge1xuICAvLyAgIHRoaXMudXBkYXRlKCk7XG4gIC8vIH07XG5cbiAgY2hhbmdlID0gKCkgPT4ge1xuICAgIHRoaXMuY29udGFpbmVyRWwuY2xhc3NMaXN0LmFkZCh0aGlzLmNsYXNzTmFtZXMuY2FyZExpc3RMb2FkaW5nKTtcbiAgICB0aGlzLmRlYm91bmNlZFVwZGF0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiDQnNC+0LzQtdC90YLQsNC70YzQvdC+0LUg0L7QsdC90L7QstC70LXQvdC40LVcbiAgICovXG4gIHVwZGF0ZSA9ICgpID0+IHtcbiAgICBVdGlscy5sb2coJ9Ca0LDRgtCw0LvQvtCzJywgJ9Ce0LHQvdC+0LLQu9C10L3QuNC1INC/0L4g0YTQuNC70YzRgtGA0YMnKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb250YWluZXJFbC5jbGFzc0xpc3QuYWRkKHRoaXMuY2xhc3NOYW1lcy5jYXJkTGlzdExvYWRpbmcpO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hamF4KSB7XG4gICAgICAgIHRoaXMuZm9ybUVsLnN1Ym1pdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWxvYWRQYWdlKDEpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyRWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNsYXNzTmFtZXMuY2FyZExpc3RMb2FkaW5nKTtcbiAgICAgIGFsZXJ0KCfQntGI0LjQsdC60LAnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9O1xuXG4gIGFwcGVuZEl0ZW1zKGl0ZW1zKSB7XG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ3Byb2R1Y3QnKSB7XG4gICAgICAgIHRoaXMuc2hvd25DYXJkcyArPSAxO1xuICAgICAgICAvLyDQn9C+0L3Rj9GC0LjRjyDQvdC1INC40LzQtdGOLCDQvdCwINGB0LrQvtC70YzQutC+INGN0YLQviDQsNC00LXQutCy0LDRgtC90L7QtSDRgNC10YjQtdC90LjQtVxuICAgICAgICBjb25zdCB2bSA9IG5ldyBQcm9kdWN0Q2FydFZ1ZSh7XG4gICAgICAgICAgc3RvcmUsXG4gICAgICAgICAgcHJvcHNEYXRhOiB7XG4gICAgICAgICAgICBwcm9kdWN0OiBpdGVtLm9wdGlvbnMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSkuJG1vdW50KCk7XG4gICAgICAgIHRoaXMuYXJyb3cucHVzaCh2bSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuYXBwZW5kQ2hpbGQodm0uJGVsKTtcbiAgICAgICAgLy8gdGhpcy5jb250YWluZXJFbC5hcHBlbmRDaGlsZChuZXcgUHJvZHVjdENhcmQoaXRlbS5vcHRpb25zKS5nZXRFbGVtZW50KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5hcHBlbmRDaGlsZChVdGlscy5odG1sVG9FbGVtZW50KGl0ZW0uaHRtbCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGVRdWFudGl0eSgpO1xuICB9XG5cbiAgLyoqXG4gICAqINCX0LDQvNC10L3QuNGC0Ywg0LrQsNGA0YLQvtGH0LrQuCDRgtC+0LLQsNGA0L7QslxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgcmVsb2FkKGRhdGEpIHtcbiAgICB0aGlzLmN1cnJlbnRQYWdlID0gMTtcbiAgICB0aGlzLnNob3duQ2FyZHMgPSAwO1xuICAgIHRoaXMudG90YWxDYXJkcyA9IGRhdGEuY291bnQ7XG5cbiAgICB0aGlzLmFycm93LmZvckVhY2goKHZtKSA9PiB7XG4gICAgICB2bS4kZGVzdHJveSgpO1xuICAgICAgdm0gPSBudWxsO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hcnJvdyA9IFtdO1xuICAgIHRoaXMuY29udGFpbmVyRWwuaW5uZXJIVE1MID0gJyc7XG5cbiAgICB0aGlzLmFwcGVuZEl0ZW1zKGRhdGEuaXRlbXMpO1xuXG4gICAgLy8gdGhpcy5zaG93bkNhcmRzID0gdGhpcy5wYXJzZShpdGVtcyk7XG4gICAgLy8gdGhpcy5saXN0RWwuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5saXN0RWwuc2Nyb2xsSGVpZ2h0fXB4YDtcbiAgICAvLyByZXR1cm4gdGhpcy5zaG93bkNhcmRzO1xuICB9XG5cbiAgLyoqXG4gICAqINCU0L7QsdCw0LLQuNGC0Ywg0LrQsNGA0YLQvtGH0LrQuCDRgtC+0LLQsNGA0L7QslxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgYWRkKGRhdGEpIHtcbiAgICB0aGlzLnRvdGFsQ2FyZHMgPSBkYXRhLmNvdW50O1xuICAgIHRoaXMuYXBwZW5kSXRlbXMoZGF0YS5pdGVtcyk7XG4gICAgLy8gdGhpcy5zaG93bkNhcmRzICs9IHRoaXMucGFyc2UoaXRlbXMpO1xuICAgIC8vIHRoaXMubGlzdEVsLnN0eWxlLmhlaWdodCA9IGAke3RoaXMubGlzdEVsLnNjcm9sbEhlaWdodH1weGA7XG4gICAgLy8gcmV0dXJuIHRoaXMuc2hvd25DYXJkcztcbiAgfVxuXG4gIC8vIFRPRE86INCS0YvQvdC10YHRgtC4INCyIGFwaVxuICByZWxvYWRQYWdlKCkge1xuICAgIC8vIEFwaS5jYXRhbG9nLnNlbmQodGhpcy5vcHRpb25zLmFjdGlvbiwgbmV3IEZvcm1EYXRhKHRoaXMuZm9ybUVsKSwgcGFnZSk7XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGhpcy5mb3JtRWwpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgncGFnZScsIDEpO1xuXG4gICAgcmV0dXJuIGdldEZpbHRyZWRDYXRhbG9nKHRoaXMub3B0aW9ucy5hY3Rpb24sIGZvcm1EYXRhKVxuICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgdGhpcy5yZWxvYWQoZGF0YSk7XG5cbiAgICAgICAgaWYgKGRhdGEudXJsKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsIG51bGwsIGRhdGEudXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnRhZ3MgJiYgdGhpcy5icmVhZGN1bXBzKSB7XG4gICAgICAgICAgdGhpcy5zZXRCcmVhZGN1bXBzKGRhdGEudGFncy5icmVhZGNydW1wLCBkYXRhLnRhZ3MudGl0bGUsIGRhdGEudGFncy5oMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCAnYWN0aXZhdGVkVmFyaWFudHMnKSkge1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL3VwZGF0ZUFjdGl2YXRlZFZhcmlhbnRzJywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCAnaGlkZGVuVmFyaWFudHMnKSkge1xuICAgICAgICAgIHN0b3JlLmRpc3BhdGNoKCdmaWx0ZXJzL3VwZGF0ZUhpZGRlblZhcmlhbnRzJywgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGFsZXJ0KGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIH0pXG4gICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNsYXNzTmFtZXMuY2FyZExpc3RMb2FkaW5nKTtcbiAgICAgIH0pO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55\n")},58:function(module,exports){eval("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcz80YTRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58\n")},59:function(module,exports,__webpack_require__){eval("var getPrototypeOf = __webpack_require__(11);\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zdXBlclByb3BCYXNlLmpzPzlmNzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsRUFBa0I7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiI1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL2dldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3N1cGVyUHJvcEJhc2U7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///59\n")},9:function(module,exports){eval("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/M2M5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwiZmlsZSI6IjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")}},[[274,1,0]]]);