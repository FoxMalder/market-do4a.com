$pi: 3.14159265359;
$_precision: 10;

@function pow($base, $exp) {
  $value: $base;
  @if $exp > 1 {
    @for $i from 2 through $exp {
      $value: $value * $base;
    }
  }
  @if $exp < 1{
    @for $i from 0 through -$exp {
      $value: $value / $base;
    }
  }
  @return $value;
}

@function fact($num) {
  $fact: 1;
  @if $num > 0{
    @for $i from 1 through $num {
      $fact: $fact * $i;
    }
  }
  @return $fact;
}

@function _to_unitless_rad($angle) {
  @if unit($angle) == "deg" {
    $angle: $angle / 180deg * $pi;
  }
  @if unit($angle) == "rad" {
    $angle: $angle / 1rad;
  }
  @return $angle;
}

@function sin($angle){
  $a: _to_unitless_rad($angle);
  $sin: $a;
  @for $n from 1 through $_precision {
    $sin: $sin + (pow(-1, $n) / fact(2 * $n + 1) ) * pow($a, (2 * $n + 1));
  }
  @return $sin;
}

@function cos($angle){
  $a: _to_unitless_rad($angle);
  $cos: 1;
  @for $n from 1 through $_precision {
    $cos: $cos + ( pow(-1,$n) / fact(2*$n) ) * pow($a,2*$n);
  }
  @return $cos;
}

@function tan($angle){
  @return sin($angle) / cos($angle);
}

@function decimal-round($number, $digits: 0, $mode: round) {
  $n: 1;
  // $number must be a number
  @if type-of($number) != number {
    @warn '#{ $number } is not a number.';
    @return $number;
  }
  // $digits must be a unitless number
  @if type-of($digits) != number {
    @warn '#{ $digits } is not a number.';
    @return $number;
  } @else if not unitless($digits) {
    @warn '#{ $digits } has a unit.';
    @return $number;
  }
  @if $digits > 0 {
    @for $i from 1 through $digits {
      $n: $n * 10;
    }
  }
  @if $mode == round {
    @return round($number * $n) / $n;
  } @else if $mode == ceil {
    @return ceil($number * $n) / $n;
  } @else if $mode == floor {
    @return floor($number * $n) / $n;
  } @else {
    @warn '#{ $mode } is undefined keyword.';
    @return $number;
  }
}

// Get unitless values

@function parseInt($n) {
  @return $n / ($n * 0 + 1);
}

@mixin mre-height-block($sh-fontsize, $sh-desiredheight, $line-height: 1.5, $mre-border-width: 0, $rem-mode: false) {

  $mre-border-width-unit: unit($mre-border-width);
  $mre-border-width-value: parseInt($mre-border-width) !default;

  $sh-fontbase: 16;

  $sh-fontunit: unit($sh-fontsize);
  $sh-fontvalue: parseInt($sh-fontsize) !default;

  $sh-heightunit: unit($sh-desiredheight);
  $sh-heightvalue: parseInt($sh-desiredheight) !default;

  $mre-line-unit: unit($line-height);
  $mre-line-value: parseInt($line-height) !default;


  // If rems are enforced
  @if $rem-mode == false {
    @if $mre-line-unit != '' and $mre-line-unit == 'rem' {
      $mre-line-value: $mre-line-value * $sh-fontbase;
    }

    @if $mre-border-width-unit == 'rem' {
      $mre-border-width-value: $mre-border-width-value * $sh-fontbase;
    }

    // If the font size is in rems
    @if $sh-fontunit == 'rem' {
      $sh-fontvalue: $sh-fontvalue * $sh-fontbase;
    }
    // If the height is in rems
    @if $sh-heightunit == 'rem' {
      $sh-heightvalue: $sh-heightvalue * $sh-fontbase;
    }
  } @else {
    @if $mre-line-unit != '' and $mre-line-unit != 'rem' {
      $mre-line-value: $mre-line-value/$sh-fontbase;
    }

    // If the font size is in px
    @if $sh-fontunit != 'rem' {
      $sh-fontvalue: $sh-fontvalue/$sh-fontbase;
    }

    // If the height is in px
    @if $sh-heightunit != 'rem' and $sh-heightunit != false {
      $sh-heightvalue: $sh-heightvalue/$sh-fontbase;
    }

    // If the border is in px
    @if $mre-border-width-unit != 'rem' and $sh-heightunit != false {
      $mre-border-width-value: $mre-border-width-value/$sh-fontbase;
    }
  }

  $sh-lineheight: 0;
  $sh-lineheightrealised: 0;

  @if $mre-line-unit != '' {
    $sh-lineheightrealised: $mre-line-value;
    $sh-lineheight: decimal-round($mre-line-value / $sh-fontvalue, 3, ceil);
  } @else {
    $sh-lineheight: $mre-line-value;
    $sh-lineheightrealised: $sh-fontvalue * $mre-line-value;
  }

  // Set the offset to 0 and override if a height is set
  $sh-offset: 0 !default;

  @if $sh-heightunit != false {

    // Calculate the remaining space available and halve it
    $sh-offset: ($sh-heightvalue - $sh-lineheightrealised)/2 - $mre-border-width-value;

  }

  //@include font-size()

  font-size: if($rem-mode, $sh-fontvalue + rem, $sh-fontvalue * 1px);
  line-height: $sh-lineheight;

  // Only add padding if the offset is truthy
  @if $sh-offset > 0 {

    // Determine whether rems or pixels
    $vpadding: if($rem-mode, $sh-offset + rem, $sh-offset * 1px);
    padding-bottom: $vpadding;
    padding-top: $vpadding;
  }

}

@mixin responsive-ratio($x,$y, $pseudo: false) {
  $padding: unquote(( $y / $x ) * 100 + '%');
  @if $pseudo {
    &::before {
      @include pseudo($pos: relative);
      width: 100%;
      padding-top: $padding;
    }
  } @else {
    padding-top: $padding;
  }
}


@mixin skew-revert($w, $h, $angle) {
  $scale: (1 + tan($angle) * $h / $w);
  object-fit: cover;
  width: $w;
  height: $h;
  transform: matrix($scale, 0, tan($angle), $scale, 0, 0);
}

@mixin skew-cover-auto-height($w, $h, $angle) {
  $scale: (1 + tan($angle) * $h / $w);
  width: $w;
  min-height: $h;
  //max-width: none;
  max-height: none;
  transform: matrix($scale, 0, tan($angle), $scale, 0, 0);
}

@mixin letter-spacing($unit, $return: 'em', $base: '16') {
  @if $return == 'em' {
    letter-spacing: unquote(($unit) / 1000 + 'em');
  } @else {
    letter-spacing: unquote(($unit * $base) / 1000 + 'px');
  }
}

@mixin dev() {
  $dev-mode: false !default;

  @if $dev-mode {
    @content;
  }
}

@mixin title {
  font: {
    family: $font-family-bender;
    style: italic;
    weight: 900;
  }
  text-transform: uppercase;
  letter-spacing: .02em;
}

@mixin make-font-inter {
  font-family: $font-family-inter-ui;
  @supports (font-variation-settings: normal) {
    font-family: $font-family-inter-ui-var;
  }
}

%button-reset {
  padding: 0;
  border: 0;
  background-color: transparent;
  color: inherit;
  font: inherit;
  cursor: pointer;

  &:focus,
  &:active {
    outline: none;
  }
}
